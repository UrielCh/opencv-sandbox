#ifndef __JSOPENCV_GENERATED_FUNCS_H__
#define __JSOPENCV_GENERATED_FUNCS_H__
#include <napi.h>
#include <../node/js_as_py.hpp>
#include <../node/cv2_convert.hpp>
#include <opencv2/opencv.hpp>
#include <jsopencv_generated_enums.h>
#include <cv2_macro.hpp>

using namespace cv;

static Napi::Value jsopencv_cv_AKAZE_create(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_descriptor_type = NULL;
    AKAZE_DescriptorType descriptor_type=AKAZE::DESCRIPTOR_MLDB;
    Napi::Value* jsobj_descriptor_size = NULL;
    int descriptor_size=0;
    Napi::Value* jsobj_descriptor_channels = NULL;
    int descriptor_channels=3;
    Napi::Value* jsobj_threshold = NULL;
    float threshold=0.001f;
    Napi::Value* jsobj_nOctaves = NULL;
    int nOctaves=4;
    Napi::Value* jsobj_nOctaveLayers = NULL;
    int nOctaveLayers=4;
    Napi::Value* jsobj_diffusivity = NULL;
    KAZE_DiffusivityType diffusivity=KAZE::DIFF_PM_G2;
    Ptr<AKAZE> retval;

    const char* keywords[] = { "descriptor_type", "descriptor_size", "descriptor_channels", "threshold", "nOctaves", "nOctaveLayers", "diffusivity", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OOOOOOO:AKAZE_create", (char**)keywords, &jsobj_descriptor_type, &jsobj_descriptor_size, &jsobj_descriptor_channels, &jsobj_threshold, &jsobj_nOctaves, &jsobj_nOctaveLayers, &jsobj_diffusivity) &&
        jsopencv_to_safe(jsobj_descriptor_type, descriptor_type, ArgInfo("descriptor_type", 0)) &&
        jsopencv_to_safe(jsobj_descriptor_size, descriptor_size, ArgInfo("descriptor_size", 0)) &&
        jsopencv_to_safe(jsobj_descriptor_channels, descriptor_channels, ArgInfo("descriptor_channels", 0)) &&
        jsopencv_to_safe(jsobj_threshold, threshold, ArgInfo("threshold", 0)) &&
        jsopencv_to_safe(jsobj_nOctaves, nOctaves, ArgInfo("nOctaves", 0)) &&
        jsopencv_to_safe(jsobj_nOctaveLayers, nOctaveLayers, ArgInfo("nOctaveLayers", 0)) &&
        jsopencv_to_safe(jsobj_diffusivity, diffusivity, ArgInfo("diffusivity", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::AKAZE::create(descriptor_type, descriptor_size, descriptor_channels, threshold, nOctaves, nOctaveLayers, diffusivity));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_AffineFeature_create(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_backend = NULL;
    Ptr<Feature2D> backend;
    Napi::Value* jsobj_maxTilt = NULL;
    int maxTilt=5;
    Napi::Value* jsobj_minTilt = NULL;
    int minTilt=0;
    Napi::Value* jsobj_tiltStep = NULL;
    float tiltStep=1.4142135623730951f;
    Napi::Value* jsobj_rotateStepBase = NULL;
    float rotateStepBase=72;
    Ptr<AffineFeature> retval;

    const char* keywords[] = { "backend", "maxTilt", "minTilt", "tiltStep", "rotateStepBase", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOOO:AffineFeature_create", (char**)keywords, &jsobj_backend, &jsobj_maxTilt, &jsobj_minTilt, &jsobj_tiltStep, &jsobj_rotateStepBase) &&
        jsopencv_to_safe(jsobj_backend, backend, ArgInfo("backend", 0)) &&
        jsopencv_to_safe(jsobj_maxTilt, maxTilt, ArgInfo("maxTilt", 0)) &&
        jsopencv_to_safe(jsobj_minTilt, minTilt, ArgInfo("minTilt", 0)) &&
        jsopencv_to_safe(jsobj_tiltStep, tiltStep, ArgInfo("tiltStep", 0)) &&
        jsopencv_to_safe(jsobj_rotateStepBase, rotateStepBase, ArgInfo("rotateStepBase", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::AffineFeature::create(backend, maxTilt, minTilt, tiltStep, rotateStepBase));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_AgastFeatureDetector_create(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_threshold = NULL;
    int threshold=10;
    Napi::Value* jsobj_nonmaxSuppression = NULL;
    bool nonmaxSuppression=true;
    Napi::Value* jsobj_type = NULL;
    AgastFeatureDetector_DetectorType type=AgastFeatureDetector::OAST_9_16;
    Ptr<AgastFeatureDetector> retval;

    const char* keywords[] = { "threshold", "nonmaxSuppression", "type", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OOO:AgastFeatureDetector_create", (char**)keywords, &jsobj_threshold, &jsobj_nonmaxSuppression, &jsobj_type) &&
        jsopencv_to_safe(jsobj_threshold, threshold, ArgInfo("threshold", 0)) &&
        jsopencv_to_safe(jsobj_nonmaxSuppression, nonmaxSuppression, ArgInfo("nonmaxSuppression", 0)) &&
        jsopencv_to_safe(jsobj_type, type, ArgInfo("type", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::AgastFeatureDetector::create(threshold, nonmaxSuppression, type));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_BFMatcher_create(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_normType = NULL;
    int normType=NORM_L2;
    Napi::Value* jsobj_crossCheck = NULL;
    bool crossCheck=false;
    Ptr<BFMatcher> retval;

    const char* keywords[] = { "normType", "crossCheck", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OO:BFMatcher_create", (char**)keywords, &jsobj_normType, &jsobj_crossCheck) &&
        jsopencv_to_safe(jsobj_normType, normType, ArgInfo("normType", 0)) &&
        jsopencv_to_safe(jsobj_crossCheck, crossCheck, ArgInfo("crossCheck", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::BFMatcher::create(normType, crossCheck));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_BRISK_create(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(3);

    {
    Napi::Value* jsobj_thresh = NULL;
    int thresh=30;
    Napi::Value* jsobj_octaves = NULL;
    int octaves=3;
    Napi::Value* jsobj_patternScale = NULL;
    float patternScale=1.0f;
    Ptr<BRISK> retval;

    const char* keywords[] = { "thresh", "octaves", "patternScale", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OOO:BRISK_create", (char**)keywords, &jsobj_thresh, &jsobj_octaves, &jsobj_patternScale) &&
        jsopencv_to_safe(jsobj_thresh, thresh, ArgInfo("thresh", 0)) &&
        jsopencv_to_safe(jsobj_octaves, octaves, ArgInfo("octaves", 0)) &&
        jsopencv_to_safe(jsobj_patternScale, patternScale, ArgInfo("patternScale", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::BRISK::create(thresh, octaves, patternScale));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_radiusList = NULL;
    vector_float radiusList;
    Napi::Value* jsobj_numberList = NULL;
    vector_int numberList;
    Napi::Value* jsobj_dMax = NULL;
    float dMax=5.85f;
    Napi::Value* jsobj_dMin = NULL;
    float dMin=8.2f;
    Napi::Value* jsobj_indexChange = NULL;
    vector_int indexChange=std::vector<int>();
    Ptr<BRISK> retval;

    const char* keywords[] = { "radiusList", "numberList", "dMax", "dMin", "indexChange", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOO:BRISK_create", (char**)keywords, &jsobj_radiusList, &jsobj_numberList, &jsobj_dMax, &jsobj_dMin, &jsobj_indexChange) &&
        jsopencv_to_safe(jsobj_radiusList, radiusList, ArgInfo("radiusList", 0)) &&
        jsopencv_to_safe(jsobj_numberList, numberList, ArgInfo("numberList", 0)) &&
        jsopencv_to_safe(jsobj_dMax, dMax, ArgInfo("dMax", 0)) &&
        jsopencv_to_safe(jsobj_dMin, dMin, ArgInfo("dMin", 0)) &&
        jsopencv_to_safe(jsobj_indexChange, indexChange, ArgInfo("indexChange", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::BRISK::create(radiusList, numberList, dMax, dMin, indexChange));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_thresh = NULL;
    int thresh=0;
    Napi::Value* jsobj_octaves = NULL;
    int octaves=0;
    Napi::Value* jsobj_radiusList = NULL;
    vector_float radiusList;
    Napi::Value* jsobj_numberList = NULL;
    vector_int numberList;
    Napi::Value* jsobj_dMax = NULL;
    float dMax=5.85f;
    Napi::Value* jsobj_dMin = NULL;
    float dMin=8.2f;
    Napi::Value* jsobj_indexChange = NULL;
    vector_int indexChange=std::vector<int>();
    Ptr<BRISK> retval;

    const char* keywords[] = { "thresh", "octaves", "radiusList", "numberList", "dMax", "dMin", "indexChange", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOO:BRISK_create", (char**)keywords, &jsobj_thresh, &jsobj_octaves, &jsobj_radiusList, &jsobj_numberList, &jsobj_dMax, &jsobj_dMin, &jsobj_indexChange) &&
        jsopencv_to_safe(jsobj_thresh, thresh, ArgInfo("thresh", 0)) &&
        jsopencv_to_safe(jsobj_octaves, octaves, ArgInfo("octaves", 0)) &&
        jsopencv_to_safe(jsobj_radiusList, radiusList, ArgInfo("radiusList", 0)) &&
        jsopencv_to_safe(jsobj_numberList, numberList, ArgInfo("numberList", 0)) &&
        jsopencv_to_safe(jsobj_dMax, dMax, ArgInfo("dMax", 0)) &&
        jsopencv_to_safe(jsobj_dMin, dMin, ArgInfo("dMin", 0)) &&
        jsopencv_to_safe(jsobj_indexChange, indexChange, ArgInfo("indexChange", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::BRISK::create(thresh, octaves, radiusList, numberList, dMax, dMin, indexChange));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "BRISK_create");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_CamShift(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_probImage = NULL;
    Mat probImage;
    Napi::Value* jsobj_window = NULL;
    Rect window;
    Napi::Value* jsobj_criteria = NULL;
    TermCriteria criteria;
    RotatedRect retval;

    const char* keywords[] = { "probImage", "window", "criteria", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:CamShift", (char**)keywords, &jsobj_probImage, &jsobj_window, &jsobj_criteria) &&
        jsopencv_to_safe(jsobj_probImage, probImage, ArgInfo("probImage", 0)) &&
        jsopencv_to_safe(jsobj_window, window, ArgInfo("window", 1)) &&
        jsopencv_to_safe(jsobj_criteria, criteria, ArgInfo("criteria", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::CamShift(probImage, window, criteria));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, window));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_probImage = NULL;
    UMat probImage;
    Napi::Value* jsobj_window = NULL;
    Rect window;
    Napi::Value* jsobj_criteria = NULL;
    TermCriteria criteria;
    RotatedRect retval;

    const char* keywords[] = { "probImage", "window", "criteria", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:CamShift", (char**)keywords, &jsobj_probImage, &jsobj_window, &jsobj_criteria) &&
        jsopencv_to_safe(jsobj_probImage, probImage, ArgInfo("probImage", 0)) &&
        jsopencv_to_safe(jsobj_window, window, ArgInfo("window", 1)) &&
        jsopencv_to_safe(jsobj_criteria, criteria, ArgInfo("criteria", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::CamShift(probImage, window, criteria));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, window));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "CamShift");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_Canny(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(4);

    {
    Napi::Value* jsobj_image = NULL;
    Mat image;
    Napi::Value* jsobj_edges = NULL;
    Mat edges;
    Napi::Value* jsobj_threshold1 = NULL;
    double threshold1=0;
    Napi::Value* jsobj_threshold2 = NULL;
    double threshold2=0;
    Napi::Value* jsobj_apertureSize = NULL;
    int apertureSize=3;
    Napi::Value* jsobj_L2gradient = NULL;
    bool L2gradient=false;

    const char* keywords[] = { "image", "threshold1", "threshold2", "edges", "apertureSize", "L2gradient", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOO:Canny", (char**)keywords, &jsobj_image, &jsobj_threshold1, &jsobj_threshold2, &jsobj_edges, &jsobj_apertureSize, &jsobj_L2gradient) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_edges, edges, ArgInfo("edges", 1)) &&
        jsopencv_to_safe(jsobj_threshold1, threshold1, ArgInfo("threshold1", 0)) &&
        jsopencv_to_safe(jsobj_threshold2, threshold2, ArgInfo("threshold2", 0)) &&
        jsopencv_to_safe(jsobj_apertureSize, apertureSize, ArgInfo("apertureSize", 0)) &&
        jsopencv_to_safe(jsobj_L2gradient, L2gradient, ArgInfo("L2gradient", 0)))
    {
        ERRWRAP2_NAPI(info, cv::Canny(image, edges, threshold1, threshold2, apertureSize, L2gradient));
        return jsopencv_from(info, edges);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_image = NULL;
    UMat image;
    Napi::Value* jsobj_edges = NULL;
    UMat edges;
    Napi::Value* jsobj_threshold1 = NULL;
    double threshold1=0;
    Napi::Value* jsobj_threshold2 = NULL;
    double threshold2=0;
    Napi::Value* jsobj_apertureSize = NULL;
    int apertureSize=3;
    Napi::Value* jsobj_L2gradient = NULL;
    bool L2gradient=false;

    const char* keywords[] = { "image", "threshold1", "threshold2", "edges", "apertureSize", "L2gradient", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOO:Canny", (char**)keywords, &jsobj_image, &jsobj_threshold1, &jsobj_threshold2, &jsobj_edges, &jsobj_apertureSize, &jsobj_L2gradient) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_edges, edges, ArgInfo("edges", 1)) &&
        jsopencv_to_safe(jsobj_threshold1, threshold1, ArgInfo("threshold1", 0)) &&
        jsopencv_to_safe(jsobj_threshold2, threshold2, ArgInfo("threshold2", 0)) &&
        jsopencv_to_safe(jsobj_apertureSize, apertureSize, ArgInfo("apertureSize", 0)) &&
        jsopencv_to_safe(jsobj_L2gradient, L2gradient, ArgInfo("L2gradient", 0)))
    {
        ERRWRAP2_NAPI(info, cv::Canny(image, edges, threshold1, threshold2, apertureSize, L2gradient));
        return jsopencv_from(info, edges);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_dx = NULL;
    Mat dx;
    Napi::Value* jsobj_dy = NULL;
    Mat dy;
    Napi::Value* jsobj_edges = NULL;
    Mat edges;
    Napi::Value* jsobj_threshold1 = NULL;
    double threshold1=0;
    Napi::Value* jsobj_threshold2 = NULL;
    double threshold2=0;
    Napi::Value* jsobj_L2gradient = NULL;
    bool L2gradient=false;

    const char* keywords[] = { "dx", "dy", "threshold1", "threshold2", "edges", "L2gradient", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OO:Canny", (char**)keywords, &jsobj_dx, &jsobj_dy, &jsobj_threshold1, &jsobj_threshold2, &jsobj_edges, &jsobj_L2gradient) &&
        jsopencv_to_safe(jsobj_dx, dx, ArgInfo("dx", 0)) &&
        jsopencv_to_safe(jsobj_dy, dy, ArgInfo("dy", 0)) &&
        jsopencv_to_safe(jsobj_edges, edges, ArgInfo("edges", 1)) &&
        jsopencv_to_safe(jsobj_threshold1, threshold1, ArgInfo("threshold1", 0)) &&
        jsopencv_to_safe(jsobj_threshold2, threshold2, ArgInfo("threshold2", 0)) &&
        jsopencv_to_safe(jsobj_L2gradient, L2gradient, ArgInfo("L2gradient", 0)))
    {
        ERRWRAP2_NAPI(info, cv::Canny(dx, dy, edges, threshold1, threshold2, L2gradient));
        return jsopencv_from(info, edges);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_dx = NULL;
    UMat dx;
    Napi::Value* jsobj_dy = NULL;
    UMat dy;
    Napi::Value* jsobj_edges = NULL;
    UMat edges;
    Napi::Value* jsobj_threshold1 = NULL;
    double threshold1=0;
    Napi::Value* jsobj_threshold2 = NULL;
    double threshold2=0;
    Napi::Value* jsobj_L2gradient = NULL;
    bool L2gradient=false;

    const char* keywords[] = { "dx", "dy", "threshold1", "threshold2", "edges", "L2gradient", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OO:Canny", (char**)keywords, &jsobj_dx, &jsobj_dy, &jsobj_threshold1, &jsobj_threshold2, &jsobj_edges, &jsobj_L2gradient) &&
        jsopencv_to_safe(jsobj_dx, dx, ArgInfo("dx", 0)) &&
        jsopencv_to_safe(jsobj_dy, dy, ArgInfo("dy", 0)) &&
        jsopencv_to_safe(jsobj_edges, edges, ArgInfo("edges", 1)) &&
        jsopencv_to_safe(jsobj_threshold1, threshold1, ArgInfo("threshold1", 0)) &&
        jsopencv_to_safe(jsobj_threshold2, threshold2, ArgInfo("threshold2", 0)) &&
        jsopencv_to_safe(jsobj_L2gradient, L2gradient, ArgInfo("L2gradient", 0)))
    {
        ERRWRAP2_NAPI(info, cv::Canny(dx, dy, edges, threshold1, threshold2, L2gradient));
        return jsopencv_from(info, edges);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "Canny");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_CascadeClassifier_convert(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_oldcascade = NULL;
    String oldcascade;
    Napi::Value* jsobj_newcascade = NULL;
    String newcascade;
    bool retval;

    const char* keywords[] = { "oldcascade", "newcascade", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:CascadeClassifier_convert", (char**)keywords, &jsobj_oldcascade, &jsobj_newcascade) &&
        jsopencv_to_safe(jsobj_oldcascade, oldcascade, ArgInfo("oldcascade", 0)) &&
        jsopencv_to_safe(jsobj_newcascade, newcascade, ArgInfo("newcascade", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::CascadeClassifier::convert(oldcascade, newcascade));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_DISOpticalFlow_create(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_preset = NULL;
    int preset=DISOpticalFlow::PRESET_FAST;
    Ptr<DISOpticalFlow> retval;

    const char* keywords[] = { "preset", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|O:DISOpticalFlow_create", (char**)keywords, &jsobj_preset) &&
        jsopencv_to_safe(jsobj_preset, preset, ArgInfo("preset", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::DISOpticalFlow::create(preset));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_DescriptorMatcher_create(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_descriptorMatcherType = NULL;
    String descriptorMatcherType;
    Ptr<DescriptorMatcher> retval;

    const char* keywords[] = { "descriptorMatcherType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:DescriptorMatcher_create", (char**)keywords, &jsobj_descriptorMatcherType) &&
        jsopencv_to_safe(jsobj_descriptorMatcherType, descriptorMatcherType, ArgInfo("descriptorMatcherType", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::DescriptorMatcher::create(descriptorMatcherType));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_matcherType = NULL;
    DescriptorMatcher_MatcherType matcherType=static_cast<DescriptorMatcher_MatcherType>(0);
    Ptr<DescriptorMatcher> retval;

    const char* keywords[] = { "matcherType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:DescriptorMatcher_create", (char**)keywords, &jsobj_matcherType) &&
        jsopencv_to_safe(jsobj_matcherType, matcherType, ArgInfo("matcherType", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::DescriptorMatcher::create(matcherType));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "DescriptorMatcher_create");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_EMD(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_signature1 = NULL;
    Mat signature1;
    Napi::Value* jsobj_signature2 = NULL;
    Mat signature2;
    Napi::Value* jsobj_distType = NULL;
    int distType=0;
    Napi::Value* jsobj_cost = NULL;
    Mat cost;
    Napi::Value* jsobj_lowerBound = NULL;
    Ptr<float> lowerBound;
    Napi::Value* jsobj_flow = NULL;
    Mat flow;
    float retval;

    const char* keywords[] = { "signature1", "signature2", "distType", "cost", "lowerBound", "flow", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOO:EMD", (char**)keywords, &jsobj_signature1, &jsobj_signature2, &jsobj_distType, &jsobj_cost, &jsobj_lowerBound, &jsobj_flow) &&
        jsopencv_to_safe(jsobj_signature1, signature1, ArgInfo("signature1", 0)) &&
        jsopencv_to_safe(jsobj_signature2, signature2, ArgInfo("signature2", 0)) &&
        jsopencv_to_safe(jsobj_distType, distType, ArgInfo("distType", 0)) &&
        jsopencv_to_safe(jsobj_cost, cost, ArgInfo("cost", 0)) &&
        jsopencv_to_safe(jsobj_lowerBound, lowerBound, ArgInfo("lowerBound", 1)) &&
        jsopencv_to_safe(jsobj_flow, flow, ArgInfo("flow", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::wrapperEMD(signature1, signature2, distType, cost, lowerBound, flow));
        return Js_BuildValue(info, "(NNN)", jsopencv_from(info, retval), jsopencv_from(info, lowerBound), jsopencv_from(info, flow));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_signature1 = NULL;
    UMat signature1;
    Napi::Value* jsobj_signature2 = NULL;
    UMat signature2;
    Napi::Value* jsobj_distType = NULL;
    int distType=0;
    Napi::Value* jsobj_cost = NULL;
    UMat cost;
    Napi::Value* jsobj_lowerBound = NULL;
    Ptr<float> lowerBound;
    Napi::Value* jsobj_flow = NULL;
    UMat flow;
    float retval;

    const char* keywords[] = { "signature1", "signature2", "distType", "cost", "lowerBound", "flow", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOO:EMD", (char**)keywords, &jsobj_signature1, &jsobj_signature2, &jsobj_distType, &jsobj_cost, &jsobj_lowerBound, &jsobj_flow) &&
        jsopencv_to_safe(jsobj_signature1, signature1, ArgInfo("signature1", 0)) &&
        jsopencv_to_safe(jsobj_signature2, signature2, ArgInfo("signature2", 0)) &&
        jsopencv_to_safe(jsobj_distType, distType, ArgInfo("distType", 0)) &&
        jsopencv_to_safe(jsobj_cost, cost, ArgInfo("cost", 0)) &&
        jsopencv_to_safe(jsobj_lowerBound, lowerBound, ArgInfo("lowerBound", 1)) &&
        jsopencv_to_safe(jsobj_flow, flow, ArgInfo("flow", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::wrapperEMD(signature1, signature2, distType, cost, lowerBound, flow));
        return Js_BuildValue(info, "(NNN)", jsopencv_from(info, retval), jsopencv_from(info, lowerBound), jsopencv_from(info, flow));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "EMD");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_FaceDetectorYN_create(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_model = NULL;
    String model;
    Napi::Value* jsobj_config = NULL;
    String config;
    Napi::Value* jsobj_input_size = NULL;
    Size input_size;
    Napi::Value* jsobj_score_threshold = NULL;
    float score_threshold=0.9f;
    Napi::Value* jsobj_nms_threshold = NULL;
    float nms_threshold=0.3f;
    Napi::Value* jsobj_top_k = NULL;
    int top_k=5000;
    Napi::Value* jsobj_backend_id = NULL;
    int backend_id=0;
    Napi::Value* jsobj_target_id = NULL;
    int target_id=0;
    Ptr<FaceDetectorYN> retval;

    const char* keywords[] = { "model", "config", "input_size", "score_threshold", "nms_threshold", "top_k", "backend_id", "target_id", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOOOO:FaceDetectorYN_create", (char**)keywords, &jsobj_model, &jsobj_config, &jsobj_input_size, &jsobj_score_threshold, &jsobj_nms_threshold, &jsobj_top_k, &jsobj_backend_id, &jsobj_target_id) &&
        jsopencv_to_safe(jsobj_model, model, ArgInfo("model", 0)) &&
        jsopencv_to_safe(jsobj_config, config, ArgInfo("config", 0)) &&
        jsopencv_to_safe(jsobj_input_size, input_size, ArgInfo("input_size", 0)) &&
        jsopencv_to_safe(jsobj_score_threshold, score_threshold, ArgInfo("score_threshold", 0)) &&
        jsopencv_to_safe(jsobj_nms_threshold, nms_threshold, ArgInfo("nms_threshold", 0)) &&
        jsopencv_to_safe(jsobj_top_k, top_k, ArgInfo("top_k", 0)) &&
        jsopencv_to_safe(jsobj_backend_id, backend_id, ArgInfo("backend_id", 0)) &&
        jsopencv_to_safe(jsobj_target_id, target_id, ArgInfo("target_id", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::FaceDetectorYN::create(model, config, input_size, score_threshold, nms_threshold, top_k, backend_id, target_id));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_FaceRecognizerSF_create(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_model = NULL;
    String model;
    Napi::Value* jsobj_config = NULL;
    String config;
    Napi::Value* jsobj_backend_id = NULL;
    int backend_id=0;
    Napi::Value* jsobj_target_id = NULL;
    int target_id=0;
    Ptr<FaceRecognizerSF> retval;

    const char* keywords[] = { "model", "config", "backend_id", "target_id", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:FaceRecognizerSF_create", (char**)keywords, &jsobj_model, &jsobj_config, &jsobj_backend_id, &jsobj_target_id) &&
        jsopencv_to_safe(jsobj_model, model, ArgInfo("model", 0)) &&
        jsopencv_to_safe(jsobj_config, config, ArgInfo("config", 0)) &&
        jsopencv_to_safe(jsobj_backend_id, backend_id, ArgInfo("backend_id", 0)) &&
        jsopencv_to_safe(jsobj_target_id, target_id, ArgInfo("target_id", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::FaceRecognizerSF::create(model, config, backend_id, target_id));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_FarnebackOpticalFlow_create(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_numLevels = NULL;
    int numLevels=5;
    Napi::Value* jsobj_pyrScale = NULL;
    double pyrScale=0.5;
    Napi::Value* jsobj_fastPyramids = NULL;
    bool fastPyramids=false;
    Napi::Value* jsobj_winSize = NULL;
    int winSize=13;
    Napi::Value* jsobj_numIters = NULL;
    int numIters=10;
    Napi::Value* jsobj_polyN = NULL;
    int polyN=5;
    Napi::Value* jsobj_polySigma = NULL;
    double polySigma=1.1;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;
    Ptr<FarnebackOpticalFlow> retval;

    const char* keywords[] = { "numLevels", "pyrScale", "fastPyramids", "winSize", "numIters", "polyN", "polySigma", "flags", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OOOOOOOO:FarnebackOpticalFlow_create", (char**)keywords, &jsobj_numLevels, &jsobj_pyrScale, &jsobj_fastPyramids, &jsobj_winSize, &jsobj_numIters, &jsobj_polyN, &jsobj_polySigma, &jsobj_flags) &&
        jsopencv_to_safe(jsobj_numLevels, numLevels, ArgInfo("numLevels", 0)) &&
        jsopencv_to_safe(jsobj_pyrScale, pyrScale, ArgInfo("pyrScale", 0)) &&
        jsopencv_to_safe(jsobj_fastPyramids, fastPyramids, ArgInfo("fastPyramids", 0)) &&
        jsopencv_to_safe(jsobj_winSize, winSize, ArgInfo("winSize", 0)) &&
        jsopencv_to_safe(jsobj_numIters, numIters, ArgInfo("numIters", 0)) &&
        jsopencv_to_safe(jsobj_polyN, polyN, ArgInfo("polyN", 0)) &&
        jsopencv_to_safe(jsobj_polySigma, polySigma, ArgInfo("polySigma", 0)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::FarnebackOpticalFlow::create(numLevels, pyrScale, fastPyramids, winSize, numIters, polyN, polySigma, flags));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_FastFeatureDetector_create(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_threshold = NULL;
    int threshold=10;
    Napi::Value* jsobj_nonmaxSuppression = NULL;
    bool nonmaxSuppression=true;
    Napi::Value* jsobj_type = NULL;
    FastFeatureDetector_DetectorType type=FastFeatureDetector::TYPE_9_16;
    Ptr<FastFeatureDetector> retval;

    const char* keywords[] = { "threshold", "nonmaxSuppression", "type", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OOO:FastFeatureDetector_create", (char**)keywords, &jsobj_threshold, &jsobj_nonmaxSuppression, &jsobj_type) &&
        jsopencv_to_safe(jsobj_threshold, threshold, ArgInfo("threshold", 0)) &&
        jsopencv_to_safe(jsobj_nonmaxSuppression, nonmaxSuppression, ArgInfo("nonmaxSuppression", 0)) &&
        jsopencv_to_safe(jsobj_type, type, ArgInfo("type", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::FastFeatureDetector::create(threshold, nonmaxSuppression, type));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_FlannBasedMatcher_create(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Ptr<FlannBasedMatcher> retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::FlannBasedMatcher::create());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_GFTTDetector_create(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_maxCorners = NULL;
    int maxCorners=1000;
    Napi::Value* jsobj_qualityLevel = NULL;
    double qualityLevel=0.01;
    Napi::Value* jsobj_minDistance = NULL;
    double minDistance=1;
    Napi::Value* jsobj_blockSize = NULL;
    int blockSize=3;
    Napi::Value* jsobj_useHarrisDetector = NULL;
    bool useHarrisDetector=false;
    Napi::Value* jsobj_k = NULL;
    double k=0.04;
    Ptr<GFTTDetector> retval;

    const char* keywords[] = { "maxCorners", "qualityLevel", "minDistance", "blockSize", "useHarrisDetector", "k", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OOOOOO:GFTTDetector_create", (char**)keywords, &jsobj_maxCorners, &jsobj_qualityLevel, &jsobj_minDistance, &jsobj_blockSize, &jsobj_useHarrisDetector, &jsobj_k) &&
        jsopencv_to_safe(jsobj_maxCorners, maxCorners, ArgInfo("maxCorners", 0)) &&
        jsopencv_to_safe(jsobj_qualityLevel, qualityLevel, ArgInfo("qualityLevel", 0)) &&
        jsopencv_to_safe(jsobj_minDistance, minDistance, ArgInfo("minDistance", 0)) &&
        jsopencv_to_safe(jsobj_blockSize, blockSize, ArgInfo("blockSize", 0)) &&
        jsopencv_to_safe(jsobj_useHarrisDetector, useHarrisDetector, ArgInfo("useHarrisDetector", 0)) &&
        jsopencv_to_safe(jsobj_k, k, ArgInfo("k", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::GFTTDetector::create(maxCorners, qualityLevel, minDistance, blockSize, useHarrisDetector, k));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_maxCorners = NULL;
    int maxCorners=0;
    Napi::Value* jsobj_qualityLevel = NULL;
    double qualityLevel=0;
    Napi::Value* jsobj_minDistance = NULL;
    double minDistance=0;
    Napi::Value* jsobj_blockSize = NULL;
    int blockSize=0;
    Napi::Value* jsobj_gradiantSize = NULL;
    int gradiantSize=0;
    Napi::Value* jsobj_useHarrisDetector = NULL;
    bool useHarrisDetector=false;
    Napi::Value* jsobj_k = NULL;
    double k=0.04;
    Ptr<GFTTDetector> retval;

    const char* keywords[] = { "maxCorners", "qualityLevel", "minDistance", "blockSize", "gradiantSize", "useHarrisDetector", "k", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOO|OO:GFTTDetector_create", (char**)keywords, &jsobj_maxCorners, &jsobj_qualityLevel, &jsobj_minDistance, &jsobj_blockSize, &jsobj_gradiantSize, &jsobj_useHarrisDetector, &jsobj_k) &&
        jsopencv_to_safe(jsobj_maxCorners, maxCorners, ArgInfo("maxCorners", 0)) &&
        jsopencv_to_safe(jsobj_qualityLevel, qualityLevel, ArgInfo("qualityLevel", 0)) &&
        jsopencv_to_safe(jsobj_minDistance, minDistance, ArgInfo("minDistance", 0)) &&
        jsopencv_to_safe(jsobj_blockSize, blockSize, ArgInfo("blockSize", 0)) &&
        jsopencv_to_safe(jsobj_gradiantSize, gradiantSize, ArgInfo("gradiantSize", 0)) &&
        jsopencv_to_safe(jsobj_useHarrisDetector, useHarrisDetector, ArgInfo("useHarrisDetector", 0)) &&
        jsopencv_to_safe(jsobj_k, k, ArgInfo("k", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::GFTTDetector::create(maxCorners, qualityLevel, minDistance, blockSize, gradiantSize, useHarrisDetector, k));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "GFTTDetector_create");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_GaussianBlur(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_ksize = NULL;
    Size ksize;
    Napi::Value* jsobj_sigmaX = NULL;
    double sigmaX=0;
    Napi::Value* jsobj_sigmaY = NULL;
    double sigmaY=0;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_DEFAULT;

    const char* keywords[] = { "src", "ksize", "sigmaX", "dst", "sigmaY", "borderType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOO:GaussianBlur", (char**)keywords, &jsobj_src, &jsobj_ksize, &jsobj_sigmaX, &jsobj_dst, &jsobj_sigmaY, &jsobj_borderType) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_ksize, ksize, ArgInfo("ksize", 0)) &&
        jsopencv_to_safe(jsobj_sigmaX, sigmaX, ArgInfo("sigmaX", 0)) &&
        jsopencv_to_safe(jsobj_sigmaY, sigmaY, ArgInfo("sigmaY", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)))
    {
        ERRWRAP2_NAPI(info, cv::GaussianBlur(src, dst, ksize, sigmaX, sigmaY, borderType));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_ksize = NULL;
    Size ksize;
    Napi::Value* jsobj_sigmaX = NULL;
    double sigmaX=0;
    Napi::Value* jsobj_sigmaY = NULL;
    double sigmaY=0;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_DEFAULT;

    const char* keywords[] = { "src", "ksize", "sigmaX", "dst", "sigmaY", "borderType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOO:GaussianBlur", (char**)keywords, &jsobj_src, &jsobj_ksize, &jsobj_sigmaX, &jsobj_dst, &jsobj_sigmaY, &jsobj_borderType) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_ksize, ksize, ArgInfo("ksize", 0)) &&
        jsopencv_to_safe(jsobj_sigmaX, sigmaX, ArgInfo("sigmaX", 0)) &&
        jsopencv_to_safe(jsobj_sigmaY, sigmaY, ArgInfo("sigmaY", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)))
    {
        ERRWRAP2_NAPI(info, cv::GaussianBlur(src, dst, ksize, sigmaX, sigmaY, borderType));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "GaussianBlur");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_HOGDescriptor_getDaimlerPeopleDetector(const Napi::CallbackInfo &info)
{
    using namespace cv;

    std::vector<float> retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::HOGDescriptor::getDaimlerPeopleDetector());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_HOGDescriptor_getDefaultPeopleDetector(const Napi::CallbackInfo &info)
{
    using namespace cv;

    std::vector<float> retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::HOGDescriptor::getDefaultPeopleDetector());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_HoughCircles(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_image = NULL;
    Mat image;
    Napi::Value* jsobj_circles = NULL;
    Mat circles;
    Napi::Value* jsobj_method = NULL;
    int method=0;
    Napi::Value* jsobj_dp = NULL;
    double dp=0;
    Napi::Value* jsobj_minDist = NULL;
    double minDist=0;
    Napi::Value* jsobj_param1 = NULL;
    double param1=100;
    Napi::Value* jsobj_param2 = NULL;
    double param2=100;
    Napi::Value* jsobj_minRadius = NULL;
    int minRadius=0;
    Napi::Value* jsobj_maxRadius = NULL;
    int maxRadius=0;

    const char* keywords[] = { "image", "method", "dp", "minDist", "circles", "param1", "param2", "minRadius", "maxRadius", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOOOO:HoughCircles", (char**)keywords, &jsobj_image, &jsobj_method, &jsobj_dp, &jsobj_minDist, &jsobj_circles, &jsobj_param1, &jsobj_param2, &jsobj_minRadius, &jsobj_maxRadius) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_circles, circles, ArgInfo("circles", 1)) &&
        jsopencv_to_safe(jsobj_method, method, ArgInfo("method", 0)) &&
        jsopencv_to_safe(jsobj_dp, dp, ArgInfo("dp", 0)) &&
        jsopencv_to_safe(jsobj_minDist, minDist, ArgInfo("minDist", 0)) &&
        jsopencv_to_safe(jsobj_param1, param1, ArgInfo("param1", 0)) &&
        jsopencv_to_safe(jsobj_param2, param2, ArgInfo("param2", 0)) &&
        jsopencv_to_safe(jsobj_minRadius, minRadius, ArgInfo("minRadius", 0)) &&
        jsopencv_to_safe(jsobj_maxRadius, maxRadius, ArgInfo("maxRadius", 0)))
    {
        ERRWRAP2_NAPI(info, cv::HoughCircles(image, circles, method, dp, minDist, param1, param2, minRadius, maxRadius));
        return jsopencv_from(info, circles);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_image = NULL;
    UMat image;
    Napi::Value* jsobj_circles = NULL;
    UMat circles;
    Napi::Value* jsobj_method = NULL;
    int method=0;
    Napi::Value* jsobj_dp = NULL;
    double dp=0;
    Napi::Value* jsobj_minDist = NULL;
    double minDist=0;
    Napi::Value* jsobj_param1 = NULL;
    double param1=100;
    Napi::Value* jsobj_param2 = NULL;
    double param2=100;
    Napi::Value* jsobj_minRadius = NULL;
    int minRadius=0;
    Napi::Value* jsobj_maxRadius = NULL;
    int maxRadius=0;

    const char* keywords[] = { "image", "method", "dp", "minDist", "circles", "param1", "param2", "minRadius", "maxRadius", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOOOO:HoughCircles", (char**)keywords, &jsobj_image, &jsobj_method, &jsobj_dp, &jsobj_minDist, &jsobj_circles, &jsobj_param1, &jsobj_param2, &jsobj_minRadius, &jsobj_maxRadius) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_circles, circles, ArgInfo("circles", 1)) &&
        jsopencv_to_safe(jsobj_method, method, ArgInfo("method", 0)) &&
        jsopencv_to_safe(jsobj_dp, dp, ArgInfo("dp", 0)) &&
        jsopencv_to_safe(jsobj_minDist, minDist, ArgInfo("minDist", 0)) &&
        jsopencv_to_safe(jsobj_param1, param1, ArgInfo("param1", 0)) &&
        jsopencv_to_safe(jsobj_param2, param2, ArgInfo("param2", 0)) &&
        jsopencv_to_safe(jsobj_minRadius, minRadius, ArgInfo("minRadius", 0)) &&
        jsopencv_to_safe(jsobj_maxRadius, maxRadius, ArgInfo("maxRadius", 0)))
    {
        ERRWRAP2_NAPI(info, cv::HoughCircles(image, circles, method, dp, minDist, param1, param2, minRadius, maxRadius));
        return jsopencv_from(info, circles);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "HoughCircles");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_HoughLines(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_image = NULL;
    Mat image;
    Napi::Value* jsobj_lines = NULL;
    Mat lines;
    Napi::Value* jsobj_rho = NULL;
    double rho=0;
    Napi::Value* jsobj_theta = NULL;
    double theta=0;
    Napi::Value* jsobj_threshold = NULL;
    int threshold=0;
    Napi::Value* jsobj_srn = NULL;
    double srn=0;
    Napi::Value* jsobj_stn = NULL;
    double stn=0;
    Napi::Value* jsobj_min_theta = NULL;
    double min_theta=0;
    Napi::Value* jsobj_max_theta = NULL;
    double max_theta=CV_PI;

    const char* keywords[] = { "image", "rho", "theta", "threshold", "lines", "srn", "stn", "min_theta", "max_theta", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOOOO:HoughLines", (char**)keywords, &jsobj_image, &jsobj_rho, &jsobj_theta, &jsobj_threshold, &jsobj_lines, &jsobj_srn, &jsobj_stn, &jsobj_min_theta, &jsobj_max_theta) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_lines, lines, ArgInfo("lines", 1)) &&
        jsopencv_to_safe(jsobj_rho, rho, ArgInfo("rho", 0)) &&
        jsopencv_to_safe(jsobj_theta, theta, ArgInfo("theta", 0)) &&
        jsopencv_to_safe(jsobj_threshold, threshold, ArgInfo("threshold", 0)) &&
        jsopencv_to_safe(jsobj_srn, srn, ArgInfo("srn", 0)) &&
        jsopencv_to_safe(jsobj_stn, stn, ArgInfo("stn", 0)) &&
        jsopencv_to_safe(jsobj_min_theta, min_theta, ArgInfo("min_theta", 0)) &&
        jsopencv_to_safe(jsobj_max_theta, max_theta, ArgInfo("max_theta", 0)))
    {
        ERRWRAP2_NAPI(info, cv::HoughLines(image, lines, rho, theta, threshold, srn, stn, min_theta, max_theta));
        return jsopencv_from(info, lines);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_image = NULL;
    UMat image;
    Napi::Value* jsobj_lines = NULL;
    UMat lines;
    Napi::Value* jsobj_rho = NULL;
    double rho=0;
    Napi::Value* jsobj_theta = NULL;
    double theta=0;
    Napi::Value* jsobj_threshold = NULL;
    int threshold=0;
    Napi::Value* jsobj_srn = NULL;
    double srn=0;
    Napi::Value* jsobj_stn = NULL;
    double stn=0;
    Napi::Value* jsobj_min_theta = NULL;
    double min_theta=0;
    Napi::Value* jsobj_max_theta = NULL;
    double max_theta=CV_PI;

    const char* keywords[] = { "image", "rho", "theta", "threshold", "lines", "srn", "stn", "min_theta", "max_theta", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOOOO:HoughLines", (char**)keywords, &jsobj_image, &jsobj_rho, &jsobj_theta, &jsobj_threshold, &jsobj_lines, &jsobj_srn, &jsobj_stn, &jsobj_min_theta, &jsobj_max_theta) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_lines, lines, ArgInfo("lines", 1)) &&
        jsopencv_to_safe(jsobj_rho, rho, ArgInfo("rho", 0)) &&
        jsopencv_to_safe(jsobj_theta, theta, ArgInfo("theta", 0)) &&
        jsopencv_to_safe(jsobj_threshold, threshold, ArgInfo("threshold", 0)) &&
        jsopencv_to_safe(jsobj_srn, srn, ArgInfo("srn", 0)) &&
        jsopencv_to_safe(jsobj_stn, stn, ArgInfo("stn", 0)) &&
        jsopencv_to_safe(jsobj_min_theta, min_theta, ArgInfo("min_theta", 0)) &&
        jsopencv_to_safe(jsobj_max_theta, max_theta, ArgInfo("max_theta", 0)))
    {
        ERRWRAP2_NAPI(info, cv::HoughLines(image, lines, rho, theta, threshold, srn, stn, min_theta, max_theta));
        return jsopencv_from(info, lines);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "HoughLines");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_HoughLinesP(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_image = NULL;
    Mat image;
    Napi::Value* jsobj_lines = NULL;
    Mat lines;
    Napi::Value* jsobj_rho = NULL;
    double rho=0;
    Napi::Value* jsobj_theta = NULL;
    double theta=0;
    Napi::Value* jsobj_threshold = NULL;
    int threshold=0;
    Napi::Value* jsobj_minLineLength = NULL;
    double minLineLength=0;
    Napi::Value* jsobj_maxLineGap = NULL;
    double maxLineGap=0;

    const char* keywords[] = { "image", "rho", "theta", "threshold", "lines", "minLineLength", "maxLineGap", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOO:HoughLinesP", (char**)keywords, &jsobj_image, &jsobj_rho, &jsobj_theta, &jsobj_threshold, &jsobj_lines, &jsobj_minLineLength, &jsobj_maxLineGap) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_lines, lines, ArgInfo("lines", 1)) &&
        jsopencv_to_safe(jsobj_rho, rho, ArgInfo("rho", 0)) &&
        jsopencv_to_safe(jsobj_theta, theta, ArgInfo("theta", 0)) &&
        jsopencv_to_safe(jsobj_threshold, threshold, ArgInfo("threshold", 0)) &&
        jsopencv_to_safe(jsobj_minLineLength, minLineLength, ArgInfo("minLineLength", 0)) &&
        jsopencv_to_safe(jsobj_maxLineGap, maxLineGap, ArgInfo("maxLineGap", 0)))
    {
        ERRWRAP2_NAPI(info, cv::HoughLinesP(image, lines, rho, theta, threshold, minLineLength, maxLineGap));
        return jsopencv_from(info, lines);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_image = NULL;
    UMat image;
    Napi::Value* jsobj_lines = NULL;
    UMat lines;
    Napi::Value* jsobj_rho = NULL;
    double rho=0;
    Napi::Value* jsobj_theta = NULL;
    double theta=0;
    Napi::Value* jsobj_threshold = NULL;
    int threshold=0;
    Napi::Value* jsobj_minLineLength = NULL;
    double minLineLength=0;
    Napi::Value* jsobj_maxLineGap = NULL;
    double maxLineGap=0;

    const char* keywords[] = { "image", "rho", "theta", "threshold", "lines", "minLineLength", "maxLineGap", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOO:HoughLinesP", (char**)keywords, &jsobj_image, &jsobj_rho, &jsobj_theta, &jsobj_threshold, &jsobj_lines, &jsobj_minLineLength, &jsobj_maxLineGap) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_lines, lines, ArgInfo("lines", 1)) &&
        jsopencv_to_safe(jsobj_rho, rho, ArgInfo("rho", 0)) &&
        jsopencv_to_safe(jsobj_theta, theta, ArgInfo("theta", 0)) &&
        jsopencv_to_safe(jsobj_threshold, threshold, ArgInfo("threshold", 0)) &&
        jsopencv_to_safe(jsobj_minLineLength, minLineLength, ArgInfo("minLineLength", 0)) &&
        jsopencv_to_safe(jsobj_maxLineGap, maxLineGap, ArgInfo("maxLineGap", 0)))
    {
        ERRWRAP2_NAPI(info, cv::HoughLinesP(image, lines, rho, theta, threshold, minLineLength, maxLineGap));
        return jsopencv_from(info, lines);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "HoughLinesP");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_HoughLinesPointSet(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_point = NULL;
    Mat point;
    Napi::Value* jsobj_lines = NULL;
    Mat lines;
    Napi::Value* jsobj_lines_max = NULL;
    int lines_max=0;
    Napi::Value* jsobj_threshold = NULL;
    int threshold=0;
    Napi::Value* jsobj_min_rho = NULL;
    double min_rho=0;
    Napi::Value* jsobj_max_rho = NULL;
    double max_rho=0;
    Napi::Value* jsobj_rho_step = NULL;
    double rho_step=0;
    Napi::Value* jsobj_min_theta = NULL;
    double min_theta=0;
    Napi::Value* jsobj_max_theta = NULL;
    double max_theta=0;
    Napi::Value* jsobj_theta_step = NULL;
    double theta_step=0;

    const char* keywords[] = { "point", "lines_max", "threshold", "min_rho", "max_rho", "rho_step", "min_theta", "max_theta", "theta_step", "lines", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOOOOO|O:HoughLinesPointSet", (char**)keywords, &jsobj_point, &jsobj_lines_max, &jsobj_threshold, &jsobj_min_rho, &jsobj_max_rho, &jsobj_rho_step, &jsobj_min_theta, &jsobj_max_theta, &jsobj_theta_step, &jsobj_lines) &&
        jsopencv_to_safe(jsobj_point, point, ArgInfo("point", 0)) &&
        jsopencv_to_safe(jsobj_lines, lines, ArgInfo("lines", 1)) &&
        jsopencv_to_safe(jsobj_lines_max, lines_max, ArgInfo("lines_max", 0)) &&
        jsopencv_to_safe(jsobj_threshold, threshold, ArgInfo("threshold", 0)) &&
        jsopencv_to_safe(jsobj_min_rho, min_rho, ArgInfo("min_rho", 0)) &&
        jsopencv_to_safe(jsobj_max_rho, max_rho, ArgInfo("max_rho", 0)) &&
        jsopencv_to_safe(jsobj_rho_step, rho_step, ArgInfo("rho_step", 0)) &&
        jsopencv_to_safe(jsobj_min_theta, min_theta, ArgInfo("min_theta", 0)) &&
        jsopencv_to_safe(jsobj_max_theta, max_theta, ArgInfo("max_theta", 0)) &&
        jsopencv_to_safe(jsobj_theta_step, theta_step, ArgInfo("theta_step", 0)))
    {
        ERRWRAP2_NAPI(info, cv::HoughLinesPointSet(point, lines, lines_max, threshold, min_rho, max_rho, rho_step, min_theta, max_theta, theta_step));
        return jsopencv_from(info, lines);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_point = NULL;
    UMat point;
    Napi::Value* jsobj_lines = NULL;
    UMat lines;
    Napi::Value* jsobj_lines_max = NULL;
    int lines_max=0;
    Napi::Value* jsobj_threshold = NULL;
    int threshold=0;
    Napi::Value* jsobj_min_rho = NULL;
    double min_rho=0;
    Napi::Value* jsobj_max_rho = NULL;
    double max_rho=0;
    Napi::Value* jsobj_rho_step = NULL;
    double rho_step=0;
    Napi::Value* jsobj_min_theta = NULL;
    double min_theta=0;
    Napi::Value* jsobj_max_theta = NULL;
    double max_theta=0;
    Napi::Value* jsobj_theta_step = NULL;
    double theta_step=0;

    const char* keywords[] = { "point", "lines_max", "threshold", "min_rho", "max_rho", "rho_step", "min_theta", "max_theta", "theta_step", "lines", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOOOOO|O:HoughLinesPointSet", (char**)keywords, &jsobj_point, &jsobj_lines_max, &jsobj_threshold, &jsobj_min_rho, &jsobj_max_rho, &jsobj_rho_step, &jsobj_min_theta, &jsobj_max_theta, &jsobj_theta_step, &jsobj_lines) &&
        jsopencv_to_safe(jsobj_point, point, ArgInfo("point", 0)) &&
        jsopencv_to_safe(jsobj_lines, lines, ArgInfo("lines", 1)) &&
        jsopencv_to_safe(jsobj_lines_max, lines_max, ArgInfo("lines_max", 0)) &&
        jsopencv_to_safe(jsobj_threshold, threshold, ArgInfo("threshold", 0)) &&
        jsopencv_to_safe(jsobj_min_rho, min_rho, ArgInfo("min_rho", 0)) &&
        jsopencv_to_safe(jsobj_max_rho, max_rho, ArgInfo("max_rho", 0)) &&
        jsopencv_to_safe(jsobj_rho_step, rho_step, ArgInfo("rho_step", 0)) &&
        jsopencv_to_safe(jsobj_min_theta, min_theta, ArgInfo("min_theta", 0)) &&
        jsopencv_to_safe(jsobj_max_theta, max_theta, ArgInfo("max_theta", 0)) &&
        jsopencv_to_safe(jsobj_theta_step, theta_step, ArgInfo("theta_step", 0)))
    {
        ERRWRAP2_NAPI(info, cv::HoughLinesPointSet(point, lines, lines_max, threshold, min_rho, max_rho, rho_step, min_theta, max_theta, theta_step));
        return jsopencv_from(info, lines);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "HoughLinesPointSet");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_HoughLinesWithAccumulator(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_image = NULL;
    Mat image;
    Napi::Value* jsobj_lines = NULL;
    Mat lines;
    Napi::Value* jsobj_rho = NULL;
    double rho=0;
    Napi::Value* jsobj_theta = NULL;
    double theta=0;
    Napi::Value* jsobj_threshold = NULL;
    int threshold=0;
    Napi::Value* jsobj_srn = NULL;
    double srn=0;
    Napi::Value* jsobj_stn = NULL;
    double stn=0;
    Napi::Value* jsobj_min_theta = NULL;
    double min_theta=0;
    Napi::Value* jsobj_max_theta = NULL;
    double max_theta=CV_PI;

    const char* keywords[] = { "image", "rho", "theta", "threshold", "lines", "srn", "stn", "min_theta", "max_theta", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOOOO:HoughLinesWithAccumulator", (char**)keywords, &jsobj_image, &jsobj_rho, &jsobj_theta, &jsobj_threshold, &jsobj_lines, &jsobj_srn, &jsobj_stn, &jsobj_min_theta, &jsobj_max_theta) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_lines, lines, ArgInfo("lines", 1)) &&
        jsopencv_to_safe(jsobj_rho, rho, ArgInfo("rho", 0)) &&
        jsopencv_to_safe(jsobj_theta, theta, ArgInfo("theta", 0)) &&
        jsopencv_to_safe(jsobj_threshold, threshold, ArgInfo("threshold", 0)) &&
        jsopencv_to_safe(jsobj_srn, srn, ArgInfo("srn", 0)) &&
        jsopencv_to_safe(jsobj_stn, stn, ArgInfo("stn", 0)) &&
        jsopencv_to_safe(jsobj_min_theta, min_theta, ArgInfo("min_theta", 0)) &&
        jsopencv_to_safe(jsobj_max_theta, max_theta, ArgInfo("max_theta", 0)))
    {
        ERRWRAP2_NAPI(info, cv::HoughLinesWithAccumulator(image, lines, rho, theta, threshold, srn, stn, min_theta, max_theta));
        return jsopencv_from(info, lines);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_image = NULL;
    UMat image;
    Napi::Value* jsobj_lines = NULL;
    UMat lines;
    Napi::Value* jsobj_rho = NULL;
    double rho=0;
    Napi::Value* jsobj_theta = NULL;
    double theta=0;
    Napi::Value* jsobj_threshold = NULL;
    int threshold=0;
    Napi::Value* jsobj_srn = NULL;
    double srn=0;
    Napi::Value* jsobj_stn = NULL;
    double stn=0;
    Napi::Value* jsobj_min_theta = NULL;
    double min_theta=0;
    Napi::Value* jsobj_max_theta = NULL;
    double max_theta=CV_PI;

    const char* keywords[] = { "image", "rho", "theta", "threshold", "lines", "srn", "stn", "min_theta", "max_theta", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOOOO:HoughLinesWithAccumulator", (char**)keywords, &jsobj_image, &jsobj_rho, &jsobj_theta, &jsobj_threshold, &jsobj_lines, &jsobj_srn, &jsobj_stn, &jsobj_min_theta, &jsobj_max_theta) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_lines, lines, ArgInfo("lines", 1)) &&
        jsopencv_to_safe(jsobj_rho, rho, ArgInfo("rho", 0)) &&
        jsopencv_to_safe(jsobj_theta, theta, ArgInfo("theta", 0)) &&
        jsopencv_to_safe(jsobj_threshold, threshold, ArgInfo("threshold", 0)) &&
        jsopencv_to_safe(jsobj_srn, srn, ArgInfo("srn", 0)) &&
        jsopencv_to_safe(jsobj_stn, stn, ArgInfo("stn", 0)) &&
        jsopencv_to_safe(jsobj_min_theta, min_theta, ArgInfo("min_theta", 0)) &&
        jsopencv_to_safe(jsobj_max_theta, max_theta, ArgInfo("max_theta", 0)))
    {
        ERRWRAP2_NAPI(info, cv::HoughLinesWithAccumulator(image, lines, rho, theta, threshold, srn, stn, min_theta, max_theta));
        return jsopencv_from(info, lines);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "HoughLinesWithAccumulator");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_HuMoments(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_m = NULL;
    Ptr<cv::Moments> m;
    Napi::Value* jsobj_hu = NULL;
    Mat hu;

    const char* keywords[] = { "m", "hu", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:HuMoments", (char**)keywords, &jsobj_m, &jsobj_hu) &&
        jsopencv_to_safe(jsobj_m, m, ArgInfo("m", 0)) &&
        jsopencv_to_safe(jsobj_hu, hu, ArgInfo("hu", 1)))
    {
        ERRWRAP2_NAPI(info, cv::HuMoments(*m, hu));
        return jsopencv_from(info, hu);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_m = NULL;
    Ptr<cv::Moments> m;
    Napi::Value* jsobj_hu = NULL;
    UMat hu;

    const char* keywords[] = { "m", "hu", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:HuMoments", (char**)keywords, &jsobj_m, &jsobj_hu) &&
        jsopencv_to_safe(jsobj_m, m, ArgInfo("m", 0)) &&
        jsopencv_to_safe(jsobj_hu, hu, ArgInfo("hu", 1)))
    {
        ERRWRAP2_NAPI(info, cv::HuMoments(*m, hu));
        return jsopencv_from(info, hu);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "HuMoments");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_KAZE_create(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_extended = NULL;
    bool extended=false;
    Napi::Value* jsobj_upright = NULL;
    bool upright=false;
    Napi::Value* jsobj_threshold = NULL;
    float threshold=0.001f;
    Napi::Value* jsobj_nOctaves = NULL;
    int nOctaves=4;
    Napi::Value* jsobj_nOctaveLayers = NULL;
    int nOctaveLayers=4;
    Napi::Value* jsobj_diffusivity = NULL;
    KAZE_DiffusivityType diffusivity=KAZE::DIFF_PM_G2;
    Ptr<KAZE> retval;

    const char* keywords[] = { "extended", "upright", "threshold", "nOctaves", "nOctaveLayers", "diffusivity", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OOOOOO:KAZE_create", (char**)keywords, &jsobj_extended, &jsobj_upright, &jsobj_threshold, &jsobj_nOctaves, &jsobj_nOctaveLayers, &jsobj_diffusivity) &&
        jsopencv_to_safe(jsobj_extended, extended, ArgInfo("extended", 0)) &&
        jsopencv_to_safe(jsobj_upright, upright, ArgInfo("upright", 0)) &&
        jsopencv_to_safe(jsobj_threshold, threshold, ArgInfo("threshold", 0)) &&
        jsopencv_to_safe(jsobj_nOctaves, nOctaves, ArgInfo("nOctaves", 0)) &&
        jsopencv_to_safe(jsobj_nOctaveLayers, nOctaveLayers, ArgInfo("nOctaveLayers", 0)) &&
        jsopencv_to_safe(jsobj_diffusivity, diffusivity, ArgInfo("diffusivity", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::KAZE::create(extended, upright, threshold, nOctaves, nOctaveLayers, diffusivity));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_KeyPoint_convert(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_keypoints = NULL;
    vector_KeyPoint keypoints;
    vector_Point2f points2f;
    Napi::Value* jsobj_keypointIndexes = NULL;
    vector_int keypointIndexes=std::vector<int>();

    const char* keywords[] = { "keypoints", "keypointIndexes", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:KeyPoint_convert", (char**)keywords, &jsobj_keypoints, &jsobj_keypointIndexes) &&
        jsopencv_to_safe(jsobj_keypoints, keypoints, ArgInfo("keypoints", 0)) &&
        jsopencv_to_safe(jsobj_keypointIndexes, keypointIndexes, ArgInfo("keypointIndexes", 0)))
    {
        ERRWRAP2_NAPI(info, cv::KeyPoint::convert(keypoints, points2f, keypointIndexes));
        return jsopencv_from(info, points2f);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_points2f = NULL;
    vector_Point2f points2f;
    vector_KeyPoint keypoints;
    Napi::Value* jsobj_size = NULL;
    float size=1;
    Napi::Value* jsobj_response = NULL;
    float response=1;
    Napi::Value* jsobj_octave = NULL;
    int octave=0;
    Napi::Value* jsobj_class_id = NULL;
    int class_id=-1;

    const char* keywords[] = { "points2f", "size", "response", "octave", "class_id", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOOO:KeyPoint_convert", (char**)keywords, &jsobj_points2f, &jsobj_size, &jsobj_response, &jsobj_octave, &jsobj_class_id) &&
        jsopencv_to_safe(jsobj_points2f, points2f, ArgInfo("points2f", 0)) &&
        jsopencv_to_safe(jsobj_size, size, ArgInfo("size", 0)) &&
        jsopencv_to_safe(jsobj_response, response, ArgInfo("response", 0)) &&
        jsopencv_to_safe(jsobj_octave, octave, ArgInfo("octave", 0)) &&
        jsopencv_to_safe(jsobj_class_id, class_id, ArgInfo("class_id", 0)))
    {
        ERRWRAP2_NAPI(info, cv::KeyPoint::convert(points2f, keypoints, size, response, octave, class_id));
        return jsopencv_from(info, keypoints);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "KeyPoint_convert");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_KeyPoint_overlap(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_kp1 = NULL;
    cv::KeyPoint kp1;
    Napi::Value* jsobj_kp2 = NULL;
    cv::KeyPoint kp2;
    float retval;

    const char* keywords[] = { "kp1", "kp2", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:KeyPoint_overlap", (char**)keywords, &jsobj_kp1, &jsobj_kp2) &&
        jsopencv_to_safe(jsobj_kp1, kp1, ArgInfo("kp1", 0)) &&
        jsopencv_to_safe(jsobj_kp2, kp2, ArgInfo("kp2", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::KeyPoint::overlap(kp1, kp2));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_LUT(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_lut = NULL;
    Mat lut;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;

    const char* keywords[] = { "src", "lut", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:LUT", (char**)keywords, &jsobj_src, &jsobj_lut, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_lut, lut, ArgInfo("lut", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)))
    {
        ERRWRAP2_NAPI(info, cv::LUT(src, lut, dst));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_lut = NULL;
    UMat lut;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;

    const char* keywords[] = { "src", "lut", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:LUT", (char**)keywords, &jsobj_src, &jsobj_lut, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_lut, lut, ArgInfo("lut", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)))
    {
        ERRWRAP2_NAPI(info, cv::LUT(src, lut, dst));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "LUT");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_Laplacian(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_ddepth = NULL;
    int ddepth=0;
    Napi::Value* jsobj_ksize = NULL;
    int ksize=1;
    Napi::Value* jsobj_scale = NULL;
    double scale=1;
    Napi::Value* jsobj_delta = NULL;
    double delta=0;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_DEFAULT;

    const char* keywords[] = { "src", "ddepth", "dst", "ksize", "scale", "delta", "borderType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOOOO:Laplacian", (char**)keywords, &jsobj_src, &jsobj_ddepth, &jsobj_dst, &jsobj_ksize, &jsobj_scale, &jsobj_delta, &jsobj_borderType) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_ddepth, ddepth, ArgInfo("ddepth", 0)) &&
        jsopencv_to_safe(jsobj_ksize, ksize, ArgInfo("ksize", 0)) &&
        jsopencv_to_safe(jsobj_scale, scale, ArgInfo("scale", 0)) &&
        jsopencv_to_safe(jsobj_delta, delta, ArgInfo("delta", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)))
    {
        ERRWRAP2_NAPI(info, cv::Laplacian(src, dst, ddepth, ksize, scale, delta, borderType));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_ddepth = NULL;
    int ddepth=0;
    Napi::Value* jsobj_ksize = NULL;
    int ksize=1;
    Napi::Value* jsobj_scale = NULL;
    double scale=1;
    Napi::Value* jsobj_delta = NULL;
    double delta=0;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_DEFAULT;

    const char* keywords[] = { "src", "ddepth", "dst", "ksize", "scale", "delta", "borderType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOOOO:Laplacian", (char**)keywords, &jsobj_src, &jsobj_ddepth, &jsobj_dst, &jsobj_ksize, &jsobj_scale, &jsobj_delta, &jsobj_borderType) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_ddepth, ddepth, ArgInfo("ddepth", 0)) &&
        jsopencv_to_safe(jsobj_ksize, ksize, ArgInfo("ksize", 0)) &&
        jsopencv_to_safe(jsobj_scale, scale, ArgInfo("scale", 0)) &&
        jsopencv_to_safe(jsobj_delta, delta, ArgInfo("delta", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)))
    {
        ERRWRAP2_NAPI(info, cv::Laplacian(src, dst, ddepth, ksize, scale, delta, borderType));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "Laplacian");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_MSER_create(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_delta = NULL;
    int delta=5;
    Napi::Value* jsobj_min_area = NULL;
    int min_area=60;
    Napi::Value* jsobj_max_area = NULL;
    int max_area=14400;
    Napi::Value* jsobj_max_variation = NULL;
    double max_variation=0.25;
    Napi::Value* jsobj_min_diversity = NULL;
    double min_diversity=.2;
    Napi::Value* jsobj_max_evolution = NULL;
    int max_evolution=200;
    Napi::Value* jsobj_area_threshold = NULL;
    double area_threshold=1.01;
    Napi::Value* jsobj_min_margin = NULL;
    double min_margin=0.003;
    Napi::Value* jsobj_edge_blur_size = NULL;
    int edge_blur_size=5;
    Ptr<MSER> retval;

    const char* keywords[] = { "delta", "min_area", "max_area", "max_variation", "min_diversity", "max_evolution", "area_threshold", "min_margin", "edge_blur_size", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OOOOOOOOO:MSER_create", (char**)keywords, &jsobj_delta, &jsobj_min_area, &jsobj_max_area, &jsobj_max_variation, &jsobj_min_diversity, &jsobj_max_evolution, &jsobj_area_threshold, &jsobj_min_margin, &jsobj_edge_blur_size) &&
        jsopencv_to_safe(jsobj_delta, delta, ArgInfo("delta", 0)) &&
        jsopencv_to_safe(jsobj_min_area, min_area, ArgInfo("min_area", 0)) &&
        jsopencv_to_safe(jsobj_max_area, max_area, ArgInfo("max_area", 0)) &&
        jsopencv_to_safe(jsobj_max_variation, max_variation, ArgInfo("max_variation", 0)) &&
        jsopencv_to_safe(jsobj_min_diversity, min_diversity, ArgInfo("min_diversity", 0)) &&
        jsopencv_to_safe(jsobj_max_evolution, max_evolution, ArgInfo("max_evolution", 0)) &&
        jsopencv_to_safe(jsobj_area_threshold, area_threshold, ArgInfo("area_threshold", 0)) &&
        jsopencv_to_safe(jsobj_min_margin, min_margin, ArgInfo("min_margin", 0)) &&
        jsopencv_to_safe(jsobj_edge_blur_size, edge_blur_size, ArgInfo("edge_blur_size", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::MSER::create(delta, min_area, max_area, max_variation, min_diversity, max_evolution, area_threshold, min_margin, edge_blur_size));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_Mahalanobis(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_v1 = NULL;
    Mat v1;
    Napi::Value* jsobj_v2 = NULL;
    Mat v2;
    Napi::Value* jsobj_icovar = NULL;
    Mat icovar;
    double retval;

    const char* keywords[] = { "v1", "v2", "icovar", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:Mahalanobis", (char**)keywords, &jsobj_v1, &jsobj_v2, &jsobj_icovar) &&
        jsopencv_to_safe(jsobj_v1, v1, ArgInfo("v1", 0)) &&
        jsopencv_to_safe(jsobj_v2, v2, ArgInfo("v2", 0)) &&
        jsopencv_to_safe(jsobj_icovar, icovar, ArgInfo("icovar", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::Mahalanobis(v1, v2, icovar));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_v1 = NULL;
    UMat v1;
    Napi::Value* jsobj_v2 = NULL;
    UMat v2;
    Napi::Value* jsobj_icovar = NULL;
    UMat icovar;
    double retval;

    const char* keywords[] = { "v1", "v2", "icovar", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:Mahalanobis", (char**)keywords, &jsobj_v1, &jsobj_v2, &jsobj_icovar) &&
        jsopencv_to_safe(jsobj_v1, v1, ArgInfo("v1", 0)) &&
        jsopencv_to_safe(jsobj_v2, v2, ArgInfo("v2", 0)) &&
        jsopencv_to_safe(jsobj_icovar, icovar, ArgInfo("icovar", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::Mahalanobis(v1, v2, icovar));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "Mahalanobis");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ORB_create(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_nfeatures = NULL;
    int nfeatures=500;
    Napi::Value* jsobj_scaleFactor = NULL;
    float scaleFactor=1.2f;
    Napi::Value* jsobj_nlevels = NULL;
    int nlevels=8;
    Napi::Value* jsobj_edgeThreshold = NULL;
    int edgeThreshold=31;
    Napi::Value* jsobj_firstLevel = NULL;
    int firstLevel=0;
    Napi::Value* jsobj_WTA_K = NULL;
    int WTA_K=2;
    Napi::Value* jsobj_scoreType = NULL;
    ORB_ScoreType scoreType=ORB::HARRIS_SCORE;
    Napi::Value* jsobj_patchSize = NULL;
    int patchSize=31;
    Napi::Value* jsobj_fastThreshold = NULL;
    int fastThreshold=20;
    Ptr<ORB> retval;

    const char* keywords[] = { "nfeatures", "scaleFactor", "nlevels", "edgeThreshold", "firstLevel", "WTA_K", "scoreType", "patchSize", "fastThreshold", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OOOOOOOOO:ORB_create", (char**)keywords, &jsobj_nfeatures, &jsobj_scaleFactor, &jsobj_nlevels, &jsobj_edgeThreshold, &jsobj_firstLevel, &jsobj_WTA_K, &jsobj_scoreType, &jsobj_patchSize, &jsobj_fastThreshold) &&
        jsopencv_to_safe(jsobj_nfeatures, nfeatures, ArgInfo("nfeatures", 0)) &&
        jsopencv_to_safe(jsobj_scaleFactor, scaleFactor, ArgInfo("scaleFactor", 0)) &&
        jsopencv_to_safe(jsobj_nlevels, nlevels, ArgInfo("nlevels", 0)) &&
        jsopencv_to_safe(jsobj_edgeThreshold, edgeThreshold, ArgInfo("edgeThreshold", 0)) &&
        jsopencv_to_safe(jsobj_firstLevel, firstLevel, ArgInfo("firstLevel", 0)) &&
        jsopencv_to_safe(jsobj_WTA_K, WTA_K, ArgInfo("WTA_K", 0)) &&
        jsopencv_to_safe(jsobj_scoreType, scoreType, ArgInfo("scoreType", 0)) &&
        jsopencv_to_safe(jsobj_patchSize, patchSize, ArgInfo("patchSize", 0)) &&
        jsopencv_to_safe(jsobj_fastThreshold, fastThreshold, ArgInfo("fastThreshold", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ORB::create(nfeatures, scaleFactor, nlevels, edgeThreshold, firstLevel, WTA_K, scoreType, patchSize, fastThreshold));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_PCABackProject(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_data = NULL;
    Mat data;
    Napi::Value* jsobj_mean = NULL;
    Mat mean;
    Napi::Value* jsobj_eigenvectors = NULL;
    Mat eigenvectors;
    Napi::Value* jsobj_result = NULL;
    Mat result;

    const char* keywords[] = { "data", "mean", "eigenvectors", "result", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:PCABackProject", (char**)keywords, &jsobj_data, &jsobj_mean, &jsobj_eigenvectors, &jsobj_result) &&
        jsopencv_to_safe(jsobj_data, data, ArgInfo("data", 0)) &&
        jsopencv_to_safe(jsobj_mean, mean, ArgInfo("mean", 0)) &&
        jsopencv_to_safe(jsobj_eigenvectors, eigenvectors, ArgInfo("eigenvectors", 0)) &&
        jsopencv_to_safe(jsobj_result, result, ArgInfo("result", 1)))
    {
        ERRWRAP2_NAPI(info, cv::PCABackProject(data, mean, eigenvectors, result));
        return jsopencv_from(info, result);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_data = NULL;
    UMat data;
    Napi::Value* jsobj_mean = NULL;
    UMat mean;
    Napi::Value* jsobj_eigenvectors = NULL;
    UMat eigenvectors;
    Napi::Value* jsobj_result = NULL;
    UMat result;

    const char* keywords[] = { "data", "mean", "eigenvectors", "result", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:PCABackProject", (char**)keywords, &jsobj_data, &jsobj_mean, &jsobj_eigenvectors, &jsobj_result) &&
        jsopencv_to_safe(jsobj_data, data, ArgInfo("data", 0)) &&
        jsopencv_to_safe(jsobj_mean, mean, ArgInfo("mean", 0)) &&
        jsopencv_to_safe(jsobj_eigenvectors, eigenvectors, ArgInfo("eigenvectors", 0)) &&
        jsopencv_to_safe(jsobj_result, result, ArgInfo("result", 1)))
    {
        ERRWRAP2_NAPI(info, cv::PCABackProject(data, mean, eigenvectors, result));
        return jsopencv_from(info, result);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "PCABackProject");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_PCACompute(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(4);

    {
    Napi::Value* jsobj_data = NULL;
    Mat data;
    Napi::Value* jsobj_mean = NULL;
    Mat mean;
    Napi::Value* jsobj_eigenvectors = NULL;
    Mat eigenvectors;
    Napi::Value* jsobj_maxComponents = NULL;
    int maxComponents=0;

    const char* keywords[] = { "data", "mean", "eigenvectors", "maxComponents", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:PCACompute", (char**)keywords, &jsobj_data, &jsobj_mean, &jsobj_eigenvectors, &jsobj_maxComponents) &&
        jsopencv_to_safe(jsobj_data, data, ArgInfo("data", 0)) &&
        jsopencv_to_safe(jsobj_mean, mean, ArgInfo("mean", 1)) &&
        jsopencv_to_safe(jsobj_eigenvectors, eigenvectors, ArgInfo("eigenvectors", 1)) &&
        jsopencv_to_safe(jsobj_maxComponents, maxComponents, ArgInfo("maxComponents", 0)))
    {
        ERRWRAP2_NAPI(info, cv::PCACompute(data, mean, eigenvectors, maxComponents));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, mean), jsopencv_from(info, eigenvectors));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_data = NULL;
    UMat data;
    Napi::Value* jsobj_mean = NULL;
    UMat mean;
    Napi::Value* jsobj_eigenvectors = NULL;
    UMat eigenvectors;
    Napi::Value* jsobj_maxComponents = NULL;
    int maxComponents=0;

    const char* keywords[] = { "data", "mean", "eigenvectors", "maxComponents", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:PCACompute", (char**)keywords, &jsobj_data, &jsobj_mean, &jsobj_eigenvectors, &jsobj_maxComponents) &&
        jsopencv_to_safe(jsobj_data, data, ArgInfo("data", 0)) &&
        jsopencv_to_safe(jsobj_mean, mean, ArgInfo("mean", 1)) &&
        jsopencv_to_safe(jsobj_eigenvectors, eigenvectors, ArgInfo("eigenvectors", 1)) &&
        jsopencv_to_safe(jsobj_maxComponents, maxComponents, ArgInfo("maxComponents", 0)))
    {
        ERRWRAP2_NAPI(info, cv::PCACompute(data, mean, eigenvectors, maxComponents));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, mean), jsopencv_from(info, eigenvectors));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_data = NULL;
    Mat data;
    Napi::Value* jsobj_mean = NULL;
    Mat mean;
    Napi::Value* jsobj_eigenvectors = NULL;
    Mat eigenvectors;
    Napi::Value* jsobj_retainedVariance = NULL;
    double retainedVariance=0;

    const char* keywords[] = { "data", "mean", "retainedVariance", "eigenvectors", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:PCACompute", (char**)keywords, &jsobj_data, &jsobj_mean, &jsobj_retainedVariance, &jsobj_eigenvectors) &&
        jsopencv_to_safe(jsobj_data, data, ArgInfo("data", 0)) &&
        jsopencv_to_safe(jsobj_mean, mean, ArgInfo("mean", 1)) &&
        jsopencv_to_safe(jsobj_eigenvectors, eigenvectors, ArgInfo("eigenvectors", 1)) &&
        jsopencv_to_safe(jsobj_retainedVariance, retainedVariance, ArgInfo("retainedVariance", 0)))
    {
        ERRWRAP2_NAPI(info, cv::PCACompute(data, mean, eigenvectors, retainedVariance));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, mean), jsopencv_from(info, eigenvectors));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_data = NULL;
    UMat data;
    Napi::Value* jsobj_mean = NULL;
    UMat mean;
    Napi::Value* jsobj_eigenvectors = NULL;
    UMat eigenvectors;
    Napi::Value* jsobj_retainedVariance = NULL;
    double retainedVariance=0;

    const char* keywords[] = { "data", "mean", "retainedVariance", "eigenvectors", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:PCACompute", (char**)keywords, &jsobj_data, &jsobj_mean, &jsobj_retainedVariance, &jsobj_eigenvectors) &&
        jsopencv_to_safe(jsobj_data, data, ArgInfo("data", 0)) &&
        jsopencv_to_safe(jsobj_mean, mean, ArgInfo("mean", 1)) &&
        jsopencv_to_safe(jsobj_eigenvectors, eigenvectors, ArgInfo("eigenvectors", 1)) &&
        jsopencv_to_safe(jsobj_retainedVariance, retainedVariance, ArgInfo("retainedVariance", 0)))
    {
        ERRWRAP2_NAPI(info, cv::PCACompute(data, mean, eigenvectors, retainedVariance));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, mean), jsopencv_from(info, eigenvectors));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "PCACompute");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_PCACompute2(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(4);

    {
    Napi::Value* jsobj_data = NULL;
    Mat data;
    Napi::Value* jsobj_mean = NULL;
    Mat mean;
    Napi::Value* jsobj_eigenvectors = NULL;
    Mat eigenvectors;
    Napi::Value* jsobj_eigenvalues = NULL;
    Mat eigenvalues;
    Napi::Value* jsobj_maxComponents = NULL;
    int maxComponents=0;

    const char* keywords[] = { "data", "mean", "eigenvectors", "eigenvalues", "maxComponents", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOO:PCACompute2", (char**)keywords, &jsobj_data, &jsobj_mean, &jsobj_eigenvectors, &jsobj_eigenvalues, &jsobj_maxComponents) &&
        jsopencv_to_safe(jsobj_data, data, ArgInfo("data", 0)) &&
        jsopencv_to_safe(jsobj_mean, mean, ArgInfo("mean", 1)) &&
        jsopencv_to_safe(jsobj_eigenvectors, eigenvectors, ArgInfo("eigenvectors", 1)) &&
        jsopencv_to_safe(jsobj_eigenvalues, eigenvalues, ArgInfo("eigenvalues", 1)) &&
        jsopencv_to_safe(jsobj_maxComponents, maxComponents, ArgInfo("maxComponents", 0)))
    {
        ERRWRAP2_NAPI(info, cv::PCACompute(data, mean, eigenvectors, eigenvalues, maxComponents));
        return Js_BuildValue(info, "(NNN)", jsopencv_from(info, mean), jsopencv_from(info, eigenvectors), jsopencv_from(info, eigenvalues));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_data = NULL;
    UMat data;
    Napi::Value* jsobj_mean = NULL;
    UMat mean;
    Napi::Value* jsobj_eigenvectors = NULL;
    UMat eigenvectors;
    Napi::Value* jsobj_eigenvalues = NULL;
    UMat eigenvalues;
    Napi::Value* jsobj_maxComponents = NULL;
    int maxComponents=0;

    const char* keywords[] = { "data", "mean", "eigenvectors", "eigenvalues", "maxComponents", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOO:PCACompute2", (char**)keywords, &jsobj_data, &jsobj_mean, &jsobj_eigenvectors, &jsobj_eigenvalues, &jsobj_maxComponents) &&
        jsopencv_to_safe(jsobj_data, data, ArgInfo("data", 0)) &&
        jsopencv_to_safe(jsobj_mean, mean, ArgInfo("mean", 1)) &&
        jsopencv_to_safe(jsobj_eigenvectors, eigenvectors, ArgInfo("eigenvectors", 1)) &&
        jsopencv_to_safe(jsobj_eigenvalues, eigenvalues, ArgInfo("eigenvalues", 1)) &&
        jsopencv_to_safe(jsobj_maxComponents, maxComponents, ArgInfo("maxComponents", 0)))
    {
        ERRWRAP2_NAPI(info, cv::PCACompute(data, mean, eigenvectors, eigenvalues, maxComponents));
        return Js_BuildValue(info, "(NNN)", jsopencv_from(info, mean), jsopencv_from(info, eigenvectors), jsopencv_from(info, eigenvalues));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_data = NULL;
    Mat data;
    Napi::Value* jsobj_mean = NULL;
    Mat mean;
    Napi::Value* jsobj_eigenvectors = NULL;
    Mat eigenvectors;
    Napi::Value* jsobj_eigenvalues = NULL;
    Mat eigenvalues;
    Napi::Value* jsobj_retainedVariance = NULL;
    double retainedVariance=0;

    const char* keywords[] = { "data", "mean", "retainedVariance", "eigenvectors", "eigenvalues", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OO:PCACompute2", (char**)keywords, &jsobj_data, &jsobj_mean, &jsobj_retainedVariance, &jsobj_eigenvectors, &jsobj_eigenvalues) &&
        jsopencv_to_safe(jsobj_data, data, ArgInfo("data", 0)) &&
        jsopencv_to_safe(jsobj_mean, mean, ArgInfo("mean", 1)) &&
        jsopencv_to_safe(jsobj_eigenvectors, eigenvectors, ArgInfo("eigenvectors", 1)) &&
        jsopencv_to_safe(jsobj_eigenvalues, eigenvalues, ArgInfo("eigenvalues", 1)) &&
        jsopencv_to_safe(jsobj_retainedVariance, retainedVariance, ArgInfo("retainedVariance", 0)))
    {
        ERRWRAP2_NAPI(info, cv::PCACompute(data, mean, eigenvectors, eigenvalues, retainedVariance));
        return Js_BuildValue(info, "(NNN)", jsopencv_from(info, mean), jsopencv_from(info, eigenvectors), jsopencv_from(info, eigenvalues));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_data = NULL;
    UMat data;
    Napi::Value* jsobj_mean = NULL;
    UMat mean;
    Napi::Value* jsobj_eigenvectors = NULL;
    UMat eigenvectors;
    Napi::Value* jsobj_eigenvalues = NULL;
    UMat eigenvalues;
    Napi::Value* jsobj_retainedVariance = NULL;
    double retainedVariance=0;

    const char* keywords[] = { "data", "mean", "retainedVariance", "eigenvectors", "eigenvalues", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OO:PCACompute2", (char**)keywords, &jsobj_data, &jsobj_mean, &jsobj_retainedVariance, &jsobj_eigenvectors, &jsobj_eigenvalues) &&
        jsopencv_to_safe(jsobj_data, data, ArgInfo("data", 0)) &&
        jsopencv_to_safe(jsobj_mean, mean, ArgInfo("mean", 1)) &&
        jsopencv_to_safe(jsobj_eigenvectors, eigenvectors, ArgInfo("eigenvectors", 1)) &&
        jsopencv_to_safe(jsobj_eigenvalues, eigenvalues, ArgInfo("eigenvalues", 1)) &&
        jsopencv_to_safe(jsobj_retainedVariance, retainedVariance, ArgInfo("retainedVariance", 0)))
    {
        ERRWRAP2_NAPI(info, cv::PCACompute(data, mean, eigenvectors, eigenvalues, retainedVariance));
        return Js_BuildValue(info, "(NNN)", jsopencv_from(info, mean), jsopencv_from(info, eigenvectors), jsopencv_from(info, eigenvalues));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "PCACompute2");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_PCAProject(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_data = NULL;
    Mat data;
    Napi::Value* jsobj_mean = NULL;
    Mat mean;
    Napi::Value* jsobj_eigenvectors = NULL;
    Mat eigenvectors;
    Napi::Value* jsobj_result = NULL;
    Mat result;

    const char* keywords[] = { "data", "mean", "eigenvectors", "result", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:PCAProject", (char**)keywords, &jsobj_data, &jsobj_mean, &jsobj_eigenvectors, &jsobj_result) &&
        jsopencv_to_safe(jsobj_data, data, ArgInfo("data", 0)) &&
        jsopencv_to_safe(jsobj_mean, mean, ArgInfo("mean", 0)) &&
        jsopencv_to_safe(jsobj_eigenvectors, eigenvectors, ArgInfo("eigenvectors", 0)) &&
        jsopencv_to_safe(jsobj_result, result, ArgInfo("result", 1)))
    {
        ERRWRAP2_NAPI(info, cv::PCAProject(data, mean, eigenvectors, result));
        return jsopencv_from(info, result);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_data = NULL;
    UMat data;
    Napi::Value* jsobj_mean = NULL;
    UMat mean;
    Napi::Value* jsobj_eigenvectors = NULL;
    UMat eigenvectors;
    Napi::Value* jsobj_result = NULL;
    UMat result;

    const char* keywords[] = { "data", "mean", "eigenvectors", "result", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:PCAProject", (char**)keywords, &jsobj_data, &jsobj_mean, &jsobj_eigenvectors, &jsobj_result) &&
        jsopencv_to_safe(jsobj_data, data, ArgInfo("data", 0)) &&
        jsopencv_to_safe(jsobj_mean, mean, ArgInfo("mean", 0)) &&
        jsopencv_to_safe(jsobj_eigenvectors, eigenvectors, ArgInfo("eigenvectors", 0)) &&
        jsopencv_to_safe(jsobj_result, result, ArgInfo("result", 1)))
    {
        ERRWRAP2_NAPI(info, cv::PCAProject(data, mean, eigenvectors, result));
        return jsopencv_from(info, result);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "PCAProject");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_PSNR(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src1 = NULL;
    Mat src1;
    Napi::Value* jsobj_src2 = NULL;
    Mat src2;
    Napi::Value* jsobj_R = NULL;
    double R=255.;
    double retval;

    const char* keywords[] = { "src1", "src2", "R", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:PSNR", (char**)keywords, &jsobj_src1, &jsobj_src2, &jsobj_R) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_R, R, ArgInfo("R", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::PSNR(src1, src2, R));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src1 = NULL;
    UMat src1;
    Napi::Value* jsobj_src2 = NULL;
    UMat src2;
    Napi::Value* jsobj_R = NULL;
    double R=255.;
    double retval;

    const char* keywords[] = { "src1", "src2", "R", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:PSNR", (char**)keywords, &jsobj_src1, &jsobj_src2, &jsobj_R) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_R, R, ArgInfo("R", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::PSNR(src1, src2, R));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "PSNR");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_QRCodeEncoder_create(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_parameters = NULL;
    cv::QRCodeEncoder::Params parameters=QRCodeEncoder::Params();
    Ptr<QRCodeEncoder> retval;

    const char* keywords[] = { "parameters", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|O:QRCodeEncoder_create", (char**)keywords, &jsobj_parameters) &&
        jsopencv_to_safe(jsobj_parameters, parameters, ArgInfo("parameters", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::QRCodeEncoder::create(parameters));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_RQDecomp3x3(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_mtxR = NULL;
    Mat mtxR;
    Napi::Value* jsobj_mtxQ = NULL;
    Mat mtxQ;
    Napi::Value* jsobj_Qx = NULL;
    Mat Qx;
    Napi::Value* jsobj_Qy = NULL;
    Mat Qy;
    Napi::Value* jsobj_Qz = NULL;
    Mat Qz;
    Vec3d retval;

    const char* keywords[] = { "src", "mtxR", "mtxQ", "Qx", "Qy", "Qz", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOOOO:RQDecomp3x3", (char**)keywords, &jsobj_src, &jsobj_mtxR, &jsobj_mtxQ, &jsobj_Qx, &jsobj_Qy, &jsobj_Qz) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_mtxR, mtxR, ArgInfo("mtxR", 1)) &&
        jsopencv_to_safe(jsobj_mtxQ, mtxQ, ArgInfo("mtxQ", 1)) &&
        jsopencv_to_safe(jsobj_Qx, Qx, ArgInfo("Qx", 1)) &&
        jsopencv_to_safe(jsobj_Qy, Qy, ArgInfo("Qy", 1)) &&
        jsopencv_to_safe(jsobj_Qz, Qz, ArgInfo("Qz", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::RQDecomp3x3(src, mtxR, mtxQ, Qx, Qy, Qz));
        return Js_BuildValue(info, "(NNNNNN)", jsopencv_from(info, retval), jsopencv_from(info, mtxR), jsopencv_from(info, mtxQ), jsopencv_from(info, Qx), jsopencv_from(info, Qy), jsopencv_from(info, Qz));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_mtxR = NULL;
    UMat mtxR;
    Napi::Value* jsobj_mtxQ = NULL;
    UMat mtxQ;
    Napi::Value* jsobj_Qx = NULL;
    UMat Qx;
    Napi::Value* jsobj_Qy = NULL;
    UMat Qy;
    Napi::Value* jsobj_Qz = NULL;
    UMat Qz;
    Vec3d retval;

    const char* keywords[] = { "src", "mtxR", "mtxQ", "Qx", "Qy", "Qz", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOOOO:RQDecomp3x3", (char**)keywords, &jsobj_src, &jsobj_mtxR, &jsobj_mtxQ, &jsobj_Qx, &jsobj_Qy, &jsobj_Qz) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_mtxR, mtxR, ArgInfo("mtxR", 1)) &&
        jsopencv_to_safe(jsobj_mtxQ, mtxQ, ArgInfo("mtxQ", 1)) &&
        jsopencv_to_safe(jsobj_Qx, Qx, ArgInfo("Qx", 1)) &&
        jsopencv_to_safe(jsobj_Qy, Qy, ArgInfo("Qy", 1)) &&
        jsopencv_to_safe(jsobj_Qz, Qz, ArgInfo("Qz", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::RQDecomp3x3(src, mtxR, mtxQ, Qx, Qy, Qz));
        return Js_BuildValue(info, "(NNNNNN)", jsopencv_from(info, retval), jsopencv_from(info, mtxR), jsopencv_from(info, mtxQ), jsopencv_from(info, Qx), jsopencv_from(info, Qy), jsopencv_from(info, Qz));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "RQDecomp3x3");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_Rodrigues(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_jacobian = NULL;
    Mat jacobian;

    const char* keywords[] = { "src", "dst", "jacobian", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OO:Rodrigues", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_jacobian) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_jacobian, jacobian, ArgInfo("jacobian", 1)))
    {
        ERRWRAP2_NAPI(info, cv::Rodrigues(src, dst, jacobian));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, dst), jsopencv_from(info, jacobian));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_jacobian = NULL;
    UMat jacobian;

    const char* keywords[] = { "src", "dst", "jacobian", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OO:Rodrigues", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_jacobian) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_jacobian, jacobian, ArgInfo("jacobian", 1)))
    {
        ERRWRAP2_NAPI(info, cv::Rodrigues(src, dst, jacobian));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, dst), jsopencv_from(info, jacobian));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "Rodrigues");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_SIFT_create(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_nfeatures = NULL;
    int nfeatures=0;
    Napi::Value* jsobj_nOctaveLayers = NULL;
    int nOctaveLayers=3;
    Napi::Value* jsobj_contrastThreshold = NULL;
    double contrastThreshold=0.04;
    Napi::Value* jsobj_edgeThreshold = NULL;
    double edgeThreshold=10;
    Napi::Value* jsobj_sigma = NULL;
    double sigma=1.6;
    Ptr<SIFT> retval;

    const char* keywords[] = { "nfeatures", "nOctaveLayers", "contrastThreshold", "edgeThreshold", "sigma", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OOOOO:SIFT_create", (char**)keywords, &jsobj_nfeatures, &jsobj_nOctaveLayers, &jsobj_contrastThreshold, &jsobj_edgeThreshold, &jsobj_sigma) &&
        jsopencv_to_safe(jsobj_nfeatures, nfeatures, ArgInfo("nfeatures", 0)) &&
        jsopencv_to_safe(jsobj_nOctaveLayers, nOctaveLayers, ArgInfo("nOctaveLayers", 0)) &&
        jsopencv_to_safe(jsobj_contrastThreshold, contrastThreshold, ArgInfo("contrastThreshold", 0)) &&
        jsopencv_to_safe(jsobj_edgeThreshold, edgeThreshold, ArgInfo("edgeThreshold", 0)) &&
        jsopencv_to_safe(jsobj_sigma, sigma, ArgInfo("sigma", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::SIFT::create(nfeatures, nOctaveLayers, contrastThreshold, edgeThreshold, sigma));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_nfeatures = NULL;
    int nfeatures=0;
    Napi::Value* jsobj_nOctaveLayers = NULL;
    int nOctaveLayers=0;
    Napi::Value* jsobj_contrastThreshold = NULL;
    double contrastThreshold=0;
    Napi::Value* jsobj_edgeThreshold = NULL;
    double edgeThreshold=0;
    Napi::Value* jsobj_sigma = NULL;
    double sigma=0;
    Napi::Value* jsobj_descriptorType = NULL;
    int descriptorType=0;
    Ptr<SIFT> retval;

    const char* keywords[] = { "nfeatures", "nOctaveLayers", "contrastThreshold", "edgeThreshold", "sigma", "descriptorType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOO:SIFT_create", (char**)keywords, &jsobj_nfeatures, &jsobj_nOctaveLayers, &jsobj_contrastThreshold, &jsobj_edgeThreshold, &jsobj_sigma, &jsobj_descriptorType) &&
        jsopencv_to_safe(jsobj_nfeatures, nfeatures, ArgInfo("nfeatures", 0)) &&
        jsopencv_to_safe(jsobj_nOctaveLayers, nOctaveLayers, ArgInfo("nOctaveLayers", 0)) &&
        jsopencv_to_safe(jsobj_contrastThreshold, contrastThreshold, ArgInfo("contrastThreshold", 0)) &&
        jsopencv_to_safe(jsobj_edgeThreshold, edgeThreshold, ArgInfo("edgeThreshold", 0)) &&
        jsopencv_to_safe(jsobj_sigma, sigma, ArgInfo("sigma", 0)) &&
        jsopencv_to_safe(jsobj_descriptorType, descriptorType, ArgInfo("descriptorType", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::SIFT::create(nfeatures, nOctaveLayers, contrastThreshold, edgeThreshold, sigma, descriptorType));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "SIFT_create");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_SVBackSubst(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_w = NULL;
    Mat w;
    Napi::Value* jsobj_u = NULL;
    Mat u;
    Napi::Value* jsobj_vt = NULL;
    Mat vt;
    Napi::Value* jsobj_rhs = NULL;
    Mat rhs;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;

    const char* keywords[] = { "w", "u", "vt", "rhs", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|O:SVBackSubst", (char**)keywords, &jsobj_w, &jsobj_u, &jsobj_vt, &jsobj_rhs, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_w, w, ArgInfo("w", 0)) &&
        jsopencv_to_safe(jsobj_u, u, ArgInfo("u", 0)) &&
        jsopencv_to_safe(jsobj_vt, vt, ArgInfo("vt", 0)) &&
        jsopencv_to_safe(jsobj_rhs, rhs, ArgInfo("rhs", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)))
    {
        ERRWRAP2_NAPI(info, cv::SVBackSubst(w, u, vt, rhs, dst));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_w = NULL;
    UMat w;
    Napi::Value* jsobj_u = NULL;
    UMat u;
    Napi::Value* jsobj_vt = NULL;
    UMat vt;
    Napi::Value* jsobj_rhs = NULL;
    UMat rhs;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;

    const char* keywords[] = { "w", "u", "vt", "rhs", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|O:SVBackSubst", (char**)keywords, &jsobj_w, &jsobj_u, &jsobj_vt, &jsobj_rhs, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_w, w, ArgInfo("w", 0)) &&
        jsopencv_to_safe(jsobj_u, u, ArgInfo("u", 0)) &&
        jsopencv_to_safe(jsobj_vt, vt, ArgInfo("vt", 0)) &&
        jsopencv_to_safe(jsobj_rhs, rhs, ArgInfo("rhs", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)))
    {
        ERRWRAP2_NAPI(info, cv::SVBackSubst(w, u, vt, rhs, dst));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "SVBackSubst");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_SVDecomp(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_w = NULL;
    Mat w;
    Napi::Value* jsobj_u = NULL;
    Mat u;
    Napi::Value* jsobj_vt = NULL;
    Mat vt;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;

    const char* keywords[] = { "src", "w", "u", "vt", "flags", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOOO:SVDecomp", (char**)keywords, &jsobj_src, &jsobj_w, &jsobj_u, &jsobj_vt, &jsobj_flags) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_w, w, ArgInfo("w", 1)) &&
        jsopencv_to_safe(jsobj_u, u, ArgInfo("u", 1)) &&
        jsopencv_to_safe(jsobj_vt, vt, ArgInfo("vt", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, cv::SVDecomp(src, w, u, vt, flags));
        return Js_BuildValue(info, "(NNN)", jsopencv_from(info, w), jsopencv_from(info, u), jsopencv_from(info, vt));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_w = NULL;
    UMat w;
    Napi::Value* jsobj_u = NULL;
    UMat u;
    Napi::Value* jsobj_vt = NULL;
    UMat vt;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;

    const char* keywords[] = { "src", "w", "u", "vt", "flags", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOOO:SVDecomp", (char**)keywords, &jsobj_src, &jsobj_w, &jsobj_u, &jsobj_vt, &jsobj_flags) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_w, w, ArgInfo("w", 1)) &&
        jsopencv_to_safe(jsobj_u, u, ArgInfo("u", 1)) &&
        jsopencv_to_safe(jsobj_vt, vt, ArgInfo("vt", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, cv::SVDecomp(src, w, u, vt, flags));
        return Js_BuildValue(info, "(NNN)", jsopencv_from(info, w), jsopencv_from(info, u), jsopencv_from(info, vt));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "SVDecomp");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_Scharr(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_ddepth = NULL;
    int ddepth=0;
    Napi::Value* jsobj_dx = NULL;
    int dx=0;
    Napi::Value* jsobj_dy = NULL;
    int dy=0;
    Napi::Value* jsobj_scale = NULL;
    double scale=1;
    Napi::Value* jsobj_delta = NULL;
    double delta=0;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_DEFAULT;

    const char* keywords[] = { "src", "ddepth", "dx", "dy", "dst", "scale", "delta", "borderType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOOO:Scharr", (char**)keywords, &jsobj_src, &jsobj_ddepth, &jsobj_dx, &jsobj_dy, &jsobj_dst, &jsobj_scale, &jsobj_delta, &jsobj_borderType) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_ddepth, ddepth, ArgInfo("ddepth", 0)) &&
        jsopencv_to_safe(jsobj_dx, dx, ArgInfo("dx", 0)) &&
        jsopencv_to_safe(jsobj_dy, dy, ArgInfo("dy", 0)) &&
        jsopencv_to_safe(jsobj_scale, scale, ArgInfo("scale", 0)) &&
        jsopencv_to_safe(jsobj_delta, delta, ArgInfo("delta", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)))
    {
        ERRWRAP2_NAPI(info, cv::Scharr(src, dst, ddepth, dx, dy, scale, delta, borderType));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_ddepth = NULL;
    int ddepth=0;
    Napi::Value* jsobj_dx = NULL;
    int dx=0;
    Napi::Value* jsobj_dy = NULL;
    int dy=0;
    Napi::Value* jsobj_scale = NULL;
    double scale=1;
    Napi::Value* jsobj_delta = NULL;
    double delta=0;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_DEFAULT;

    const char* keywords[] = { "src", "ddepth", "dx", "dy", "dst", "scale", "delta", "borderType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOOO:Scharr", (char**)keywords, &jsobj_src, &jsobj_ddepth, &jsobj_dx, &jsobj_dy, &jsobj_dst, &jsobj_scale, &jsobj_delta, &jsobj_borderType) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_ddepth, ddepth, ArgInfo("ddepth", 0)) &&
        jsopencv_to_safe(jsobj_dx, dx, ArgInfo("dx", 0)) &&
        jsopencv_to_safe(jsobj_dy, dy, ArgInfo("dy", 0)) &&
        jsopencv_to_safe(jsobj_scale, scale, ArgInfo("scale", 0)) &&
        jsopencv_to_safe(jsobj_delta, delta, ArgInfo("delta", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)))
    {
        ERRWRAP2_NAPI(info, cv::Scharr(src, dst, ddepth, dx, dy, scale, delta, borderType));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "Scharr");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_SimpleBlobDetector_create(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_parameters = NULL;
    cv::SimpleBlobDetector::Params parameters=SimpleBlobDetector::Params();
    Ptr<SimpleBlobDetector> retval;

    const char* keywords[] = { "parameters", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|O:SimpleBlobDetector_create", (char**)keywords, &jsobj_parameters) &&
        jsopencv_to_safe(jsobj_parameters, parameters, ArgInfo("parameters", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::SimpleBlobDetector::create(parameters));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_Sobel(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_ddepth = NULL;
    int ddepth=0;
    Napi::Value* jsobj_dx = NULL;
    int dx=0;
    Napi::Value* jsobj_dy = NULL;
    int dy=0;
    Napi::Value* jsobj_ksize = NULL;
    int ksize=3;
    Napi::Value* jsobj_scale = NULL;
    double scale=1;
    Napi::Value* jsobj_delta = NULL;
    double delta=0;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_DEFAULT;

    const char* keywords[] = { "src", "ddepth", "dx", "dy", "dst", "ksize", "scale", "delta", "borderType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOOOO:Sobel", (char**)keywords, &jsobj_src, &jsobj_ddepth, &jsobj_dx, &jsobj_dy, &jsobj_dst, &jsobj_ksize, &jsobj_scale, &jsobj_delta, &jsobj_borderType) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_ddepth, ddepth, ArgInfo("ddepth", 0)) &&
        jsopencv_to_safe(jsobj_dx, dx, ArgInfo("dx", 0)) &&
        jsopencv_to_safe(jsobj_dy, dy, ArgInfo("dy", 0)) &&
        jsopencv_to_safe(jsobj_ksize, ksize, ArgInfo("ksize", 0)) &&
        jsopencv_to_safe(jsobj_scale, scale, ArgInfo("scale", 0)) &&
        jsopencv_to_safe(jsobj_delta, delta, ArgInfo("delta", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)))
    {
        ERRWRAP2_NAPI(info, cv::Sobel(src, dst, ddepth, dx, dy, ksize, scale, delta, borderType));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_ddepth = NULL;
    int ddepth=0;
    Napi::Value* jsobj_dx = NULL;
    int dx=0;
    Napi::Value* jsobj_dy = NULL;
    int dy=0;
    Napi::Value* jsobj_ksize = NULL;
    int ksize=3;
    Napi::Value* jsobj_scale = NULL;
    double scale=1;
    Napi::Value* jsobj_delta = NULL;
    double delta=0;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_DEFAULT;

    const char* keywords[] = { "src", "ddepth", "dx", "dy", "dst", "ksize", "scale", "delta", "borderType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOOOO:Sobel", (char**)keywords, &jsobj_src, &jsobj_ddepth, &jsobj_dx, &jsobj_dy, &jsobj_dst, &jsobj_ksize, &jsobj_scale, &jsobj_delta, &jsobj_borderType) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_ddepth, ddepth, ArgInfo("ddepth", 0)) &&
        jsopencv_to_safe(jsobj_dx, dx, ArgInfo("dx", 0)) &&
        jsopencv_to_safe(jsobj_dy, dy, ArgInfo("dy", 0)) &&
        jsopencv_to_safe(jsobj_ksize, ksize, ArgInfo("ksize", 0)) &&
        jsopencv_to_safe(jsobj_scale, scale, ArgInfo("scale", 0)) &&
        jsopencv_to_safe(jsobj_delta, delta, ArgInfo("delta", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)))
    {
        ERRWRAP2_NAPI(info, cv::Sobel(src, dst, ddepth, dx, dy, ksize, scale, delta, borderType));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "Sobel");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_SparsePyrLKOpticalFlow_create(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_winSize = NULL;
    Size winSize=Size(21, 21);
    Napi::Value* jsobj_maxLevel = NULL;
    int maxLevel=3;
    Napi::Value* jsobj_crit = NULL;
    TermCriteria crit=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 0.01);
    Napi::Value* jsobj_flags = NULL;
    int flags=0;
    Napi::Value* jsobj_minEigThreshold = NULL;
    double minEigThreshold=1e-4;
    Ptr<SparsePyrLKOpticalFlow> retval;

    const char* keywords[] = { "winSize", "maxLevel", "crit", "flags", "minEigThreshold", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OOOOO:SparsePyrLKOpticalFlow_create", (char**)keywords, &jsobj_winSize, &jsobj_maxLevel, &jsobj_crit, &jsobj_flags, &jsobj_minEigThreshold) &&
        jsopencv_to_safe(jsobj_winSize, winSize, ArgInfo("winSize", 0)) &&
        jsopencv_to_safe(jsobj_maxLevel, maxLevel, ArgInfo("maxLevel", 0)) &&
        jsopencv_to_safe(jsobj_crit, crit, ArgInfo("crit", 0)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_minEigThreshold, minEigThreshold, ArgInfo("minEigThreshold", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::SparsePyrLKOpticalFlow::create(winSize, maxLevel, crit, flags, minEigThreshold));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_StereoBM_create(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_numDisparities = NULL;
    int numDisparities=0;
    Napi::Value* jsobj_blockSize = NULL;
    int blockSize=21;
    Ptr<StereoBM> retval;

    const char* keywords[] = { "numDisparities", "blockSize", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OO:StereoBM_create", (char**)keywords, &jsobj_numDisparities, &jsobj_blockSize) &&
        jsopencv_to_safe(jsobj_numDisparities, numDisparities, ArgInfo("numDisparities", 0)) &&
        jsopencv_to_safe(jsobj_blockSize, blockSize, ArgInfo("blockSize", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::StereoBM::create(numDisparities, blockSize));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_StereoSGBM_create(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_minDisparity = NULL;
    int minDisparity=0;
    Napi::Value* jsobj_numDisparities = NULL;
    int numDisparities=16;
    Napi::Value* jsobj_blockSize = NULL;
    int blockSize=3;
    Napi::Value* jsobj_P1 = NULL;
    int P1=0;
    Napi::Value* jsobj_P2 = NULL;
    int P2=0;
    Napi::Value* jsobj_disp12MaxDiff = NULL;
    int disp12MaxDiff=0;
    Napi::Value* jsobj_preFilterCap = NULL;
    int preFilterCap=0;
    Napi::Value* jsobj_uniquenessRatio = NULL;
    int uniquenessRatio=0;
    Napi::Value* jsobj_speckleWindowSize = NULL;
    int speckleWindowSize=0;
    Napi::Value* jsobj_speckleRange = NULL;
    int speckleRange=0;
    Napi::Value* jsobj_mode = NULL;
    int mode=StereoSGBM::MODE_SGBM;
    Ptr<StereoSGBM> retval;

    const char* keywords[] = { "minDisparity", "numDisparities", "blockSize", "P1", "P2", "disp12MaxDiff", "preFilterCap", "uniquenessRatio", "speckleWindowSize", "speckleRange", "mode", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OOOOOOOOOOO:StereoSGBM_create", (char**)keywords, &jsobj_minDisparity, &jsobj_numDisparities, &jsobj_blockSize, &jsobj_P1, &jsobj_P2, &jsobj_disp12MaxDiff, &jsobj_preFilterCap, &jsobj_uniquenessRatio, &jsobj_speckleWindowSize, &jsobj_speckleRange, &jsobj_mode) &&
        jsopencv_to_safe(jsobj_minDisparity, minDisparity, ArgInfo("minDisparity", 0)) &&
        jsopencv_to_safe(jsobj_numDisparities, numDisparities, ArgInfo("numDisparities", 0)) &&
        jsopencv_to_safe(jsobj_blockSize, blockSize, ArgInfo("blockSize", 0)) &&
        jsopencv_to_safe(jsobj_P1, P1, ArgInfo("P1", 0)) &&
        jsopencv_to_safe(jsobj_P2, P2, ArgInfo("P2", 0)) &&
        jsopencv_to_safe(jsobj_disp12MaxDiff, disp12MaxDiff, ArgInfo("disp12MaxDiff", 0)) &&
        jsopencv_to_safe(jsobj_preFilterCap, preFilterCap, ArgInfo("preFilterCap", 0)) &&
        jsopencv_to_safe(jsobj_uniquenessRatio, uniquenessRatio, ArgInfo("uniquenessRatio", 0)) &&
        jsopencv_to_safe(jsobj_speckleWindowSize, speckleWindowSize, ArgInfo("speckleWindowSize", 0)) &&
        jsopencv_to_safe(jsobj_speckleRange, speckleRange, ArgInfo("speckleRange", 0)) &&
        jsopencv_to_safe(jsobj_mode, mode, ArgInfo("mode", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::StereoSGBM::create(minDisparity, numDisparities, blockSize, P1, P2, disp12MaxDiff, preFilterCap, uniquenessRatio, speckleWindowSize, speckleRange, mode));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_TrackerCSRT_create(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_parameters = NULL;
    cv::TrackerCSRT::Params parameters=TrackerCSRT::Params();
    Ptr<TrackerCSRT> retval;

    const char* keywords[] = { "parameters", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|O:TrackerCSRT_create", (char**)keywords, &jsobj_parameters) &&
        jsopencv_to_safe(jsobj_parameters, parameters, ArgInfo("parameters", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::TrackerCSRT::create(parameters));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_TrackerDaSiamRPN_create(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_parameters = NULL;
    cv::TrackerDaSiamRPN::Params parameters=TrackerDaSiamRPN::Params();
    Ptr<TrackerDaSiamRPN> retval;

    const char* keywords[] = { "parameters", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|O:TrackerDaSiamRPN_create", (char**)keywords, &jsobj_parameters) &&
        jsopencv_to_safe(jsobj_parameters, parameters, ArgInfo("parameters", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::TrackerDaSiamRPN::create(parameters));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_TrackerGOTURN_create(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_parameters = NULL;
    cv::TrackerGOTURN::Params parameters=TrackerGOTURN::Params();
    Ptr<TrackerGOTURN> retval;

    const char* keywords[] = { "parameters", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|O:TrackerGOTURN_create", (char**)keywords, &jsobj_parameters) &&
        jsopencv_to_safe(jsobj_parameters, parameters, ArgInfo("parameters", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::TrackerGOTURN::create(parameters));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_TrackerKCF_create(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_parameters = NULL;
    cv::TrackerKCF::Params parameters=TrackerKCF::Params();
    Ptr<TrackerKCF> retval;

    const char* keywords[] = { "parameters", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|O:TrackerKCF_create", (char**)keywords, &jsobj_parameters) &&
        jsopencv_to_safe(jsobj_parameters, parameters, ArgInfo("parameters", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::TrackerKCF::create(parameters));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_TrackerMIL_create(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_parameters = NULL;
    cv::TrackerMIL::Params parameters=TrackerMIL::Params();
    Ptr<TrackerMIL> retval;

    const char* keywords[] = { "parameters", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|O:TrackerMIL_create", (char**)keywords, &jsobj_parameters) &&
        jsopencv_to_safe(jsobj_parameters, parameters, ArgInfo("parameters", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::TrackerMIL::create(parameters));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_TrackerNano_create(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_parameters = NULL;
    cv::TrackerNano::Params parameters=TrackerNano::Params();
    Ptr<TrackerNano> retval;

    const char* keywords[] = { "parameters", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|O:TrackerNano_create", (char**)keywords, &jsobj_parameters) &&
        jsopencv_to_safe(jsobj_parameters, parameters, ArgInfo("parameters", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::TrackerNano::create(parameters));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_UMat_context(const Napi::CallbackInfo &info)
{
    using namespace cv;

    void* retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv_UMat_context());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_UMat_queue(const Napi::CallbackInfo &info)
{
    using namespace cv;

    void* retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv_UMat_queue());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_VariationalRefinement_create(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Ptr<VariationalRefinement> retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::VariationalRefinement::create());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_VideoCapture_waitAny(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_streams = NULL;
    vector_VideoCapture streams;
    vector_int readyIndex;
    Napi::Value* jsobj_timeoutNs = NULL;
    int64 timeoutNs=0;
    bool retval;

    const char* keywords[] = { "streams", "timeoutNs", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:VideoCapture_waitAny", (char**)keywords, &jsobj_streams, &jsobj_timeoutNs) &&
        jsopencv_to_safe(jsobj_streams, streams, ArgInfo("streams", 0)) &&
        jsopencv_to_safe(jsobj_timeoutNs, timeoutNs, ArgInfo("timeoutNs", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::VideoCapture::waitAny(streams, readyIndex, timeoutNs));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, readyIndex));
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_VideoWriter_fourcc(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_c1 = NULL;
    char c1;
    Napi::Value* jsobj_c2 = NULL;
    char c2;
    Napi::Value* jsobj_c3 = NULL;
    char c3;
    Napi::Value* jsobj_c4 = NULL;
    char c4;
    int retval;

    const char* keywords[] = { "c1", "c2", "c3", "c4", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO:VideoWriter_fourcc", (char**)keywords, &jsobj_c1, &jsobj_c2, &jsobj_c3, &jsobj_c4) &&
        jsconvert_to_char(*jsobj_c1, &c1, ArgInfo("c1", 0)) &&
        jsconvert_to_char(*jsobj_c2, &c2, ArgInfo("c2", 0)) &&
        jsconvert_to_char(*jsobj_c3, &c3, ArgInfo("c3", 0)) &&
        jsconvert_to_char(*jsobj_c4, &c4, ArgInfo("c4", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::VideoWriter::fourcc(c1, c2, c3, c4));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_absdiff(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src1 = NULL;
    Mat src1;
    Napi::Value* jsobj_src2 = NULL;
    Mat src2;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;

    const char* keywords[] = { "src1", "src2", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:absdiff", (char**)keywords, &jsobj_src1, &jsobj_src2, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)))
    {
        ERRWRAP2_NAPI(info, cv::absdiff(src1, src2, dst));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src1 = NULL;
    UMat src1;
    Napi::Value* jsobj_src2 = NULL;
    UMat src2;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;

    const char* keywords[] = { "src1", "src2", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:absdiff", (char**)keywords, &jsobj_src1, &jsobj_src2, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)))
    {
        ERRWRAP2_NAPI(info, cv::absdiff(src1, src2, dst));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "absdiff");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_accumulate(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_mask = NULL;
    Mat mask;

    const char* keywords[] = { "src", "dst", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:accumulate", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)))
    {
        ERRWRAP2_NAPI(info, cv::accumulate(src, dst, mask));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_mask = NULL;
    UMat mask;

    const char* keywords[] = { "src", "dst", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:accumulate", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)))
    {
        ERRWRAP2_NAPI(info, cv::accumulate(src, dst, mask));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "accumulate");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_accumulateProduct(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src1 = NULL;
    Mat src1;
    Napi::Value* jsobj_src2 = NULL;
    Mat src2;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_mask = NULL;
    Mat mask;

    const char* keywords[] = { "src1", "src2", "dst", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:accumulateProduct", (char**)keywords, &jsobj_src1, &jsobj_src2, &jsobj_dst, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)))
    {
        ERRWRAP2_NAPI(info, cv::accumulateProduct(src1, src2, dst, mask));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src1 = NULL;
    UMat src1;
    Napi::Value* jsobj_src2 = NULL;
    UMat src2;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_mask = NULL;
    UMat mask;

    const char* keywords[] = { "src1", "src2", "dst", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:accumulateProduct", (char**)keywords, &jsobj_src1, &jsobj_src2, &jsobj_dst, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)))
    {
        ERRWRAP2_NAPI(info, cv::accumulateProduct(src1, src2, dst, mask));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "accumulateProduct");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_accumulateSquare(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_mask = NULL;
    Mat mask;

    const char* keywords[] = { "src", "dst", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:accumulateSquare", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)))
    {
        ERRWRAP2_NAPI(info, cv::accumulateSquare(src, dst, mask));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_mask = NULL;
    UMat mask;

    const char* keywords[] = { "src", "dst", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:accumulateSquare", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)))
    {
        ERRWRAP2_NAPI(info, cv::accumulateSquare(src, dst, mask));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "accumulateSquare");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_accumulateWeighted(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_alpha = NULL;
    double alpha=0;
    Napi::Value* jsobj_mask = NULL;
    Mat mask;

    const char* keywords[] = { "src", "dst", "alpha", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:accumulateWeighted", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_alpha, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_alpha, alpha, ArgInfo("alpha", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)))
    {
        ERRWRAP2_NAPI(info, cv::accumulateWeighted(src, dst, alpha, mask));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_alpha = NULL;
    double alpha=0;
    Napi::Value* jsobj_mask = NULL;
    UMat mask;

    const char* keywords[] = { "src", "dst", "alpha", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:accumulateWeighted", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_alpha, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_alpha, alpha, ArgInfo("alpha", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)))
    {
        ERRWRAP2_NAPI(info, cv::accumulateWeighted(src, dst, alpha, mask));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "accumulateWeighted");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_adaptiveThreshold(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_maxValue = NULL;
    double maxValue=0;
    Napi::Value* jsobj_adaptiveMethod = NULL;
    int adaptiveMethod=0;
    Napi::Value* jsobj_thresholdType = NULL;
    int thresholdType=0;
    Napi::Value* jsobj_blockSize = NULL;
    int blockSize=0;
    Napi::Value* jsobj_C = NULL;
    double C=0;

    const char* keywords[] = { "src", "maxValue", "adaptiveMethod", "thresholdType", "blockSize", "C", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOO|O:adaptiveThreshold", (char**)keywords, &jsobj_src, &jsobj_maxValue, &jsobj_adaptiveMethod, &jsobj_thresholdType, &jsobj_blockSize, &jsobj_C, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_maxValue, maxValue, ArgInfo("maxValue", 0)) &&
        jsopencv_to_safe(jsobj_adaptiveMethod, adaptiveMethod, ArgInfo("adaptiveMethod", 0)) &&
        jsopencv_to_safe(jsobj_thresholdType, thresholdType, ArgInfo("thresholdType", 0)) &&
        jsopencv_to_safe(jsobj_blockSize, blockSize, ArgInfo("blockSize", 0)) &&
        jsopencv_to_safe(jsobj_C, C, ArgInfo("C", 0)))
    {
        ERRWRAP2_NAPI(info, cv::adaptiveThreshold(src, dst, maxValue, adaptiveMethod, thresholdType, blockSize, C));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_maxValue = NULL;
    double maxValue=0;
    Napi::Value* jsobj_adaptiveMethod = NULL;
    int adaptiveMethod=0;
    Napi::Value* jsobj_thresholdType = NULL;
    int thresholdType=0;
    Napi::Value* jsobj_blockSize = NULL;
    int blockSize=0;
    Napi::Value* jsobj_C = NULL;
    double C=0;

    const char* keywords[] = { "src", "maxValue", "adaptiveMethod", "thresholdType", "blockSize", "C", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOO|O:adaptiveThreshold", (char**)keywords, &jsobj_src, &jsobj_maxValue, &jsobj_adaptiveMethod, &jsobj_thresholdType, &jsobj_blockSize, &jsobj_C, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_maxValue, maxValue, ArgInfo("maxValue", 0)) &&
        jsopencv_to_safe(jsobj_adaptiveMethod, adaptiveMethod, ArgInfo("adaptiveMethod", 0)) &&
        jsopencv_to_safe(jsobj_thresholdType, thresholdType, ArgInfo("thresholdType", 0)) &&
        jsopencv_to_safe(jsobj_blockSize, blockSize, ArgInfo("blockSize", 0)) &&
        jsopencv_to_safe(jsobj_C, C, ArgInfo("C", 0)))
    {
        ERRWRAP2_NAPI(info, cv::adaptiveThreshold(src, dst, maxValue, adaptiveMethod, thresholdType, blockSize, C));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "adaptiveThreshold");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_add(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src1 = NULL;
    Mat src1;
    Napi::Value* jsobj_src2 = NULL;
    Mat src2;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_mask = NULL;
    Mat mask;
    Napi::Value* jsobj_dtype = NULL;
    int dtype=-1;

    const char* keywords[] = { "src1", "src2", "dst", "mask", "dtype", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOO:add", (char**)keywords, &jsobj_src1, &jsobj_src2, &jsobj_dst, &jsobj_mask, &jsobj_dtype) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)) &&
        jsopencv_to_safe(jsobj_dtype, dtype, ArgInfo("dtype", 0)))
    {
        ERRWRAP2_NAPI(info, cv::add(src1, src2, dst, mask, dtype));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src1 = NULL;
    UMat src1;
    Napi::Value* jsobj_src2 = NULL;
    UMat src2;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_mask = NULL;
    UMat mask;
    Napi::Value* jsobj_dtype = NULL;
    int dtype=-1;

    const char* keywords[] = { "src1", "src2", "dst", "mask", "dtype", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOO:add", (char**)keywords, &jsobj_src1, &jsobj_src2, &jsobj_dst, &jsobj_mask, &jsobj_dtype) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)) &&
        jsopencv_to_safe(jsobj_dtype, dtype, ArgInfo("dtype", 0)))
    {
        ERRWRAP2_NAPI(info, cv::add(src1, src2, dst, mask, dtype));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "add");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_addText(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_img = NULL;
    Mat img;
    Napi::Value* jsobj_text = NULL;
    String text;
    Napi::Value* jsobj_org = NULL;
    Point org;
    Napi::Value* jsobj_nameFont = NULL;
    String nameFont;
    Napi::Value* jsobj_pointSize = NULL;
    int pointSize=-1;
    Napi::Value* jsobj_color = NULL;
    Scalar color=Scalar::all(0);
    Napi::Value* jsobj_weight = NULL;
    int weight=QT_FONT_NORMAL;
    Napi::Value* jsobj_style = NULL;
    int style=QT_STYLE_NORMAL;
    Napi::Value* jsobj_spacing = NULL;
    int spacing=0;

    const char* keywords[] = { "img", "text", "org", "nameFont", "pointSize", "color", "weight", "style", "spacing", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOOOO:addText", (char**)keywords, &jsobj_img, &jsobj_text, &jsobj_org, &jsobj_nameFont, &jsobj_pointSize, &jsobj_color, &jsobj_weight, &jsobj_style, &jsobj_spacing) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 0)) &&
        jsopencv_to_safe(jsobj_text, text, ArgInfo("text", 0)) &&
        jsopencv_to_safe(jsobj_org, org, ArgInfo("org", 0)) &&
        jsopencv_to_safe(jsobj_nameFont, nameFont, ArgInfo("nameFont", 0)) &&
        jsopencv_to_safe(jsobj_pointSize, pointSize, ArgInfo("pointSize", 0)) &&
        jsopencv_to_safe(jsobj_color, color, ArgInfo("color", 0)) &&
        jsopencv_to_safe(jsobj_weight, weight, ArgInfo("weight", 0)) &&
        jsopencv_to_safe(jsobj_style, style, ArgInfo("style", 0)) &&
        jsopencv_to_safe(jsobj_spacing, spacing, ArgInfo("spacing", 0)))
    {
        ERRWRAP2_NAPI(info, cv::addText(img, text, org, nameFont, pointSize, color, weight, style, spacing));
        return info.Env().Null();;
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_addWeighted(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src1 = NULL;
    Mat src1;
    Napi::Value* jsobj_alpha = NULL;
    double alpha=0;
    Napi::Value* jsobj_src2 = NULL;
    Mat src2;
    Napi::Value* jsobj_beta = NULL;
    double beta=0;
    Napi::Value* jsobj_gamma = NULL;
    double gamma=0;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_dtype = NULL;
    int dtype=-1;

    const char* keywords[] = { "src1", "alpha", "src2", "beta", "gamma", "dst", "dtype", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOO|OO:addWeighted", (char**)keywords, &jsobj_src1, &jsobj_alpha, &jsobj_src2, &jsobj_beta, &jsobj_gamma, &jsobj_dst, &jsobj_dtype) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_alpha, alpha, ArgInfo("alpha", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_beta, beta, ArgInfo("beta", 0)) &&
        jsopencv_to_safe(jsobj_gamma, gamma, ArgInfo("gamma", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_dtype, dtype, ArgInfo("dtype", 0)))
    {
        ERRWRAP2_NAPI(info, cv::addWeighted(src1, alpha, src2, beta, gamma, dst, dtype));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src1 = NULL;
    UMat src1;
    Napi::Value* jsobj_alpha = NULL;
    double alpha=0;
    Napi::Value* jsobj_src2 = NULL;
    UMat src2;
    Napi::Value* jsobj_beta = NULL;
    double beta=0;
    Napi::Value* jsobj_gamma = NULL;
    double gamma=0;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_dtype = NULL;
    int dtype=-1;

    const char* keywords[] = { "src1", "alpha", "src2", "beta", "gamma", "dst", "dtype", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOO|OO:addWeighted", (char**)keywords, &jsobj_src1, &jsobj_alpha, &jsobj_src2, &jsobj_beta, &jsobj_gamma, &jsobj_dst, &jsobj_dtype) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_alpha, alpha, ArgInfo("alpha", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_beta, beta, ArgInfo("beta", 0)) &&
        jsopencv_to_safe(jsobj_gamma, gamma, ArgInfo("gamma", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_dtype, dtype, ArgInfo("dtype", 0)))
    {
        ERRWRAP2_NAPI(info, cv::addWeighted(src1, alpha, src2, beta, gamma, dst, dtype));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "addWeighted");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_applyColorMap(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(4);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_colormap = NULL;
    int colormap=0;

    const char* keywords[] = { "src", "colormap", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:applyColorMap", (char**)keywords, &jsobj_src, &jsobj_colormap, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_colormap, colormap, ArgInfo("colormap", 0)))
    {
        ERRWRAP2_NAPI(info, cv::applyColorMap(src, dst, colormap));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_colormap = NULL;
    int colormap=0;

    const char* keywords[] = { "src", "colormap", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:applyColorMap", (char**)keywords, &jsobj_src, &jsobj_colormap, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_colormap, colormap, ArgInfo("colormap", 0)))
    {
        ERRWRAP2_NAPI(info, cv::applyColorMap(src, dst, colormap));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_userColor = NULL;
    Mat userColor;

    const char* keywords[] = { "src", "userColor", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:applyColorMap", (char**)keywords, &jsobj_src, &jsobj_userColor, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_userColor, userColor, ArgInfo("userColor", 0)))
    {
        ERRWRAP2_NAPI(info, cv::applyColorMap(src, dst, userColor));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_userColor = NULL;
    UMat userColor;

    const char* keywords[] = { "src", "userColor", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:applyColorMap", (char**)keywords, &jsobj_src, &jsobj_userColor, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_userColor, userColor, ArgInfo("userColor", 0)))
    {
        ERRWRAP2_NAPI(info, cv::applyColorMap(src, dst, userColor));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "applyColorMap");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_approxPolyDP(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_curve = NULL;
    Mat curve;
    Napi::Value* jsobj_approxCurve = NULL;
    Mat approxCurve;
    Napi::Value* jsobj_epsilon = NULL;
    double epsilon=0;
    Napi::Value* jsobj_closed = NULL;
    bool closed=0;

    const char* keywords[] = { "curve", "epsilon", "closed", "approxCurve", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:approxPolyDP", (char**)keywords, &jsobj_curve, &jsobj_epsilon, &jsobj_closed, &jsobj_approxCurve) &&
        jsopencv_to_safe(jsobj_curve, curve, ArgInfo("curve", 0)) &&
        jsopencv_to_safe(jsobj_approxCurve, approxCurve, ArgInfo("approxCurve", 1)) &&
        jsopencv_to_safe(jsobj_epsilon, epsilon, ArgInfo("epsilon", 0)) &&
        jsopencv_to_safe(jsobj_closed, closed, ArgInfo("closed", 0)))
    {
        ERRWRAP2_NAPI(info, cv::approxPolyDP(curve, approxCurve, epsilon, closed));
        return jsopencv_from(info, approxCurve);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_curve = NULL;
    UMat curve;
    Napi::Value* jsobj_approxCurve = NULL;
    UMat approxCurve;
    Napi::Value* jsobj_epsilon = NULL;
    double epsilon=0;
    Napi::Value* jsobj_closed = NULL;
    bool closed=0;

    const char* keywords[] = { "curve", "epsilon", "closed", "approxCurve", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:approxPolyDP", (char**)keywords, &jsobj_curve, &jsobj_epsilon, &jsobj_closed, &jsobj_approxCurve) &&
        jsopencv_to_safe(jsobj_curve, curve, ArgInfo("curve", 0)) &&
        jsopencv_to_safe(jsobj_approxCurve, approxCurve, ArgInfo("approxCurve", 1)) &&
        jsopencv_to_safe(jsobj_epsilon, epsilon, ArgInfo("epsilon", 0)) &&
        jsopencv_to_safe(jsobj_closed, closed, ArgInfo("closed", 0)))
    {
        ERRWRAP2_NAPI(info, cv::approxPolyDP(curve, approxCurve, epsilon, closed));
        return jsopencv_from(info, approxCurve);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "approxPolyDP");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_arcLength(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_curve = NULL;
    Mat curve;
    Napi::Value* jsobj_closed = NULL;
    bool closed=0;
    double retval;

    const char* keywords[] = { "curve", "closed", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:arcLength", (char**)keywords, &jsobj_curve, &jsobj_closed) &&
        jsopencv_to_safe(jsobj_curve, curve, ArgInfo("curve", 0)) &&
        jsopencv_to_safe(jsobj_closed, closed, ArgInfo("closed", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::arcLength(curve, closed));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_curve = NULL;
    UMat curve;
    Napi::Value* jsobj_closed = NULL;
    bool closed=0;
    double retval;

    const char* keywords[] = { "curve", "closed", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:arcLength", (char**)keywords, &jsobj_curve, &jsobj_closed) &&
        jsopencv_to_safe(jsobj_curve, curve, ArgInfo("curve", 0)) &&
        jsopencv_to_safe(jsobj_closed, closed, ArgInfo("closed", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::arcLength(curve, closed));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "arcLength");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_arrowedLine(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_img = NULL;
    Mat img;
    Napi::Value* jsobj_pt1 = NULL;
    Point pt1;
    Napi::Value* jsobj_pt2 = NULL;
    Point pt2;
    Napi::Value* jsobj_color = NULL;
    Scalar color;
    Napi::Value* jsobj_thickness = NULL;
    int thickness=1;
    Napi::Value* jsobj_line_type = NULL;
    int line_type=8;
    Napi::Value* jsobj_shift = NULL;
    int shift=0;
    Napi::Value* jsobj_tipLength = NULL;
    double tipLength=0.1;

    const char* keywords[] = { "img", "pt1", "pt2", "color", "thickness", "line_type", "shift", "tipLength", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOOO:arrowedLine", (char**)keywords, &jsobj_img, &jsobj_pt1, &jsobj_pt2, &jsobj_color, &jsobj_thickness, &jsobj_line_type, &jsobj_shift, &jsobj_tipLength) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 1)) &&
        jsopencv_to_safe(jsobj_pt1, pt1, ArgInfo("pt1", 0)) &&
        jsopencv_to_safe(jsobj_pt2, pt2, ArgInfo("pt2", 0)) &&
        jsopencv_to_safe(jsobj_color, color, ArgInfo("color", 0)) &&
        jsopencv_to_safe(jsobj_thickness, thickness, ArgInfo("thickness", 0)) &&
        jsopencv_to_safe(jsobj_line_type, line_type, ArgInfo("line_type", 0)) &&
        jsopencv_to_safe(jsobj_shift, shift, ArgInfo("shift", 0)) &&
        jsopencv_to_safe(jsobj_tipLength, tipLength, ArgInfo("tipLength", 0)))
    {
        ERRWRAP2_NAPI(info, cv::arrowedLine(img, pt1, pt2, color, thickness, line_type, shift, tipLength));
        return jsopencv_from(info, img);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_img = NULL;
    UMat img;
    Napi::Value* jsobj_pt1 = NULL;
    Point pt1;
    Napi::Value* jsobj_pt2 = NULL;
    Point pt2;
    Napi::Value* jsobj_color = NULL;
    Scalar color;
    Napi::Value* jsobj_thickness = NULL;
    int thickness=1;
    Napi::Value* jsobj_line_type = NULL;
    int line_type=8;
    Napi::Value* jsobj_shift = NULL;
    int shift=0;
    Napi::Value* jsobj_tipLength = NULL;
    double tipLength=0.1;

    const char* keywords[] = { "img", "pt1", "pt2", "color", "thickness", "line_type", "shift", "tipLength", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOOO:arrowedLine", (char**)keywords, &jsobj_img, &jsobj_pt1, &jsobj_pt2, &jsobj_color, &jsobj_thickness, &jsobj_line_type, &jsobj_shift, &jsobj_tipLength) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 1)) &&
        jsopencv_to_safe(jsobj_pt1, pt1, ArgInfo("pt1", 0)) &&
        jsopencv_to_safe(jsobj_pt2, pt2, ArgInfo("pt2", 0)) &&
        jsopencv_to_safe(jsobj_color, color, ArgInfo("color", 0)) &&
        jsopencv_to_safe(jsobj_thickness, thickness, ArgInfo("thickness", 0)) &&
        jsopencv_to_safe(jsobj_line_type, line_type, ArgInfo("line_type", 0)) &&
        jsopencv_to_safe(jsobj_shift, shift, ArgInfo("shift", 0)) &&
        jsopencv_to_safe(jsobj_tipLength, tipLength, ArgInfo("tipLength", 0)))
    {
        ERRWRAP2_NAPI(info, cv::arrowedLine(img, pt1, pt2, color, thickness, line_type, shift, tipLength));
        return jsopencv_from(info, img);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "arrowedLine");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_batchDistance(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src1 = NULL;
    Mat src1;
    Napi::Value* jsobj_src2 = NULL;
    Mat src2;
    Napi::Value* jsobj_dist = NULL;
    Mat dist;
    Napi::Value* jsobj_dtype = NULL;
    int dtype=0;
    Napi::Value* jsobj_nidx = NULL;
    Mat nidx;
    Napi::Value* jsobj_normType = NULL;
    int normType=NORM_L2;
    Napi::Value* jsobj_K = NULL;
    int K=0;
    Napi::Value* jsobj_mask = NULL;
    Mat mask;
    Napi::Value* jsobj_update = NULL;
    int update=0;
    Napi::Value* jsobj_crosscheck = NULL;
    bool crosscheck=false;

    const char* keywords[] = { "src1", "src2", "dtype", "dist", "nidx", "normType", "K", "mask", "update", "crosscheck", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOOOOOO:batchDistance", (char**)keywords, &jsobj_src1, &jsobj_src2, &jsobj_dtype, &jsobj_dist, &jsobj_nidx, &jsobj_normType, &jsobj_K, &jsobj_mask, &jsobj_update, &jsobj_crosscheck) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_dist, dist, ArgInfo("dist", 1)) &&
        jsopencv_to_safe(jsobj_dtype, dtype, ArgInfo("dtype", 0)) &&
        jsopencv_to_safe(jsobj_nidx, nidx, ArgInfo("nidx", 1)) &&
        jsopencv_to_safe(jsobj_normType, normType, ArgInfo("normType", 0)) &&
        jsopencv_to_safe(jsobj_K, K, ArgInfo("K", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)) &&
        jsopencv_to_safe(jsobj_update, update, ArgInfo("update", 0)) &&
        jsopencv_to_safe(jsobj_crosscheck, crosscheck, ArgInfo("crosscheck", 0)))
    {
        ERRWRAP2_NAPI(info, cv::batchDistance(src1, src2, dist, dtype, nidx, normType, K, mask, update, crosscheck));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, dist), jsopencv_from(info, nidx));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src1 = NULL;
    UMat src1;
    Napi::Value* jsobj_src2 = NULL;
    UMat src2;
    Napi::Value* jsobj_dist = NULL;
    UMat dist;
    Napi::Value* jsobj_dtype = NULL;
    int dtype=0;
    Napi::Value* jsobj_nidx = NULL;
    UMat nidx;
    Napi::Value* jsobj_normType = NULL;
    int normType=NORM_L2;
    Napi::Value* jsobj_K = NULL;
    int K=0;
    Napi::Value* jsobj_mask = NULL;
    UMat mask;
    Napi::Value* jsobj_update = NULL;
    int update=0;
    Napi::Value* jsobj_crosscheck = NULL;
    bool crosscheck=false;

    const char* keywords[] = { "src1", "src2", "dtype", "dist", "nidx", "normType", "K", "mask", "update", "crosscheck", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOOOOOO:batchDistance", (char**)keywords, &jsobj_src1, &jsobj_src2, &jsobj_dtype, &jsobj_dist, &jsobj_nidx, &jsobj_normType, &jsobj_K, &jsobj_mask, &jsobj_update, &jsobj_crosscheck) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_dist, dist, ArgInfo("dist", 1)) &&
        jsopencv_to_safe(jsobj_dtype, dtype, ArgInfo("dtype", 0)) &&
        jsopencv_to_safe(jsobj_nidx, nidx, ArgInfo("nidx", 1)) &&
        jsopencv_to_safe(jsobj_normType, normType, ArgInfo("normType", 0)) &&
        jsopencv_to_safe(jsobj_K, K, ArgInfo("K", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)) &&
        jsopencv_to_safe(jsobj_update, update, ArgInfo("update", 0)) &&
        jsopencv_to_safe(jsobj_crosscheck, crosscheck, ArgInfo("crosscheck", 0)))
    {
        ERRWRAP2_NAPI(info, cv::batchDistance(src1, src2, dist, dtype, nidx, normType, K, mask, update, crosscheck));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, dist), jsopencv_from(info, nidx));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "batchDistance");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_bilateralFilter(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_d = NULL;
    int d=0;
    Napi::Value* jsobj_sigmaColor = NULL;
    double sigmaColor=0;
    Napi::Value* jsobj_sigmaSpace = NULL;
    double sigmaSpace=0;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_DEFAULT;

    const char* keywords[] = { "src", "d", "sigmaColor", "sigmaSpace", "dst", "borderType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OO:bilateralFilter", (char**)keywords, &jsobj_src, &jsobj_d, &jsobj_sigmaColor, &jsobj_sigmaSpace, &jsobj_dst, &jsobj_borderType) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_d, d, ArgInfo("d", 0)) &&
        jsopencv_to_safe(jsobj_sigmaColor, sigmaColor, ArgInfo("sigmaColor", 0)) &&
        jsopencv_to_safe(jsobj_sigmaSpace, sigmaSpace, ArgInfo("sigmaSpace", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)))
    {
        ERRWRAP2_NAPI(info, cv::bilateralFilter(src, dst, d, sigmaColor, sigmaSpace, borderType));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_d = NULL;
    int d=0;
    Napi::Value* jsobj_sigmaColor = NULL;
    double sigmaColor=0;
    Napi::Value* jsobj_sigmaSpace = NULL;
    double sigmaSpace=0;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_DEFAULT;

    const char* keywords[] = { "src", "d", "sigmaColor", "sigmaSpace", "dst", "borderType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OO:bilateralFilter", (char**)keywords, &jsobj_src, &jsobj_d, &jsobj_sigmaColor, &jsobj_sigmaSpace, &jsobj_dst, &jsobj_borderType) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_d, d, ArgInfo("d", 0)) &&
        jsopencv_to_safe(jsobj_sigmaColor, sigmaColor, ArgInfo("sigmaColor", 0)) &&
        jsopencv_to_safe(jsobj_sigmaSpace, sigmaSpace, ArgInfo("sigmaSpace", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)))
    {
        ERRWRAP2_NAPI(info, cv::bilateralFilter(src, dst, d, sigmaColor, sigmaSpace, borderType));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "bilateralFilter");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_bitwise_and(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src1 = NULL;
    Mat src1;
    Napi::Value* jsobj_src2 = NULL;
    Mat src2;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_mask = NULL;
    Mat mask;

    const char* keywords[] = { "src1", "src2", "dst", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:bitwise_and", (char**)keywords, &jsobj_src1, &jsobj_src2, &jsobj_dst, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)))
    {
        ERRWRAP2_NAPI(info, cv::bitwise_and(src1, src2, dst, mask));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src1 = NULL;
    UMat src1;
    Napi::Value* jsobj_src2 = NULL;
    UMat src2;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_mask = NULL;
    UMat mask;

    const char* keywords[] = { "src1", "src2", "dst", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:bitwise_and", (char**)keywords, &jsobj_src1, &jsobj_src2, &jsobj_dst, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)))
    {
        ERRWRAP2_NAPI(info, cv::bitwise_and(src1, src2, dst, mask));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "bitwise_and");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_bitwise_not(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_mask = NULL;
    Mat mask;

    const char* keywords[] = { "src", "dst", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OO:bitwise_not", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)))
    {
        ERRWRAP2_NAPI(info, cv::bitwise_not(src, dst, mask));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_mask = NULL;
    UMat mask;

    const char* keywords[] = { "src", "dst", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OO:bitwise_not", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)))
    {
        ERRWRAP2_NAPI(info, cv::bitwise_not(src, dst, mask));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "bitwise_not");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_bitwise_or(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src1 = NULL;
    Mat src1;
    Napi::Value* jsobj_src2 = NULL;
    Mat src2;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_mask = NULL;
    Mat mask;

    const char* keywords[] = { "src1", "src2", "dst", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:bitwise_or", (char**)keywords, &jsobj_src1, &jsobj_src2, &jsobj_dst, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)))
    {
        ERRWRAP2_NAPI(info, cv::bitwise_or(src1, src2, dst, mask));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src1 = NULL;
    UMat src1;
    Napi::Value* jsobj_src2 = NULL;
    UMat src2;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_mask = NULL;
    UMat mask;

    const char* keywords[] = { "src1", "src2", "dst", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:bitwise_or", (char**)keywords, &jsobj_src1, &jsobj_src2, &jsobj_dst, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)))
    {
        ERRWRAP2_NAPI(info, cv::bitwise_or(src1, src2, dst, mask));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "bitwise_or");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_bitwise_xor(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src1 = NULL;
    Mat src1;
    Napi::Value* jsobj_src2 = NULL;
    Mat src2;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_mask = NULL;
    Mat mask;

    const char* keywords[] = { "src1", "src2", "dst", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:bitwise_xor", (char**)keywords, &jsobj_src1, &jsobj_src2, &jsobj_dst, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)))
    {
        ERRWRAP2_NAPI(info, cv::bitwise_xor(src1, src2, dst, mask));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src1 = NULL;
    UMat src1;
    Napi::Value* jsobj_src2 = NULL;
    UMat src2;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_mask = NULL;
    UMat mask;

    const char* keywords[] = { "src1", "src2", "dst", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:bitwise_xor", (char**)keywords, &jsobj_src1, &jsobj_src2, &jsobj_dst, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)))
    {
        ERRWRAP2_NAPI(info, cv::bitwise_xor(src1, src2, dst, mask));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "bitwise_xor");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_blendLinear(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src1 = NULL;
    Mat src1;
    Napi::Value* jsobj_src2 = NULL;
    Mat src2;
    Napi::Value* jsobj_weights1 = NULL;
    Mat weights1;
    Napi::Value* jsobj_weights2 = NULL;
    Mat weights2;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;

    const char* keywords[] = { "src1", "src2", "weights1", "weights2", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|O:blendLinear", (char**)keywords, &jsobj_src1, &jsobj_src2, &jsobj_weights1, &jsobj_weights2, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_weights1, weights1, ArgInfo("weights1", 0)) &&
        jsopencv_to_safe(jsobj_weights2, weights2, ArgInfo("weights2", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)))
    {
        ERRWRAP2_NAPI(info, cv::blendLinear(src1, src2, weights1, weights2, dst));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src1 = NULL;
    UMat src1;
    Napi::Value* jsobj_src2 = NULL;
    UMat src2;
    Napi::Value* jsobj_weights1 = NULL;
    UMat weights1;
    Napi::Value* jsobj_weights2 = NULL;
    UMat weights2;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;

    const char* keywords[] = { "src1", "src2", "weights1", "weights2", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|O:blendLinear", (char**)keywords, &jsobj_src1, &jsobj_src2, &jsobj_weights1, &jsobj_weights2, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_weights1, weights1, ArgInfo("weights1", 0)) &&
        jsopencv_to_safe(jsobj_weights2, weights2, ArgInfo("weights2", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)))
    {
        ERRWRAP2_NAPI(info, cv::blendLinear(src1, src2, weights1, weights2, dst));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "blendLinear");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_blur(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_ksize = NULL;
    Size ksize;
    Napi::Value* jsobj_anchor = NULL;
    Point anchor=Point(-1,-1);
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_DEFAULT;

    const char* keywords[] = { "src", "ksize", "dst", "anchor", "borderType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOO:blur", (char**)keywords, &jsobj_src, &jsobj_ksize, &jsobj_dst, &jsobj_anchor, &jsobj_borderType) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_ksize, ksize, ArgInfo("ksize", 0)) &&
        jsopencv_to_safe(jsobj_anchor, anchor, ArgInfo("anchor", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)))
    {
        ERRWRAP2_NAPI(info, cv::blur(src, dst, ksize, anchor, borderType));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_ksize = NULL;
    Size ksize;
    Napi::Value* jsobj_anchor = NULL;
    Point anchor=Point(-1,-1);
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_DEFAULT;

    const char* keywords[] = { "src", "ksize", "dst", "anchor", "borderType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOO:blur", (char**)keywords, &jsobj_src, &jsobj_ksize, &jsobj_dst, &jsobj_anchor, &jsobj_borderType) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_ksize, ksize, ArgInfo("ksize", 0)) &&
        jsopencv_to_safe(jsobj_anchor, anchor, ArgInfo("anchor", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)))
    {
        ERRWRAP2_NAPI(info, cv::blur(src, dst, ksize, anchor, borderType));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "blur");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_borderInterpolate(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_p = NULL;
    int p=0;
    Napi::Value* jsobj_len = NULL;
    int len=0;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=0;
    int retval;

    const char* keywords[] = { "p", "len", "borderType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:borderInterpolate", (char**)keywords, &jsobj_p, &jsobj_len, &jsobj_borderType) &&
        jsopencv_to_safe(jsobj_p, p, ArgInfo("p", 0)) &&
        jsopencv_to_safe(jsobj_len, len, ArgInfo("len", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::borderInterpolate(p, len, borderType));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_boundingRect(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_array = NULL;
    Mat array;
    Rect retval;

    const char* keywords[] = { "array", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:boundingRect", (char**)keywords, &jsobj_array) &&
        jsopencv_to_safe(jsobj_array, array, ArgInfo("array", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::boundingRect(array));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_array = NULL;
    UMat array;
    Rect retval;

    const char* keywords[] = { "array", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:boundingRect", (char**)keywords, &jsobj_array) &&
        jsopencv_to_safe(jsobj_array, array, ArgInfo("array", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::boundingRect(array));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "boundingRect");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_boxFilter(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_ddepth = NULL;
    int ddepth=0;
    Napi::Value* jsobj_ksize = NULL;
    Size ksize;
    Napi::Value* jsobj_anchor = NULL;
    Point anchor=Point(-1,-1);
    Napi::Value* jsobj_normalize = NULL;
    bool normalize=true;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_DEFAULT;

    const char* keywords[] = { "src", "ddepth", "ksize", "dst", "anchor", "normalize", "borderType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOOO:boxFilter", (char**)keywords, &jsobj_src, &jsobj_ddepth, &jsobj_ksize, &jsobj_dst, &jsobj_anchor, &jsobj_normalize, &jsobj_borderType) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_ddepth, ddepth, ArgInfo("ddepth", 0)) &&
        jsopencv_to_safe(jsobj_ksize, ksize, ArgInfo("ksize", 0)) &&
        jsopencv_to_safe(jsobj_anchor, anchor, ArgInfo("anchor", 0)) &&
        jsopencv_to_safe(jsobj_normalize, normalize, ArgInfo("normalize", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)))
    {
        ERRWRAP2_NAPI(info, cv::boxFilter(src, dst, ddepth, ksize, anchor, normalize, borderType));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_ddepth = NULL;
    int ddepth=0;
    Napi::Value* jsobj_ksize = NULL;
    Size ksize;
    Napi::Value* jsobj_anchor = NULL;
    Point anchor=Point(-1,-1);
    Napi::Value* jsobj_normalize = NULL;
    bool normalize=true;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_DEFAULT;

    const char* keywords[] = { "src", "ddepth", "ksize", "dst", "anchor", "normalize", "borderType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOOO:boxFilter", (char**)keywords, &jsobj_src, &jsobj_ddepth, &jsobj_ksize, &jsobj_dst, &jsobj_anchor, &jsobj_normalize, &jsobj_borderType) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_ddepth, ddepth, ArgInfo("ddepth", 0)) &&
        jsopencv_to_safe(jsobj_ksize, ksize, ArgInfo("ksize", 0)) &&
        jsopencv_to_safe(jsobj_anchor, anchor, ArgInfo("anchor", 0)) &&
        jsopencv_to_safe(jsobj_normalize, normalize, ArgInfo("normalize", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)))
    {
        ERRWRAP2_NAPI(info, cv::boxFilter(src, dst, ddepth, ksize, anchor, normalize, borderType));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "boxFilter");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_boxPoints(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_box = NULL;
    RotatedRect box;
    Napi::Value* jsobj_points = NULL;
    Mat points;

    const char* keywords[] = { "box", "points", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:boxPoints", (char**)keywords, &jsobj_box, &jsobj_points) &&
        jsopencv_to_safe(jsobj_box, box, ArgInfo("box", 0)) &&
        jsopencv_to_safe(jsobj_points, points, ArgInfo("points", 1)))
    {
        ERRWRAP2_NAPI(info, cv::boxPoints(box, points));
        return jsopencv_from(info, points);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_box = NULL;
    RotatedRect box;
    Napi::Value* jsobj_points = NULL;
    UMat points;

    const char* keywords[] = { "box", "points", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:boxPoints", (char**)keywords, &jsobj_box, &jsobj_points) &&
        jsopencv_to_safe(jsobj_box, box, ArgInfo("box", 0)) &&
        jsopencv_to_safe(jsobj_points, points, ArgInfo("points", 1)))
    {
        ERRWRAP2_NAPI(info, cv::boxPoints(box, points));
        return jsopencv_from(info, points);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "boxPoints");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_buildOpticalFlowPyramid(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_img = NULL;
    Mat img;
    Napi::Value* jsobj_pyramid = NULL;
    vector_Mat pyramid;
    Napi::Value* jsobj_winSize = NULL;
    Size winSize;
    Napi::Value* jsobj_maxLevel = NULL;
    int maxLevel=0;
    Napi::Value* jsobj_withDerivatives = NULL;
    bool withDerivatives=true;
    Napi::Value* jsobj_pyrBorder = NULL;
    int pyrBorder=BORDER_REFLECT_101;
    Napi::Value* jsobj_derivBorder = NULL;
    int derivBorder=BORDER_CONSTANT;
    Napi::Value* jsobj_tryReuseInputImage = NULL;
    bool tryReuseInputImage=true;
    int retval;

    const char* keywords[] = { "img", "winSize", "maxLevel", "pyramid", "withDerivatives", "pyrBorder", "derivBorder", "tryReuseInputImage", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOOOO:buildOpticalFlowPyramid", (char**)keywords, &jsobj_img, &jsobj_winSize, &jsobj_maxLevel, &jsobj_pyramid, &jsobj_withDerivatives, &jsobj_pyrBorder, &jsobj_derivBorder, &jsobj_tryReuseInputImage) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 0)) &&
        jsopencv_to_safe(jsobj_pyramid, pyramid, ArgInfo("pyramid", 1)) &&
        jsopencv_to_safe(jsobj_winSize, winSize, ArgInfo("winSize", 0)) &&
        jsopencv_to_safe(jsobj_maxLevel, maxLevel, ArgInfo("maxLevel", 0)) &&
        jsopencv_to_safe(jsobj_withDerivatives, withDerivatives, ArgInfo("withDerivatives", 0)) &&
        jsopencv_to_safe(jsobj_pyrBorder, pyrBorder, ArgInfo("pyrBorder", 0)) &&
        jsopencv_to_safe(jsobj_derivBorder, derivBorder, ArgInfo("derivBorder", 0)) &&
        jsopencv_to_safe(jsobj_tryReuseInputImage, tryReuseInputImage, ArgInfo("tryReuseInputImage", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::buildOpticalFlowPyramid(img, pyramid, winSize, maxLevel, withDerivatives, pyrBorder, derivBorder, tryReuseInputImage));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, pyramid));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_img = NULL;
    UMat img;
    Napi::Value* jsobj_pyramid = NULL;
    vector_UMat pyramid;
    Napi::Value* jsobj_winSize = NULL;
    Size winSize;
    Napi::Value* jsobj_maxLevel = NULL;
    int maxLevel=0;
    Napi::Value* jsobj_withDerivatives = NULL;
    bool withDerivatives=true;
    Napi::Value* jsobj_pyrBorder = NULL;
    int pyrBorder=BORDER_REFLECT_101;
    Napi::Value* jsobj_derivBorder = NULL;
    int derivBorder=BORDER_CONSTANT;
    Napi::Value* jsobj_tryReuseInputImage = NULL;
    bool tryReuseInputImage=true;
    int retval;

    const char* keywords[] = { "img", "winSize", "maxLevel", "pyramid", "withDerivatives", "pyrBorder", "derivBorder", "tryReuseInputImage", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOOOO:buildOpticalFlowPyramid", (char**)keywords, &jsobj_img, &jsobj_winSize, &jsobj_maxLevel, &jsobj_pyramid, &jsobj_withDerivatives, &jsobj_pyrBorder, &jsobj_derivBorder, &jsobj_tryReuseInputImage) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 0)) &&
        jsopencv_to_safe(jsobj_pyramid, pyramid, ArgInfo("pyramid", 1)) &&
        jsopencv_to_safe(jsobj_winSize, winSize, ArgInfo("winSize", 0)) &&
        jsopencv_to_safe(jsobj_maxLevel, maxLevel, ArgInfo("maxLevel", 0)) &&
        jsopencv_to_safe(jsobj_withDerivatives, withDerivatives, ArgInfo("withDerivatives", 0)) &&
        jsopencv_to_safe(jsobj_pyrBorder, pyrBorder, ArgInfo("pyrBorder", 0)) &&
        jsopencv_to_safe(jsobj_derivBorder, derivBorder, ArgInfo("derivBorder", 0)) &&
        jsopencv_to_safe(jsobj_tryReuseInputImage, tryReuseInputImage, ArgInfo("tryReuseInputImage", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::buildOpticalFlowPyramid(img, pyramid, winSize, maxLevel, withDerivatives, pyrBorder, derivBorder, tryReuseInputImage));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, pyramid));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "buildOpticalFlowPyramid");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_calcBackProject(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_images = NULL;
    vector_Mat images;
    Napi::Value* jsobj_channels = NULL;
    vector_int channels;
    Napi::Value* jsobj_hist = NULL;
    Mat hist;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_ranges = NULL;
    vector_float ranges;
    Napi::Value* jsobj_scale = NULL;
    double scale=0;

    const char* keywords[] = { "images", "channels", "hist", "ranges", "scale", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOO|O:calcBackProject", (char**)keywords, &jsobj_images, &jsobj_channels, &jsobj_hist, &jsobj_ranges, &jsobj_scale, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_images, images, ArgInfo("images", 0)) &&
        jsopencv_to_safe(jsobj_channels, channels, ArgInfo("channels", 0)) &&
        jsopencv_to_safe(jsobj_hist, hist, ArgInfo("hist", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_ranges, ranges, ArgInfo("ranges", 0)) &&
        jsopencv_to_safe(jsobj_scale, scale, ArgInfo("scale", 0)))
    {
        ERRWRAP2_NAPI(info, cv::calcBackProject(images, channels, hist, dst, ranges, scale));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_images = NULL;
    vector_UMat images;
    Napi::Value* jsobj_channels = NULL;
    vector_int channels;
    Napi::Value* jsobj_hist = NULL;
    UMat hist;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_ranges = NULL;
    vector_float ranges;
    Napi::Value* jsobj_scale = NULL;
    double scale=0;

    const char* keywords[] = { "images", "channels", "hist", "ranges", "scale", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOO|O:calcBackProject", (char**)keywords, &jsobj_images, &jsobj_channels, &jsobj_hist, &jsobj_ranges, &jsobj_scale, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_images, images, ArgInfo("images", 0)) &&
        jsopencv_to_safe(jsobj_channels, channels, ArgInfo("channels", 0)) &&
        jsopencv_to_safe(jsobj_hist, hist, ArgInfo("hist", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_ranges, ranges, ArgInfo("ranges", 0)) &&
        jsopencv_to_safe(jsobj_scale, scale, ArgInfo("scale", 0)))
    {
        ERRWRAP2_NAPI(info, cv::calcBackProject(images, channels, hist, dst, ranges, scale));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "calcBackProject");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_calcCovarMatrix(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_samples = NULL;
    Mat samples;
    Napi::Value* jsobj_covar = NULL;
    Mat covar;
    Napi::Value* jsobj_mean = NULL;
    Mat mean;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;
    Napi::Value* jsobj_ctype = NULL;
    int ctype=CV_64F;

    const char* keywords[] = { "samples", "mean", "flags", "covar", "ctype", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OO:calcCovarMatrix", (char**)keywords, &jsobj_samples, &jsobj_mean, &jsobj_flags, &jsobj_covar, &jsobj_ctype) &&
        jsopencv_to_safe(jsobj_samples, samples, ArgInfo("samples", 0)) &&
        jsopencv_to_safe(jsobj_covar, covar, ArgInfo("covar", 1)) &&
        jsopencv_to_safe(jsobj_mean, mean, ArgInfo("mean", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_ctype, ctype, ArgInfo("ctype", 0)))
    {
        ERRWRAP2_NAPI(info, cv::calcCovarMatrix(samples, covar, mean, flags, ctype));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, covar), jsopencv_from(info, mean));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_samples = NULL;
    UMat samples;
    Napi::Value* jsobj_covar = NULL;
    UMat covar;
    Napi::Value* jsobj_mean = NULL;
    UMat mean;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;
    Napi::Value* jsobj_ctype = NULL;
    int ctype=CV_64F;

    const char* keywords[] = { "samples", "mean", "flags", "covar", "ctype", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OO:calcCovarMatrix", (char**)keywords, &jsobj_samples, &jsobj_mean, &jsobj_flags, &jsobj_covar, &jsobj_ctype) &&
        jsopencv_to_safe(jsobj_samples, samples, ArgInfo("samples", 0)) &&
        jsopencv_to_safe(jsobj_covar, covar, ArgInfo("covar", 1)) &&
        jsopencv_to_safe(jsobj_mean, mean, ArgInfo("mean", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_ctype, ctype, ArgInfo("ctype", 0)))
    {
        ERRWRAP2_NAPI(info, cv::calcCovarMatrix(samples, covar, mean, flags, ctype));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, covar), jsopencv_from(info, mean));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "calcCovarMatrix");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_calcHist(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_images = NULL;
    vector_Mat images;
    Napi::Value* jsobj_channels = NULL;
    vector_int channels;
    Napi::Value* jsobj_mask = NULL;
    Mat mask;
    Napi::Value* jsobj_hist = NULL;
    Mat hist;
    Napi::Value* jsobj_histSize = NULL;
    vector_int histSize;
    Napi::Value* jsobj_ranges = NULL;
    vector_float ranges;
    Napi::Value* jsobj_accumulate = NULL;
    bool accumulate=false;

    const char* keywords[] = { "images", "channels", "mask", "histSize", "ranges", "hist", "accumulate", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOO|OO:calcHist", (char**)keywords, &jsobj_images, &jsobj_channels, &jsobj_mask, &jsobj_histSize, &jsobj_ranges, &jsobj_hist, &jsobj_accumulate) &&
        jsopencv_to_safe(jsobj_images, images, ArgInfo("images", 0)) &&
        jsopencv_to_safe(jsobj_channels, channels, ArgInfo("channels", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)) &&
        jsopencv_to_safe(jsobj_hist, hist, ArgInfo("hist", 1)) &&
        jsopencv_to_safe(jsobj_histSize, histSize, ArgInfo("histSize", 0)) &&
        jsopencv_to_safe(jsobj_ranges, ranges, ArgInfo("ranges", 0)) &&
        jsopencv_to_safe(jsobj_accumulate, accumulate, ArgInfo("accumulate", 0)))
    {
        ERRWRAP2_NAPI(info, cv::calcHist(images, channels, mask, hist, histSize, ranges, accumulate));
        return jsopencv_from(info, hist);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_images = NULL;
    vector_UMat images;
    Napi::Value* jsobj_channels = NULL;
    vector_int channels;
    Napi::Value* jsobj_mask = NULL;
    UMat mask;
    Napi::Value* jsobj_hist = NULL;
    UMat hist;
    Napi::Value* jsobj_histSize = NULL;
    vector_int histSize;
    Napi::Value* jsobj_ranges = NULL;
    vector_float ranges;
    Napi::Value* jsobj_accumulate = NULL;
    bool accumulate=false;

    const char* keywords[] = { "images", "channels", "mask", "histSize", "ranges", "hist", "accumulate", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOO|OO:calcHist", (char**)keywords, &jsobj_images, &jsobj_channels, &jsobj_mask, &jsobj_histSize, &jsobj_ranges, &jsobj_hist, &jsobj_accumulate) &&
        jsopencv_to_safe(jsobj_images, images, ArgInfo("images", 0)) &&
        jsopencv_to_safe(jsobj_channels, channels, ArgInfo("channels", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)) &&
        jsopencv_to_safe(jsobj_hist, hist, ArgInfo("hist", 1)) &&
        jsopencv_to_safe(jsobj_histSize, histSize, ArgInfo("histSize", 0)) &&
        jsopencv_to_safe(jsobj_ranges, ranges, ArgInfo("ranges", 0)) &&
        jsopencv_to_safe(jsobj_accumulate, accumulate, ArgInfo("accumulate", 0)))
    {
        ERRWRAP2_NAPI(info, cv::calcHist(images, channels, mask, hist, histSize, ranges, accumulate));
        return jsopencv_from(info, hist);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "calcHist");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_calcOpticalFlowFarneback(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_prev = NULL;
    Mat prev;
    Napi::Value* jsobj_next = NULL;
    Mat next;
    Napi::Value* jsobj_flow = NULL;
    Mat flow;
    Napi::Value* jsobj_pyr_scale = NULL;
    double pyr_scale=0;
    Napi::Value* jsobj_levels = NULL;
    int levels=0;
    Napi::Value* jsobj_winsize = NULL;
    int winsize=0;
    Napi::Value* jsobj_iterations = NULL;
    int iterations=0;
    Napi::Value* jsobj_poly_n = NULL;
    int poly_n=0;
    Napi::Value* jsobj_poly_sigma = NULL;
    double poly_sigma=0;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;

    const char* keywords[] = { "prev", "next", "flow", "pyr_scale", "levels", "winsize", "iterations", "poly_n", "poly_sigma", "flags", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOOOOOO:calcOpticalFlowFarneback", (char**)keywords, &jsobj_prev, &jsobj_next, &jsobj_flow, &jsobj_pyr_scale, &jsobj_levels, &jsobj_winsize, &jsobj_iterations, &jsobj_poly_n, &jsobj_poly_sigma, &jsobj_flags) &&
        jsopencv_to_safe(jsobj_prev, prev, ArgInfo("prev", 0)) &&
        jsopencv_to_safe(jsobj_next, next, ArgInfo("next", 0)) &&
        jsopencv_to_safe(jsobj_flow, flow, ArgInfo("flow", 1)) &&
        jsopencv_to_safe(jsobj_pyr_scale, pyr_scale, ArgInfo("pyr_scale", 0)) &&
        jsopencv_to_safe(jsobj_levels, levels, ArgInfo("levels", 0)) &&
        jsopencv_to_safe(jsobj_winsize, winsize, ArgInfo("winsize", 0)) &&
        jsopencv_to_safe(jsobj_iterations, iterations, ArgInfo("iterations", 0)) &&
        jsopencv_to_safe(jsobj_poly_n, poly_n, ArgInfo("poly_n", 0)) &&
        jsopencv_to_safe(jsobj_poly_sigma, poly_sigma, ArgInfo("poly_sigma", 0)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, cv::calcOpticalFlowFarneback(prev, next, flow, pyr_scale, levels, winsize, iterations, poly_n, poly_sigma, flags));
        return jsopencv_from(info, flow);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_prev = NULL;
    UMat prev;
    Napi::Value* jsobj_next = NULL;
    UMat next;
    Napi::Value* jsobj_flow = NULL;
    UMat flow;
    Napi::Value* jsobj_pyr_scale = NULL;
    double pyr_scale=0;
    Napi::Value* jsobj_levels = NULL;
    int levels=0;
    Napi::Value* jsobj_winsize = NULL;
    int winsize=0;
    Napi::Value* jsobj_iterations = NULL;
    int iterations=0;
    Napi::Value* jsobj_poly_n = NULL;
    int poly_n=0;
    Napi::Value* jsobj_poly_sigma = NULL;
    double poly_sigma=0;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;

    const char* keywords[] = { "prev", "next", "flow", "pyr_scale", "levels", "winsize", "iterations", "poly_n", "poly_sigma", "flags", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOOOOOO:calcOpticalFlowFarneback", (char**)keywords, &jsobj_prev, &jsobj_next, &jsobj_flow, &jsobj_pyr_scale, &jsobj_levels, &jsobj_winsize, &jsobj_iterations, &jsobj_poly_n, &jsobj_poly_sigma, &jsobj_flags) &&
        jsopencv_to_safe(jsobj_prev, prev, ArgInfo("prev", 0)) &&
        jsopencv_to_safe(jsobj_next, next, ArgInfo("next", 0)) &&
        jsopencv_to_safe(jsobj_flow, flow, ArgInfo("flow", 1)) &&
        jsopencv_to_safe(jsobj_pyr_scale, pyr_scale, ArgInfo("pyr_scale", 0)) &&
        jsopencv_to_safe(jsobj_levels, levels, ArgInfo("levels", 0)) &&
        jsopencv_to_safe(jsobj_winsize, winsize, ArgInfo("winsize", 0)) &&
        jsopencv_to_safe(jsobj_iterations, iterations, ArgInfo("iterations", 0)) &&
        jsopencv_to_safe(jsobj_poly_n, poly_n, ArgInfo("poly_n", 0)) &&
        jsopencv_to_safe(jsobj_poly_sigma, poly_sigma, ArgInfo("poly_sigma", 0)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, cv::calcOpticalFlowFarneback(prev, next, flow, pyr_scale, levels, winsize, iterations, poly_n, poly_sigma, flags));
        return jsopencv_from(info, flow);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "calcOpticalFlowFarneback");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_calcOpticalFlowPyrLK(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_prevImg = NULL;
    Mat prevImg;
    Napi::Value* jsobj_nextImg = NULL;
    Mat nextImg;
    Napi::Value* jsobj_prevPts = NULL;
    Mat prevPts;
    Napi::Value* jsobj_nextPts = NULL;
    Mat nextPts;
    Napi::Value* jsobj_status = NULL;
    Mat status;
    Napi::Value* jsobj_err = NULL;
    Mat err;
    Napi::Value* jsobj_winSize = NULL;
    Size winSize=Size(21,21);
    Napi::Value* jsobj_maxLevel = NULL;
    int maxLevel=3;
    Napi::Value* jsobj_criteria = NULL;
    TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 0.01);
    Napi::Value* jsobj_flags = NULL;
    int flags=0;
    Napi::Value* jsobj_minEigThreshold = NULL;
    double minEigThreshold=1e-4;

    const char* keywords[] = { "prevImg", "nextImg", "prevPts", "nextPts", "status", "err", "winSize", "maxLevel", "criteria", "flags", "minEigThreshold", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOOOOOO:calcOpticalFlowPyrLK", (char**)keywords, &jsobj_prevImg, &jsobj_nextImg, &jsobj_prevPts, &jsobj_nextPts, &jsobj_status, &jsobj_err, &jsobj_winSize, &jsobj_maxLevel, &jsobj_criteria, &jsobj_flags, &jsobj_minEigThreshold) &&
        jsopencv_to_safe(jsobj_prevImg, prevImg, ArgInfo("prevImg", 0)) &&
        jsopencv_to_safe(jsobj_nextImg, nextImg, ArgInfo("nextImg", 0)) &&
        jsopencv_to_safe(jsobj_prevPts, prevPts, ArgInfo("prevPts", 0)) &&
        jsopencv_to_safe(jsobj_nextPts, nextPts, ArgInfo("nextPts", 1)) &&
        jsopencv_to_safe(jsobj_status, status, ArgInfo("status", 1)) &&
        jsopencv_to_safe(jsobj_err, err, ArgInfo("err", 1)) &&
        jsopencv_to_safe(jsobj_winSize, winSize, ArgInfo("winSize", 0)) &&
        jsopencv_to_safe(jsobj_maxLevel, maxLevel, ArgInfo("maxLevel", 0)) &&
        jsopencv_to_safe(jsobj_criteria, criteria, ArgInfo("criteria", 0)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_minEigThreshold, minEigThreshold, ArgInfo("minEigThreshold", 0)))
    {
        ERRWRAP2_NAPI(info, cv::calcOpticalFlowPyrLK(prevImg, nextImg, prevPts, nextPts, status, err, winSize, maxLevel, criteria, flags, minEigThreshold));
        return Js_BuildValue(info, "(NNN)", jsopencv_from(info, nextPts), jsopencv_from(info, status), jsopencv_from(info, err));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_prevImg = NULL;
    UMat prevImg;
    Napi::Value* jsobj_nextImg = NULL;
    UMat nextImg;
    Napi::Value* jsobj_prevPts = NULL;
    UMat prevPts;
    Napi::Value* jsobj_nextPts = NULL;
    UMat nextPts;
    Napi::Value* jsobj_status = NULL;
    UMat status;
    Napi::Value* jsobj_err = NULL;
    UMat err;
    Napi::Value* jsobj_winSize = NULL;
    Size winSize=Size(21,21);
    Napi::Value* jsobj_maxLevel = NULL;
    int maxLevel=3;
    Napi::Value* jsobj_criteria = NULL;
    TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 0.01);
    Napi::Value* jsobj_flags = NULL;
    int flags=0;
    Napi::Value* jsobj_minEigThreshold = NULL;
    double minEigThreshold=1e-4;

    const char* keywords[] = { "prevImg", "nextImg", "prevPts", "nextPts", "status", "err", "winSize", "maxLevel", "criteria", "flags", "minEigThreshold", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOOOOOO:calcOpticalFlowPyrLK", (char**)keywords, &jsobj_prevImg, &jsobj_nextImg, &jsobj_prevPts, &jsobj_nextPts, &jsobj_status, &jsobj_err, &jsobj_winSize, &jsobj_maxLevel, &jsobj_criteria, &jsobj_flags, &jsobj_minEigThreshold) &&
        jsopencv_to_safe(jsobj_prevImg, prevImg, ArgInfo("prevImg", 0)) &&
        jsopencv_to_safe(jsobj_nextImg, nextImg, ArgInfo("nextImg", 0)) &&
        jsopencv_to_safe(jsobj_prevPts, prevPts, ArgInfo("prevPts", 0)) &&
        jsopencv_to_safe(jsobj_nextPts, nextPts, ArgInfo("nextPts", 1)) &&
        jsopencv_to_safe(jsobj_status, status, ArgInfo("status", 1)) &&
        jsopencv_to_safe(jsobj_err, err, ArgInfo("err", 1)) &&
        jsopencv_to_safe(jsobj_winSize, winSize, ArgInfo("winSize", 0)) &&
        jsopencv_to_safe(jsobj_maxLevel, maxLevel, ArgInfo("maxLevel", 0)) &&
        jsopencv_to_safe(jsobj_criteria, criteria, ArgInfo("criteria", 0)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_minEigThreshold, minEigThreshold, ArgInfo("minEigThreshold", 0)))
    {
        ERRWRAP2_NAPI(info, cv::calcOpticalFlowPyrLK(prevImg, nextImg, prevPts, nextPts, status, err, winSize, maxLevel, criteria, flags, minEigThreshold));
        return Js_BuildValue(info, "(NNN)", jsopencv_from(info, nextPts), jsopencv_from(info, status), jsopencv_from(info, err));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "calcOpticalFlowPyrLK");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_calibrateCamera(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_objectPoints = NULL;
    vector_Mat objectPoints;
    Napi::Value* jsobj_imagePoints = NULL;
    vector_Mat imagePoints;
    Napi::Value* jsobj_imageSize = NULL;
    Size imageSize;
    Napi::Value* jsobj_cameraMatrix = NULL;
    Mat cameraMatrix;
    Napi::Value* jsobj_distCoeffs = NULL;
    Mat distCoeffs;
    Napi::Value* jsobj_rvecs = NULL;
    vector_Mat rvecs;
    Napi::Value* jsobj_tvecs = NULL;
    vector_Mat tvecs;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;
    Napi::Value* jsobj_criteria = NULL;
    TermCriteria criteria=TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON);
    double retval;

    const char* keywords[] = { "objectPoints", "imagePoints", "imageSize", "cameraMatrix", "distCoeffs", "rvecs", "tvecs", "flags", "criteria", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOO|OOOO:calibrateCamera", (char**)keywords, &jsobj_objectPoints, &jsobj_imagePoints, &jsobj_imageSize, &jsobj_cameraMatrix, &jsobj_distCoeffs, &jsobj_rvecs, &jsobj_tvecs, &jsobj_flags, &jsobj_criteria) &&
        jsopencv_to_safe(jsobj_objectPoints, objectPoints, ArgInfo("objectPoints", 0)) &&
        jsopencv_to_safe(jsobj_imagePoints, imagePoints, ArgInfo("imagePoints", 0)) &&
        jsopencv_to_safe(jsobj_imageSize, imageSize, ArgInfo("imageSize", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 1)) &&
        jsopencv_to_safe(jsobj_distCoeffs, distCoeffs, ArgInfo("distCoeffs", 1)) &&
        jsopencv_to_safe(jsobj_rvecs, rvecs, ArgInfo("rvecs", 1)) &&
        jsopencv_to_safe(jsobj_tvecs, tvecs, ArgInfo("tvecs", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_criteria, criteria, ArgInfo("criteria", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::calibrateCamera(objectPoints, imagePoints, imageSize, cameraMatrix, distCoeffs, rvecs, tvecs, flags, criteria));
        return Js_BuildValue(info, "(NNNNN)", jsopencv_from(info, retval), jsopencv_from(info, cameraMatrix), jsopencv_from(info, distCoeffs), jsopencv_from(info, rvecs), jsopencv_from(info, tvecs));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_objectPoints = NULL;
    vector_UMat objectPoints;
    Napi::Value* jsobj_imagePoints = NULL;
    vector_UMat imagePoints;
    Napi::Value* jsobj_imageSize = NULL;
    Size imageSize;
    Napi::Value* jsobj_cameraMatrix = NULL;
    UMat cameraMatrix;
    Napi::Value* jsobj_distCoeffs = NULL;
    UMat distCoeffs;
    Napi::Value* jsobj_rvecs = NULL;
    vector_UMat rvecs;
    Napi::Value* jsobj_tvecs = NULL;
    vector_UMat tvecs;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;
    Napi::Value* jsobj_criteria = NULL;
    TermCriteria criteria=TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON);
    double retval;

    const char* keywords[] = { "objectPoints", "imagePoints", "imageSize", "cameraMatrix", "distCoeffs", "rvecs", "tvecs", "flags", "criteria", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOO|OOOO:calibrateCamera", (char**)keywords, &jsobj_objectPoints, &jsobj_imagePoints, &jsobj_imageSize, &jsobj_cameraMatrix, &jsobj_distCoeffs, &jsobj_rvecs, &jsobj_tvecs, &jsobj_flags, &jsobj_criteria) &&
        jsopencv_to_safe(jsobj_objectPoints, objectPoints, ArgInfo("objectPoints", 0)) &&
        jsopencv_to_safe(jsobj_imagePoints, imagePoints, ArgInfo("imagePoints", 0)) &&
        jsopencv_to_safe(jsobj_imageSize, imageSize, ArgInfo("imageSize", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 1)) &&
        jsopencv_to_safe(jsobj_distCoeffs, distCoeffs, ArgInfo("distCoeffs", 1)) &&
        jsopencv_to_safe(jsobj_rvecs, rvecs, ArgInfo("rvecs", 1)) &&
        jsopencv_to_safe(jsobj_tvecs, tvecs, ArgInfo("tvecs", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_criteria, criteria, ArgInfo("criteria", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::calibrateCamera(objectPoints, imagePoints, imageSize, cameraMatrix, distCoeffs, rvecs, tvecs, flags, criteria));
        return Js_BuildValue(info, "(NNNNN)", jsopencv_from(info, retval), jsopencv_from(info, cameraMatrix), jsopencv_from(info, distCoeffs), jsopencv_from(info, rvecs), jsopencv_from(info, tvecs));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "calibrateCamera");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_calibrateCameraExtended(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_objectPoints = NULL;
    vector_Mat objectPoints;
    Napi::Value* jsobj_imagePoints = NULL;
    vector_Mat imagePoints;
    Napi::Value* jsobj_imageSize = NULL;
    Size imageSize;
    Napi::Value* jsobj_cameraMatrix = NULL;
    Mat cameraMatrix;
    Napi::Value* jsobj_distCoeffs = NULL;
    Mat distCoeffs;
    Napi::Value* jsobj_rvecs = NULL;
    vector_Mat rvecs;
    Napi::Value* jsobj_tvecs = NULL;
    vector_Mat tvecs;
    Napi::Value* jsobj_stdDeviationsIntrinsics = NULL;
    Mat stdDeviationsIntrinsics;
    Napi::Value* jsobj_stdDeviationsExtrinsics = NULL;
    Mat stdDeviationsExtrinsics;
    Napi::Value* jsobj_perViewErrors = NULL;
    Mat perViewErrors;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;
    Napi::Value* jsobj_criteria = NULL;
    TermCriteria criteria=TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON);
    double retval;

    const char* keywords[] = { "objectPoints", "imagePoints", "imageSize", "cameraMatrix", "distCoeffs", "rvecs", "tvecs", "stdDeviationsIntrinsics", "stdDeviationsExtrinsics", "perViewErrors", "flags", "criteria", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOO|OOOOOOO:calibrateCameraExtended", (char**)keywords, &jsobj_objectPoints, &jsobj_imagePoints, &jsobj_imageSize, &jsobj_cameraMatrix, &jsobj_distCoeffs, &jsobj_rvecs, &jsobj_tvecs, &jsobj_stdDeviationsIntrinsics, &jsobj_stdDeviationsExtrinsics, &jsobj_perViewErrors, &jsobj_flags, &jsobj_criteria) &&
        jsopencv_to_safe(jsobj_objectPoints, objectPoints, ArgInfo("objectPoints", 0)) &&
        jsopencv_to_safe(jsobj_imagePoints, imagePoints, ArgInfo("imagePoints", 0)) &&
        jsopencv_to_safe(jsobj_imageSize, imageSize, ArgInfo("imageSize", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 1)) &&
        jsopencv_to_safe(jsobj_distCoeffs, distCoeffs, ArgInfo("distCoeffs", 1)) &&
        jsopencv_to_safe(jsobj_rvecs, rvecs, ArgInfo("rvecs", 1)) &&
        jsopencv_to_safe(jsobj_tvecs, tvecs, ArgInfo("tvecs", 1)) &&
        jsopencv_to_safe(jsobj_stdDeviationsIntrinsics, stdDeviationsIntrinsics, ArgInfo("stdDeviationsIntrinsics", 1)) &&
        jsopencv_to_safe(jsobj_stdDeviationsExtrinsics, stdDeviationsExtrinsics, ArgInfo("stdDeviationsExtrinsics", 1)) &&
        jsopencv_to_safe(jsobj_perViewErrors, perViewErrors, ArgInfo("perViewErrors", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_criteria, criteria, ArgInfo("criteria", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::calibrateCamera(objectPoints, imagePoints, imageSize, cameraMatrix, distCoeffs, rvecs, tvecs, stdDeviationsIntrinsics, stdDeviationsExtrinsics, perViewErrors, flags, criteria));
        return Js_BuildValue(info, "(NNNNNNNN)", jsopencv_from(info, retval), jsopencv_from(info, cameraMatrix), jsopencv_from(info, distCoeffs), jsopencv_from(info, rvecs), jsopencv_from(info, tvecs), jsopencv_from(info, stdDeviationsIntrinsics), jsopencv_from(info, stdDeviationsExtrinsics), jsopencv_from(info, perViewErrors));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_objectPoints = NULL;
    vector_UMat objectPoints;
    Napi::Value* jsobj_imagePoints = NULL;
    vector_UMat imagePoints;
    Napi::Value* jsobj_imageSize = NULL;
    Size imageSize;
    Napi::Value* jsobj_cameraMatrix = NULL;
    UMat cameraMatrix;
    Napi::Value* jsobj_distCoeffs = NULL;
    UMat distCoeffs;
    Napi::Value* jsobj_rvecs = NULL;
    vector_UMat rvecs;
    Napi::Value* jsobj_tvecs = NULL;
    vector_UMat tvecs;
    Napi::Value* jsobj_stdDeviationsIntrinsics = NULL;
    UMat stdDeviationsIntrinsics;
    Napi::Value* jsobj_stdDeviationsExtrinsics = NULL;
    UMat stdDeviationsExtrinsics;
    Napi::Value* jsobj_perViewErrors = NULL;
    UMat perViewErrors;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;
    Napi::Value* jsobj_criteria = NULL;
    TermCriteria criteria=TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON);
    double retval;

    const char* keywords[] = { "objectPoints", "imagePoints", "imageSize", "cameraMatrix", "distCoeffs", "rvecs", "tvecs", "stdDeviationsIntrinsics", "stdDeviationsExtrinsics", "perViewErrors", "flags", "criteria", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOO|OOOOOOO:calibrateCameraExtended", (char**)keywords, &jsobj_objectPoints, &jsobj_imagePoints, &jsobj_imageSize, &jsobj_cameraMatrix, &jsobj_distCoeffs, &jsobj_rvecs, &jsobj_tvecs, &jsobj_stdDeviationsIntrinsics, &jsobj_stdDeviationsExtrinsics, &jsobj_perViewErrors, &jsobj_flags, &jsobj_criteria) &&
        jsopencv_to_safe(jsobj_objectPoints, objectPoints, ArgInfo("objectPoints", 0)) &&
        jsopencv_to_safe(jsobj_imagePoints, imagePoints, ArgInfo("imagePoints", 0)) &&
        jsopencv_to_safe(jsobj_imageSize, imageSize, ArgInfo("imageSize", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 1)) &&
        jsopencv_to_safe(jsobj_distCoeffs, distCoeffs, ArgInfo("distCoeffs", 1)) &&
        jsopencv_to_safe(jsobj_rvecs, rvecs, ArgInfo("rvecs", 1)) &&
        jsopencv_to_safe(jsobj_tvecs, tvecs, ArgInfo("tvecs", 1)) &&
        jsopencv_to_safe(jsobj_stdDeviationsIntrinsics, stdDeviationsIntrinsics, ArgInfo("stdDeviationsIntrinsics", 1)) &&
        jsopencv_to_safe(jsobj_stdDeviationsExtrinsics, stdDeviationsExtrinsics, ArgInfo("stdDeviationsExtrinsics", 1)) &&
        jsopencv_to_safe(jsobj_perViewErrors, perViewErrors, ArgInfo("perViewErrors", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_criteria, criteria, ArgInfo("criteria", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::calibrateCamera(objectPoints, imagePoints, imageSize, cameraMatrix, distCoeffs, rvecs, tvecs, stdDeviationsIntrinsics, stdDeviationsExtrinsics, perViewErrors, flags, criteria));
        return Js_BuildValue(info, "(NNNNNNNN)", jsopencv_from(info, retval), jsopencv_from(info, cameraMatrix), jsopencv_from(info, distCoeffs), jsopencv_from(info, rvecs), jsopencv_from(info, tvecs), jsopencv_from(info, stdDeviationsIntrinsics), jsopencv_from(info, stdDeviationsExtrinsics), jsopencv_from(info, perViewErrors));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "calibrateCameraExtended");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_calibrateCameraRO(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_objectPoints = NULL;
    vector_Mat objectPoints;
    Napi::Value* jsobj_imagePoints = NULL;
    vector_Mat imagePoints;
    Napi::Value* jsobj_imageSize = NULL;
    Size imageSize;
    Napi::Value* jsobj_iFixedPoint = NULL;
    int iFixedPoint=0;
    Napi::Value* jsobj_cameraMatrix = NULL;
    Mat cameraMatrix;
    Napi::Value* jsobj_distCoeffs = NULL;
    Mat distCoeffs;
    Napi::Value* jsobj_rvecs = NULL;
    vector_Mat rvecs;
    Napi::Value* jsobj_tvecs = NULL;
    vector_Mat tvecs;
    Napi::Value* jsobj_newObjPoints = NULL;
    Mat newObjPoints;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;
    Napi::Value* jsobj_criteria = NULL;
    TermCriteria criteria=TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON);
    double retval;

    const char* keywords[] = { "objectPoints", "imagePoints", "imageSize", "iFixedPoint", "cameraMatrix", "distCoeffs", "rvecs", "tvecs", "newObjPoints", "flags", "criteria", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOO|OOOOO:calibrateCameraRO", (char**)keywords, &jsobj_objectPoints, &jsobj_imagePoints, &jsobj_imageSize, &jsobj_iFixedPoint, &jsobj_cameraMatrix, &jsobj_distCoeffs, &jsobj_rvecs, &jsobj_tvecs, &jsobj_newObjPoints, &jsobj_flags, &jsobj_criteria) &&
        jsopencv_to_safe(jsobj_objectPoints, objectPoints, ArgInfo("objectPoints", 0)) &&
        jsopencv_to_safe(jsobj_imagePoints, imagePoints, ArgInfo("imagePoints", 0)) &&
        jsopencv_to_safe(jsobj_imageSize, imageSize, ArgInfo("imageSize", 0)) &&
        jsopencv_to_safe(jsobj_iFixedPoint, iFixedPoint, ArgInfo("iFixedPoint", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 1)) &&
        jsopencv_to_safe(jsobj_distCoeffs, distCoeffs, ArgInfo("distCoeffs", 1)) &&
        jsopencv_to_safe(jsobj_rvecs, rvecs, ArgInfo("rvecs", 1)) &&
        jsopencv_to_safe(jsobj_tvecs, tvecs, ArgInfo("tvecs", 1)) &&
        jsopencv_to_safe(jsobj_newObjPoints, newObjPoints, ArgInfo("newObjPoints", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_criteria, criteria, ArgInfo("criteria", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::calibrateCameraRO(objectPoints, imagePoints, imageSize, iFixedPoint, cameraMatrix, distCoeffs, rvecs, tvecs, newObjPoints, flags, criteria));
        return Js_BuildValue(info, "(NNNNNN)", jsopencv_from(info, retval), jsopencv_from(info, cameraMatrix), jsopencv_from(info, distCoeffs), jsopencv_from(info, rvecs), jsopencv_from(info, tvecs), jsopencv_from(info, newObjPoints));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_objectPoints = NULL;
    vector_UMat objectPoints;
    Napi::Value* jsobj_imagePoints = NULL;
    vector_UMat imagePoints;
    Napi::Value* jsobj_imageSize = NULL;
    Size imageSize;
    Napi::Value* jsobj_iFixedPoint = NULL;
    int iFixedPoint=0;
    Napi::Value* jsobj_cameraMatrix = NULL;
    UMat cameraMatrix;
    Napi::Value* jsobj_distCoeffs = NULL;
    UMat distCoeffs;
    Napi::Value* jsobj_rvecs = NULL;
    vector_UMat rvecs;
    Napi::Value* jsobj_tvecs = NULL;
    vector_UMat tvecs;
    Napi::Value* jsobj_newObjPoints = NULL;
    UMat newObjPoints;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;
    Napi::Value* jsobj_criteria = NULL;
    TermCriteria criteria=TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON);
    double retval;

    const char* keywords[] = { "objectPoints", "imagePoints", "imageSize", "iFixedPoint", "cameraMatrix", "distCoeffs", "rvecs", "tvecs", "newObjPoints", "flags", "criteria", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOO|OOOOO:calibrateCameraRO", (char**)keywords, &jsobj_objectPoints, &jsobj_imagePoints, &jsobj_imageSize, &jsobj_iFixedPoint, &jsobj_cameraMatrix, &jsobj_distCoeffs, &jsobj_rvecs, &jsobj_tvecs, &jsobj_newObjPoints, &jsobj_flags, &jsobj_criteria) &&
        jsopencv_to_safe(jsobj_objectPoints, objectPoints, ArgInfo("objectPoints", 0)) &&
        jsopencv_to_safe(jsobj_imagePoints, imagePoints, ArgInfo("imagePoints", 0)) &&
        jsopencv_to_safe(jsobj_imageSize, imageSize, ArgInfo("imageSize", 0)) &&
        jsopencv_to_safe(jsobj_iFixedPoint, iFixedPoint, ArgInfo("iFixedPoint", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 1)) &&
        jsopencv_to_safe(jsobj_distCoeffs, distCoeffs, ArgInfo("distCoeffs", 1)) &&
        jsopencv_to_safe(jsobj_rvecs, rvecs, ArgInfo("rvecs", 1)) &&
        jsopencv_to_safe(jsobj_tvecs, tvecs, ArgInfo("tvecs", 1)) &&
        jsopencv_to_safe(jsobj_newObjPoints, newObjPoints, ArgInfo("newObjPoints", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_criteria, criteria, ArgInfo("criteria", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::calibrateCameraRO(objectPoints, imagePoints, imageSize, iFixedPoint, cameraMatrix, distCoeffs, rvecs, tvecs, newObjPoints, flags, criteria));
        return Js_BuildValue(info, "(NNNNNN)", jsopencv_from(info, retval), jsopencv_from(info, cameraMatrix), jsopencv_from(info, distCoeffs), jsopencv_from(info, rvecs), jsopencv_from(info, tvecs), jsopencv_from(info, newObjPoints));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "calibrateCameraRO");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_calibrateCameraROExtended(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_objectPoints = NULL;
    vector_Mat objectPoints;
    Napi::Value* jsobj_imagePoints = NULL;
    vector_Mat imagePoints;
    Napi::Value* jsobj_imageSize = NULL;
    Size imageSize;
    Napi::Value* jsobj_iFixedPoint = NULL;
    int iFixedPoint=0;
    Napi::Value* jsobj_cameraMatrix = NULL;
    Mat cameraMatrix;
    Napi::Value* jsobj_distCoeffs = NULL;
    Mat distCoeffs;
    Napi::Value* jsobj_rvecs = NULL;
    vector_Mat rvecs;
    Napi::Value* jsobj_tvecs = NULL;
    vector_Mat tvecs;
    Napi::Value* jsobj_newObjPoints = NULL;
    Mat newObjPoints;
    Napi::Value* jsobj_stdDeviationsIntrinsics = NULL;
    Mat stdDeviationsIntrinsics;
    Napi::Value* jsobj_stdDeviationsExtrinsics = NULL;
    Mat stdDeviationsExtrinsics;
    Napi::Value* jsobj_stdDeviationsObjPoints = NULL;
    Mat stdDeviationsObjPoints;
    Napi::Value* jsobj_perViewErrors = NULL;
    Mat perViewErrors;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;
    Napi::Value* jsobj_criteria = NULL;
    TermCriteria criteria=TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON);
    double retval;

    const char* keywords[] = { "objectPoints", "imagePoints", "imageSize", "iFixedPoint", "cameraMatrix", "distCoeffs", "rvecs", "tvecs", "newObjPoints", "stdDeviationsIntrinsics", "stdDeviationsExtrinsics", "stdDeviationsObjPoints", "perViewErrors", "flags", "criteria", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOO|OOOOOOOOO:calibrateCameraROExtended", (char**)keywords, &jsobj_objectPoints, &jsobj_imagePoints, &jsobj_imageSize, &jsobj_iFixedPoint, &jsobj_cameraMatrix, &jsobj_distCoeffs, &jsobj_rvecs, &jsobj_tvecs, &jsobj_newObjPoints, &jsobj_stdDeviationsIntrinsics, &jsobj_stdDeviationsExtrinsics, &jsobj_stdDeviationsObjPoints, &jsobj_perViewErrors, &jsobj_flags, &jsobj_criteria) &&
        jsopencv_to_safe(jsobj_objectPoints, objectPoints, ArgInfo("objectPoints", 0)) &&
        jsopencv_to_safe(jsobj_imagePoints, imagePoints, ArgInfo("imagePoints", 0)) &&
        jsopencv_to_safe(jsobj_imageSize, imageSize, ArgInfo("imageSize", 0)) &&
        jsopencv_to_safe(jsobj_iFixedPoint, iFixedPoint, ArgInfo("iFixedPoint", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 1)) &&
        jsopencv_to_safe(jsobj_distCoeffs, distCoeffs, ArgInfo("distCoeffs", 1)) &&
        jsopencv_to_safe(jsobj_rvecs, rvecs, ArgInfo("rvecs", 1)) &&
        jsopencv_to_safe(jsobj_tvecs, tvecs, ArgInfo("tvecs", 1)) &&
        jsopencv_to_safe(jsobj_newObjPoints, newObjPoints, ArgInfo("newObjPoints", 1)) &&
        jsopencv_to_safe(jsobj_stdDeviationsIntrinsics, stdDeviationsIntrinsics, ArgInfo("stdDeviationsIntrinsics", 1)) &&
        jsopencv_to_safe(jsobj_stdDeviationsExtrinsics, stdDeviationsExtrinsics, ArgInfo("stdDeviationsExtrinsics", 1)) &&
        jsopencv_to_safe(jsobj_stdDeviationsObjPoints, stdDeviationsObjPoints, ArgInfo("stdDeviationsObjPoints", 1)) &&
        jsopencv_to_safe(jsobj_perViewErrors, perViewErrors, ArgInfo("perViewErrors", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_criteria, criteria, ArgInfo("criteria", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::calibrateCameraRO(objectPoints, imagePoints, imageSize, iFixedPoint, cameraMatrix, distCoeffs, rvecs, tvecs, newObjPoints, stdDeviationsIntrinsics, stdDeviationsExtrinsics, stdDeviationsObjPoints, perViewErrors, flags, criteria));
        return Js_BuildValue(info, "(NNNNNNNNNN)", jsopencv_from(info, retval), jsopencv_from(info, cameraMatrix), jsopencv_from(info, distCoeffs), jsopencv_from(info, rvecs), jsopencv_from(info, tvecs), jsopencv_from(info, newObjPoints), jsopencv_from(info, stdDeviationsIntrinsics), jsopencv_from(info, stdDeviationsExtrinsics), jsopencv_from(info, stdDeviationsObjPoints), jsopencv_from(info, perViewErrors));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_objectPoints = NULL;
    vector_UMat objectPoints;
    Napi::Value* jsobj_imagePoints = NULL;
    vector_UMat imagePoints;
    Napi::Value* jsobj_imageSize = NULL;
    Size imageSize;
    Napi::Value* jsobj_iFixedPoint = NULL;
    int iFixedPoint=0;
    Napi::Value* jsobj_cameraMatrix = NULL;
    UMat cameraMatrix;
    Napi::Value* jsobj_distCoeffs = NULL;
    UMat distCoeffs;
    Napi::Value* jsobj_rvecs = NULL;
    vector_UMat rvecs;
    Napi::Value* jsobj_tvecs = NULL;
    vector_UMat tvecs;
    Napi::Value* jsobj_newObjPoints = NULL;
    UMat newObjPoints;
    Napi::Value* jsobj_stdDeviationsIntrinsics = NULL;
    UMat stdDeviationsIntrinsics;
    Napi::Value* jsobj_stdDeviationsExtrinsics = NULL;
    UMat stdDeviationsExtrinsics;
    Napi::Value* jsobj_stdDeviationsObjPoints = NULL;
    UMat stdDeviationsObjPoints;
    Napi::Value* jsobj_perViewErrors = NULL;
    UMat perViewErrors;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;
    Napi::Value* jsobj_criteria = NULL;
    TermCriteria criteria=TermCriteria( TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON);
    double retval;

    const char* keywords[] = { "objectPoints", "imagePoints", "imageSize", "iFixedPoint", "cameraMatrix", "distCoeffs", "rvecs", "tvecs", "newObjPoints", "stdDeviationsIntrinsics", "stdDeviationsExtrinsics", "stdDeviationsObjPoints", "perViewErrors", "flags", "criteria", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOO|OOOOOOOOO:calibrateCameraROExtended", (char**)keywords, &jsobj_objectPoints, &jsobj_imagePoints, &jsobj_imageSize, &jsobj_iFixedPoint, &jsobj_cameraMatrix, &jsobj_distCoeffs, &jsobj_rvecs, &jsobj_tvecs, &jsobj_newObjPoints, &jsobj_stdDeviationsIntrinsics, &jsobj_stdDeviationsExtrinsics, &jsobj_stdDeviationsObjPoints, &jsobj_perViewErrors, &jsobj_flags, &jsobj_criteria) &&
        jsopencv_to_safe(jsobj_objectPoints, objectPoints, ArgInfo("objectPoints", 0)) &&
        jsopencv_to_safe(jsobj_imagePoints, imagePoints, ArgInfo("imagePoints", 0)) &&
        jsopencv_to_safe(jsobj_imageSize, imageSize, ArgInfo("imageSize", 0)) &&
        jsopencv_to_safe(jsobj_iFixedPoint, iFixedPoint, ArgInfo("iFixedPoint", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 1)) &&
        jsopencv_to_safe(jsobj_distCoeffs, distCoeffs, ArgInfo("distCoeffs", 1)) &&
        jsopencv_to_safe(jsobj_rvecs, rvecs, ArgInfo("rvecs", 1)) &&
        jsopencv_to_safe(jsobj_tvecs, tvecs, ArgInfo("tvecs", 1)) &&
        jsopencv_to_safe(jsobj_newObjPoints, newObjPoints, ArgInfo("newObjPoints", 1)) &&
        jsopencv_to_safe(jsobj_stdDeviationsIntrinsics, stdDeviationsIntrinsics, ArgInfo("stdDeviationsIntrinsics", 1)) &&
        jsopencv_to_safe(jsobj_stdDeviationsExtrinsics, stdDeviationsExtrinsics, ArgInfo("stdDeviationsExtrinsics", 1)) &&
        jsopencv_to_safe(jsobj_stdDeviationsObjPoints, stdDeviationsObjPoints, ArgInfo("stdDeviationsObjPoints", 1)) &&
        jsopencv_to_safe(jsobj_perViewErrors, perViewErrors, ArgInfo("perViewErrors", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_criteria, criteria, ArgInfo("criteria", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::calibrateCameraRO(objectPoints, imagePoints, imageSize, iFixedPoint, cameraMatrix, distCoeffs, rvecs, tvecs, newObjPoints, stdDeviationsIntrinsics, stdDeviationsExtrinsics, stdDeviationsObjPoints, perViewErrors, flags, criteria));
        return Js_BuildValue(info, "(NNNNNNNNNN)", jsopencv_from(info, retval), jsopencv_from(info, cameraMatrix), jsopencv_from(info, distCoeffs), jsopencv_from(info, rvecs), jsopencv_from(info, tvecs), jsopencv_from(info, newObjPoints), jsopencv_from(info, stdDeviationsIntrinsics), jsopencv_from(info, stdDeviationsExtrinsics), jsopencv_from(info, stdDeviationsObjPoints), jsopencv_from(info, perViewErrors));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "calibrateCameraROExtended");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_calibrateHandEye(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_R_gripper2base = NULL;
    vector_Mat R_gripper2base;
    Napi::Value* jsobj_t_gripper2base = NULL;
    vector_Mat t_gripper2base;
    Napi::Value* jsobj_R_target2cam = NULL;
    vector_Mat R_target2cam;
    Napi::Value* jsobj_t_target2cam = NULL;
    vector_Mat t_target2cam;
    Napi::Value* jsobj_R_cam2gripper = NULL;
    Mat R_cam2gripper;
    Napi::Value* jsobj_t_cam2gripper = NULL;
    Mat t_cam2gripper;
    Napi::Value* jsobj_method = NULL;
    HandEyeCalibrationMethod method=CALIB_HAND_EYE_TSAI;

    const char* keywords[] = { "R_gripper2base", "t_gripper2base", "R_target2cam", "t_target2cam", "R_cam2gripper", "t_cam2gripper", "method", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOO:calibrateHandEye", (char**)keywords, &jsobj_R_gripper2base, &jsobj_t_gripper2base, &jsobj_R_target2cam, &jsobj_t_target2cam, &jsobj_R_cam2gripper, &jsobj_t_cam2gripper, &jsobj_method) &&
        jsopencv_to_safe(jsobj_R_gripper2base, R_gripper2base, ArgInfo("R_gripper2base", 0)) &&
        jsopencv_to_safe(jsobj_t_gripper2base, t_gripper2base, ArgInfo("t_gripper2base", 0)) &&
        jsopencv_to_safe(jsobj_R_target2cam, R_target2cam, ArgInfo("R_target2cam", 0)) &&
        jsopencv_to_safe(jsobj_t_target2cam, t_target2cam, ArgInfo("t_target2cam", 0)) &&
        jsopencv_to_safe(jsobj_R_cam2gripper, R_cam2gripper, ArgInfo("R_cam2gripper", 1)) &&
        jsopencv_to_safe(jsobj_t_cam2gripper, t_cam2gripper, ArgInfo("t_cam2gripper", 1)) &&
        jsopencv_to_safe(jsobj_method, method, ArgInfo("method", 0)))
    {
        ERRWRAP2_NAPI(info, cv::calibrateHandEye(R_gripper2base, t_gripper2base, R_target2cam, t_target2cam, R_cam2gripper, t_cam2gripper, method));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, R_cam2gripper), jsopencv_from(info, t_cam2gripper));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_R_gripper2base = NULL;
    vector_UMat R_gripper2base;
    Napi::Value* jsobj_t_gripper2base = NULL;
    vector_UMat t_gripper2base;
    Napi::Value* jsobj_R_target2cam = NULL;
    vector_UMat R_target2cam;
    Napi::Value* jsobj_t_target2cam = NULL;
    vector_UMat t_target2cam;
    Napi::Value* jsobj_R_cam2gripper = NULL;
    UMat R_cam2gripper;
    Napi::Value* jsobj_t_cam2gripper = NULL;
    UMat t_cam2gripper;
    Napi::Value* jsobj_method = NULL;
    HandEyeCalibrationMethod method=CALIB_HAND_EYE_TSAI;

    const char* keywords[] = { "R_gripper2base", "t_gripper2base", "R_target2cam", "t_target2cam", "R_cam2gripper", "t_cam2gripper", "method", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOO:calibrateHandEye", (char**)keywords, &jsobj_R_gripper2base, &jsobj_t_gripper2base, &jsobj_R_target2cam, &jsobj_t_target2cam, &jsobj_R_cam2gripper, &jsobj_t_cam2gripper, &jsobj_method) &&
        jsopencv_to_safe(jsobj_R_gripper2base, R_gripper2base, ArgInfo("R_gripper2base", 0)) &&
        jsopencv_to_safe(jsobj_t_gripper2base, t_gripper2base, ArgInfo("t_gripper2base", 0)) &&
        jsopencv_to_safe(jsobj_R_target2cam, R_target2cam, ArgInfo("R_target2cam", 0)) &&
        jsopencv_to_safe(jsobj_t_target2cam, t_target2cam, ArgInfo("t_target2cam", 0)) &&
        jsopencv_to_safe(jsobj_R_cam2gripper, R_cam2gripper, ArgInfo("R_cam2gripper", 1)) &&
        jsopencv_to_safe(jsobj_t_cam2gripper, t_cam2gripper, ArgInfo("t_cam2gripper", 1)) &&
        jsopencv_to_safe(jsobj_method, method, ArgInfo("method", 0)))
    {
        ERRWRAP2_NAPI(info, cv::calibrateHandEye(R_gripper2base, t_gripper2base, R_target2cam, t_target2cam, R_cam2gripper, t_cam2gripper, method));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, R_cam2gripper), jsopencv_from(info, t_cam2gripper));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "calibrateHandEye");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_calibrateRobotWorldHandEye(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_R_world2cam = NULL;
    vector_Mat R_world2cam;
    Napi::Value* jsobj_t_world2cam = NULL;
    vector_Mat t_world2cam;
    Napi::Value* jsobj_R_base2gripper = NULL;
    vector_Mat R_base2gripper;
    Napi::Value* jsobj_t_base2gripper = NULL;
    vector_Mat t_base2gripper;
    Napi::Value* jsobj_R_base2world = NULL;
    Mat R_base2world;
    Napi::Value* jsobj_t_base2world = NULL;
    Mat t_base2world;
    Napi::Value* jsobj_R_gripper2cam = NULL;
    Mat R_gripper2cam;
    Napi::Value* jsobj_t_gripper2cam = NULL;
    Mat t_gripper2cam;
    Napi::Value* jsobj_method = NULL;
    RobotWorldHandEyeCalibrationMethod method=CALIB_ROBOT_WORLD_HAND_EYE_SHAH;

    const char* keywords[] = { "R_world2cam", "t_world2cam", "R_base2gripper", "t_base2gripper", "R_base2world", "t_base2world", "R_gripper2cam", "t_gripper2cam", "method", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOOOO:calibrateRobotWorldHandEye", (char**)keywords, &jsobj_R_world2cam, &jsobj_t_world2cam, &jsobj_R_base2gripper, &jsobj_t_base2gripper, &jsobj_R_base2world, &jsobj_t_base2world, &jsobj_R_gripper2cam, &jsobj_t_gripper2cam, &jsobj_method) &&
        jsopencv_to_safe(jsobj_R_world2cam, R_world2cam, ArgInfo("R_world2cam", 0)) &&
        jsopencv_to_safe(jsobj_t_world2cam, t_world2cam, ArgInfo("t_world2cam", 0)) &&
        jsopencv_to_safe(jsobj_R_base2gripper, R_base2gripper, ArgInfo("R_base2gripper", 0)) &&
        jsopencv_to_safe(jsobj_t_base2gripper, t_base2gripper, ArgInfo("t_base2gripper", 0)) &&
        jsopencv_to_safe(jsobj_R_base2world, R_base2world, ArgInfo("R_base2world", 1)) &&
        jsopencv_to_safe(jsobj_t_base2world, t_base2world, ArgInfo("t_base2world", 1)) &&
        jsopencv_to_safe(jsobj_R_gripper2cam, R_gripper2cam, ArgInfo("R_gripper2cam", 1)) &&
        jsopencv_to_safe(jsobj_t_gripper2cam, t_gripper2cam, ArgInfo("t_gripper2cam", 1)) &&
        jsopencv_to_safe(jsobj_method, method, ArgInfo("method", 0)))
    {
        ERRWRAP2_NAPI(info, cv::calibrateRobotWorldHandEye(R_world2cam, t_world2cam, R_base2gripper, t_base2gripper, R_base2world, t_base2world, R_gripper2cam, t_gripper2cam, method));
        return Js_BuildValue(info, "(NNNN)", jsopencv_from(info, R_base2world), jsopencv_from(info, t_base2world), jsopencv_from(info, R_gripper2cam), jsopencv_from(info, t_gripper2cam));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_R_world2cam = NULL;
    vector_UMat R_world2cam;
    Napi::Value* jsobj_t_world2cam = NULL;
    vector_UMat t_world2cam;
    Napi::Value* jsobj_R_base2gripper = NULL;
    vector_UMat R_base2gripper;
    Napi::Value* jsobj_t_base2gripper = NULL;
    vector_UMat t_base2gripper;
    Napi::Value* jsobj_R_base2world = NULL;
    UMat R_base2world;
    Napi::Value* jsobj_t_base2world = NULL;
    UMat t_base2world;
    Napi::Value* jsobj_R_gripper2cam = NULL;
    UMat R_gripper2cam;
    Napi::Value* jsobj_t_gripper2cam = NULL;
    UMat t_gripper2cam;
    Napi::Value* jsobj_method = NULL;
    RobotWorldHandEyeCalibrationMethod method=CALIB_ROBOT_WORLD_HAND_EYE_SHAH;

    const char* keywords[] = { "R_world2cam", "t_world2cam", "R_base2gripper", "t_base2gripper", "R_base2world", "t_base2world", "R_gripper2cam", "t_gripper2cam", "method", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOOOO:calibrateRobotWorldHandEye", (char**)keywords, &jsobj_R_world2cam, &jsobj_t_world2cam, &jsobj_R_base2gripper, &jsobj_t_base2gripper, &jsobj_R_base2world, &jsobj_t_base2world, &jsobj_R_gripper2cam, &jsobj_t_gripper2cam, &jsobj_method) &&
        jsopencv_to_safe(jsobj_R_world2cam, R_world2cam, ArgInfo("R_world2cam", 0)) &&
        jsopencv_to_safe(jsobj_t_world2cam, t_world2cam, ArgInfo("t_world2cam", 0)) &&
        jsopencv_to_safe(jsobj_R_base2gripper, R_base2gripper, ArgInfo("R_base2gripper", 0)) &&
        jsopencv_to_safe(jsobj_t_base2gripper, t_base2gripper, ArgInfo("t_base2gripper", 0)) &&
        jsopencv_to_safe(jsobj_R_base2world, R_base2world, ArgInfo("R_base2world", 1)) &&
        jsopencv_to_safe(jsobj_t_base2world, t_base2world, ArgInfo("t_base2world", 1)) &&
        jsopencv_to_safe(jsobj_R_gripper2cam, R_gripper2cam, ArgInfo("R_gripper2cam", 1)) &&
        jsopencv_to_safe(jsobj_t_gripper2cam, t_gripper2cam, ArgInfo("t_gripper2cam", 1)) &&
        jsopencv_to_safe(jsobj_method, method, ArgInfo("method", 0)))
    {
        ERRWRAP2_NAPI(info, cv::calibrateRobotWorldHandEye(R_world2cam, t_world2cam, R_base2gripper, t_base2gripper, R_base2world, t_base2world, R_gripper2cam, t_gripper2cam, method));
        return Js_BuildValue(info, "(NNNN)", jsopencv_from(info, R_base2world), jsopencv_from(info, t_base2world), jsopencv_from(info, R_gripper2cam), jsopencv_from(info, t_gripper2cam));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "calibrateRobotWorldHandEye");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_calibrationMatrixValues(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_cameraMatrix = NULL;
    Mat cameraMatrix;
    Napi::Value* jsobj_imageSize = NULL;
    Size imageSize;
    Napi::Value* jsobj_apertureWidth = NULL;
    double apertureWidth=0;
    Napi::Value* jsobj_apertureHeight = NULL;
    double apertureHeight=0;
    double fovx;
    double fovy;
    double focalLength;
    Point2d principalPoint;
    double aspectRatio;

    const char* keywords[] = { "cameraMatrix", "imageSize", "apertureWidth", "apertureHeight", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO:calibrationMatrixValues", (char**)keywords, &jsobj_cameraMatrix, &jsobj_imageSize, &jsobj_apertureWidth, &jsobj_apertureHeight) &&
        jsopencv_to_safe(jsobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 0)) &&
        jsopencv_to_safe(jsobj_imageSize, imageSize, ArgInfo("imageSize", 0)) &&
        jsopencv_to_safe(jsobj_apertureWidth, apertureWidth, ArgInfo("apertureWidth", 0)) &&
        jsopencv_to_safe(jsobj_apertureHeight, apertureHeight, ArgInfo("apertureHeight", 0)))
    {
        ERRWRAP2_NAPI(info, cv::calibrationMatrixValues(cameraMatrix, imageSize, apertureWidth, apertureHeight, fovx, fovy, focalLength, principalPoint, aspectRatio));
        return Js_BuildValue(info, "(NNNNN)", jsopencv_from(info, fovx), jsopencv_from(info, fovy), jsopencv_from(info, focalLength), jsopencv_from(info, principalPoint), jsopencv_from(info, aspectRatio));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_cameraMatrix = NULL;
    UMat cameraMatrix;
    Napi::Value* jsobj_imageSize = NULL;
    Size imageSize;
    Napi::Value* jsobj_apertureWidth = NULL;
    double apertureWidth=0;
    Napi::Value* jsobj_apertureHeight = NULL;
    double apertureHeight=0;
    double fovx;
    double fovy;
    double focalLength;
    Point2d principalPoint;
    double aspectRatio;

    const char* keywords[] = { "cameraMatrix", "imageSize", "apertureWidth", "apertureHeight", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO:calibrationMatrixValues", (char**)keywords, &jsobj_cameraMatrix, &jsobj_imageSize, &jsobj_apertureWidth, &jsobj_apertureHeight) &&
        jsopencv_to_safe(jsobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 0)) &&
        jsopencv_to_safe(jsobj_imageSize, imageSize, ArgInfo("imageSize", 0)) &&
        jsopencv_to_safe(jsobj_apertureWidth, apertureWidth, ArgInfo("apertureWidth", 0)) &&
        jsopencv_to_safe(jsobj_apertureHeight, apertureHeight, ArgInfo("apertureHeight", 0)))
    {
        ERRWRAP2_NAPI(info, cv::calibrationMatrixValues(cameraMatrix, imageSize, apertureWidth, apertureHeight, fovx, fovy, focalLength, principalPoint, aspectRatio));
        return Js_BuildValue(info, "(NNNNN)", jsopencv_from(info, fovx), jsopencv_from(info, fovy), jsopencv_from(info, focalLength), jsopencv_from(info, principalPoint), jsopencv_from(info, aspectRatio));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "calibrationMatrixValues");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_cartToPolar(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_x = NULL;
    Mat x;
    Napi::Value* jsobj_y = NULL;
    Mat y;
    Napi::Value* jsobj_magnitude = NULL;
    Mat magnitude;
    Napi::Value* jsobj_angle = NULL;
    Mat angle;
    Napi::Value* jsobj_angleInDegrees = NULL;
    bool angleInDegrees=false;

    const char* keywords[] = { "x", "y", "magnitude", "angle", "angleInDegrees", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOO:cartToPolar", (char**)keywords, &jsobj_x, &jsobj_y, &jsobj_magnitude, &jsobj_angle, &jsobj_angleInDegrees) &&
        jsopencv_to_safe(jsobj_x, x, ArgInfo("x", 0)) &&
        jsopencv_to_safe(jsobj_y, y, ArgInfo("y", 0)) &&
        jsopencv_to_safe(jsobj_magnitude, magnitude, ArgInfo("magnitude", 1)) &&
        jsopencv_to_safe(jsobj_angle, angle, ArgInfo("angle", 1)) &&
        jsopencv_to_safe(jsobj_angleInDegrees, angleInDegrees, ArgInfo("angleInDegrees", 0)))
    {
        ERRWRAP2_NAPI(info, cv::cartToPolar(x, y, magnitude, angle, angleInDegrees));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, magnitude), jsopencv_from(info, angle));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_x = NULL;
    UMat x;
    Napi::Value* jsobj_y = NULL;
    UMat y;
    Napi::Value* jsobj_magnitude = NULL;
    UMat magnitude;
    Napi::Value* jsobj_angle = NULL;
    UMat angle;
    Napi::Value* jsobj_angleInDegrees = NULL;
    bool angleInDegrees=false;

    const char* keywords[] = { "x", "y", "magnitude", "angle", "angleInDegrees", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOO:cartToPolar", (char**)keywords, &jsobj_x, &jsobj_y, &jsobj_magnitude, &jsobj_angle, &jsobj_angleInDegrees) &&
        jsopencv_to_safe(jsobj_x, x, ArgInfo("x", 0)) &&
        jsopencv_to_safe(jsobj_y, y, ArgInfo("y", 0)) &&
        jsopencv_to_safe(jsobj_magnitude, magnitude, ArgInfo("magnitude", 1)) &&
        jsopencv_to_safe(jsobj_angle, angle, ArgInfo("angle", 1)) &&
        jsopencv_to_safe(jsobj_angleInDegrees, angleInDegrees, ArgInfo("angleInDegrees", 0)))
    {
        ERRWRAP2_NAPI(info, cv::cartToPolar(x, y, magnitude, angle, angleInDegrees));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, magnitude), jsopencv_from(info, angle));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "cartToPolar");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_checkChessboard(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_img = NULL;
    Mat img;
    Napi::Value* jsobj_size = NULL;
    Size size;
    bool retval;

    const char* keywords[] = { "img", "size", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:checkChessboard", (char**)keywords, &jsobj_img, &jsobj_size) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 0)) &&
        jsopencv_to_safe(jsobj_size, size, ArgInfo("size", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::checkChessboard(img, size));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_img = NULL;
    UMat img;
    Napi::Value* jsobj_size = NULL;
    Size size;
    bool retval;

    const char* keywords[] = { "img", "size", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:checkChessboard", (char**)keywords, &jsobj_img, &jsobj_size) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 0)) &&
        jsopencv_to_safe(jsobj_size, size, ArgInfo("size", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::checkChessboard(img, size));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "checkChessboard");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_checkHardwareSupport(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_feature = NULL;
    int feature=0;
    bool retval;

    const char* keywords[] = { "feature", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:checkHardwareSupport", (char**)keywords, &jsobj_feature) &&
        jsopencv_to_safe(jsobj_feature, feature, ArgInfo("feature", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::checkHardwareSupport(feature));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_checkRange(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_a = NULL;
    Mat a;
    Napi::Value* jsobj_quiet = NULL;
    bool quiet=true;
    Point pos;
    Napi::Value* jsobj_minVal = NULL;
    double minVal=-DBL_MAX;
    Napi::Value* jsobj_maxVal = NULL;
    double maxVal=DBL_MAX;
    bool retval;

    const char* keywords[] = { "a", "quiet", "minVal", "maxVal", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOO:checkRange", (char**)keywords, &jsobj_a, &jsobj_quiet, &jsobj_minVal, &jsobj_maxVal) &&
        jsopencv_to_safe(jsobj_a, a, ArgInfo("a", 0)) &&
        jsopencv_to_safe(jsobj_quiet, quiet, ArgInfo("quiet", 0)) &&
        jsopencv_to_safe(jsobj_minVal, minVal, ArgInfo("minVal", 0)) &&
        jsopencv_to_safe(jsobj_maxVal, maxVal, ArgInfo("maxVal", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::checkRange(a, quiet, &pos, minVal, maxVal));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, pos));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_a = NULL;
    UMat a;
    Napi::Value* jsobj_quiet = NULL;
    bool quiet=true;
    Point pos;
    Napi::Value* jsobj_minVal = NULL;
    double minVal=-DBL_MAX;
    Napi::Value* jsobj_maxVal = NULL;
    double maxVal=DBL_MAX;
    bool retval;

    const char* keywords[] = { "a", "quiet", "minVal", "maxVal", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOO:checkRange", (char**)keywords, &jsobj_a, &jsobj_quiet, &jsobj_minVal, &jsobj_maxVal) &&
        jsopencv_to_safe(jsobj_a, a, ArgInfo("a", 0)) &&
        jsopencv_to_safe(jsobj_quiet, quiet, ArgInfo("quiet", 0)) &&
        jsopencv_to_safe(jsobj_minVal, minVal, ArgInfo("minVal", 0)) &&
        jsopencv_to_safe(jsobj_maxVal, maxVal, ArgInfo("maxVal", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::checkRange(a, quiet, &pos, minVal, maxVal));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, pos));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "checkRange");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_circle(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_img = NULL;
    Mat img;
    Napi::Value* jsobj_center = NULL;
    Point center;
    Napi::Value* jsobj_radius = NULL;
    int radius=0;
    Napi::Value* jsobj_color = NULL;
    Scalar color;
    Napi::Value* jsobj_thickness = NULL;
    int thickness=1;
    Napi::Value* jsobj_lineType = NULL;
    int lineType=LINE_8;
    Napi::Value* jsobj_shift = NULL;
    int shift=0;

    const char* keywords[] = { "img", "center", "radius", "color", "thickness", "lineType", "shift", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOO:circle", (char**)keywords, &jsobj_img, &jsobj_center, &jsobj_radius, &jsobj_color, &jsobj_thickness, &jsobj_lineType, &jsobj_shift) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 1)) &&
        jsopencv_to_safe(jsobj_center, center, ArgInfo("center", 0)) &&
        jsopencv_to_safe(jsobj_radius, radius, ArgInfo("radius", 0)) &&
        jsopencv_to_safe(jsobj_color, color, ArgInfo("color", 0)) &&
        jsopencv_to_safe(jsobj_thickness, thickness, ArgInfo("thickness", 0)) &&
        jsopencv_to_safe(jsobj_lineType, lineType, ArgInfo("lineType", 0)) &&
        jsopencv_to_safe(jsobj_shift, shift, ArgInfo("shift", 0)))
    {
        ERRWRAP2_NAPI(info, cv::circle(img, center, radius, color, thickness, lineType, shift));
        return jsopencv_from(info, img);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_img = NULL;
    UMat img;
    Napi::Value* jsobj_center = NULL;
    Point center;
    Napi::Value* jsobj_radius = NULL;
    int radius=0;
    Napi::Value* jsobj_color = NULL;
    Scalar color;
    Napi::Value* jsobj_thickness = NULL;
    int thickness=1;
    Napi::Value* jsobj_lineType = NULL;
    int lineType=LINE_8;
    Napi::Value* jsobj_shift = NULL;
    int shift=0;

    const char* keywords[] = { "img", "center", "radius", "color", "thickness", "lineType", "shift", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOO:circle", (char**)keywords, &jsobj_img, &jsobj_center, &jsobj_radius, &jsobj_color, &jsobj_thickness, &jsobj_lineType, &jsobj_shift) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 1)) &&
        jsopencv_to_safe(jsobj_center, center, ArgInfo("center", 0)) &&
        jsopencv_to_safe(jsobj_radius, radius, ArgInfo("radius", 0)) &&
        jsopencv_to_safe(jsobj_color, color, ArgInfo("color", 0)) &&
        jsopencv_to_safe(jsobj_thickness, thickness, ArgInfo("thickness", 0)) &&
        jsopencv_to_safe(jsobj_lineType, lineType, ArgInfo("lineType", 0)) &&
        jsopencv_to_safe(jsobj_shift, shift, ArgInfo("shift", 0)))
    {
        ERRWRAP2_NAPI(info, cv::circle(img, center, radius, color, thickness, lineType, shift));
        return jsopencv_from(info, img);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "circle");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_clipLine(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_imgRect = NULL;
    Rect imgRect;
    Napi::Value* jsobj_pt1 = NULL;
    Point pt1;
    Napi::Value* jsobj_pt2 = NULL;
    Point pt2;
    bool retval;

    const char* keywords[] = { "imgRect", "pt1", "pt2", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:clipLine", (char**)keywords, &jsobj_imgRect, &jsobj_pt1, &jsobj_pt2) &&
        jsopencv_to_safe(jsobj_imgRect, imgRect, ArgInfo("imgRect", 0)) &&
        jsopencv_to_safe(jsobj_pt1, pt1, ArgInfo("pt1", 1)) &&
        jsopencv_to_safe(jsobj_pt2, pt2, ArgInfo("pt2", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::clipLine(imgRect, pt1, pt2));
        return Js_BuildValue(info, "(NNN)", jsopencv_from(info, retval), jsopencv_from(info, pt1), jsopencv_from(info, pt2));
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_colorChange(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_mask = NULL;
    Mat mask;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_red_mul = NULL;
    float red_mul=1.0f;
    Napi::Value* jsobj_green_mul = NULL;
    float green_mul=1.0f;
    Napi::Value* jsobj_blue_mul = NULL;
    float blue_mul=1.0f;

    const char* keywords[] = { "src", "mask", "dst", "red_mul", "green_mul", "blue_mul", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOOO:colorChange", (char**)keywords, &jsobj_src, &jsobj_mask, &jsobj_dst, &jsobj_red_mul, &jsobj_green_mul, &jsobj_blue_mul) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_red_mul, red_mul, ArgInfo("red_mul", 0)) &&
        jsopencv_to_safe(jsobj_green_mul, green_mul, ArgInfo("green_mul", 0)) &&
        jsopencv_to_safe(jsobj_blue_mul, blue_mul, ArgInfo("blue_mul", 0)))
    {
        ERRWRAP2_NAPI(info, cv::colorChange(src, mask, dst, red_mul, green_mul, blue_mul));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_mask = NULL;
    UMat mask;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_red_mul = NULL;
    float red_mul=1.0f;
    Napi::Value* jsobj_green_mul = NULL;
    float green_mul=1.0f;
    Napi::Value* jsobj_blue_mul = NULL;
    float blue_mul=1.0f;

    const char* keywords[] = { "src", "mask", "dst", "red_mul", "green_mul", "blue_mul", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOOO:colorChange", (char**)keywords, &jsobj_src, &jsobj_mask, &jsobj_dst, &jsobj_red_mul, &jsobj_green_mul, &jsobj_blue_mul) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_red_mul, red_mul, ArgInfo("red_mul", 0)) &&
        jsopencv_to_safe(jsobj_green_mul, green_mul, ArgInfo("green_mul", 0)) &&
        jsopencv_to_safe(jsobj_blue_mul, blue_mul, ArgInfo("blue_mul", 0)))
    {
        ERRWRAP2_NAPI(info, cv::colorChange(src, mask, dst, red_mul, green_mul, blue_mul));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "colorChange");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_compare(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src1 = NULL;
    Mat src1;
    Napi::Value* jsobj_src2 = NULL;
    Mat src2;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_cmpop = NULL;
    int cmpop=0;

    const char* keywords[] = { "src1", "src2", "cmpop", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:compare", (char**)keywords, &jsobj_src1, &jsobj_src2, &jsobj_cmpop, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_cmpop, cmpop, ArgInfo("cmpop", 0)))
    {
        ERRWRAP2_NAPI(info, cv::compare(src1, src2, dst, cmpop));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src1 = NULL;
    UMat src1;
    Napi::Value* jsobj_src2 = NULL;
    UMat src2;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_cmpop = NULL;
    int cmpop=0;

    const char* keywords[] = { "src1", "src2", "cmpop", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:compare", (char**)keywords, &jsobj_src1, &jsobj_src2, &jsobj_cmpop, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_cmpop, cmpop, ArgInfo("cmpop", 0)))
    {
        ERRWRAP2_NAPI(info, cv::compare(src1, src2, dst, cmpop));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "compare");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_compareHist(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_H1 = NULL;
    Mat H1;
    Napi::Value* jsobj_H2 = NULL;
    Mat H2;
    Napi::Value* jsobj_method = NULL;
    int method=0;
    double retval;

    const char* keywords[] = { "H1", "H2", "method", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:compareHist", (char**)keywords, &jsobj_H1, &jsobj_H2, &jsobj_method) &&
        jsopencv_to_safe(jsobj_H1, H1, ArgInfo("H1", 0)) &&
        jsopencv_to_safe(jsobj_H2, H2, ArgInfo("H2", 0)) &&
        jsopencv_to_safe(jsobj_method, method, ArgInfo("method", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::compareHist(H1, H2, method));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_H1 = NULL;
    UMat H1;
    Napi::Value* jsobj_H2 = NULL;
    UMat H2;
    Napi::Value* jsobj_method = NULL;
    int method=0;
    double retval;

    const char* keywords[] = { "H1", "H2", "method", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:compareHist", (char**)keywords, &jsobj_H1, &jsobj_H2, &jsobj_method) &&
        jsopencv_to_safe(jsobj_H1, H1, ArgInfo("H1", 0)) &&
        jsopencv_to_safe(jsobj_H2, H2, ArgInfo("H2", 0)) &&
        jsopencv_to_safe(jsobj_method, method, ArgInfo("method", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::compareHist(H1, H2, method));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "compareHist");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_completeSymm(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_m = NULL;
    Mat m;
    Napi::Value* jsobj_lowerToUpper = NULL;
    bool lowerToUpper=false;

    const char* keywords[] = { "m", "lowerToUpper", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:completeSymm", (char**)keywords, &jsobj_m, &jsobj_lowerToUpper) &&
        jsopencv_to_safe(jsobj_m, m, ArgInfo("m", 1)) &&
        jsopencv_to_safe(jsobj_lowerToUpper, lowerToUpper, ArgInfo("lowerToUpper", 0)))
    {
        ERRWRAP2_NAPI(info, cv::completeSymm(m, lowerToUpper));
        return jsopencv_from(info, m);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_m = NULL;
    UMat m;
    Napi::Value* jsobj_lowerToUpper = NULL;
    bool lowerToUpper=false;

    const char* keywords[] = { "m", "lowerToUpper", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:completeSymm", (char**)keywords, &jsobj_m, &jsobj_lowerToUpper) &&
        jsopencv_to_safe(jsobj_m, m, ArgInfo("m", 1)) &&
        jsopencv_to_safe(jsobj_lowerToUpper, lowerToUpper, ArgInfo("lowerToUpper", 0)))
    {
        ERRWRAP2_NAPI(info, cv::completeSymm(m, lowerToUpper));
        return jsopencv_from(info, m);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "completeSymm");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_composeRT(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_rvec1 = NULL;
    Mat rvec1;
    Napi::Value* jsobj_tvec1 = NULL;
    Mat tvec1;
    Napi::Value* jsobj_rvec2 = NULL;
    Mat rvec2;
    Napi::Value* jsobj_tvec2 = NULL;
    Mat tvec2;
    Napi::Value* jsobj_rvec3 = NULL;
    Mat rvec3;
    Napi::Value* jsobj_tvec3 = NULL;
    Mat tvec3;
    Napi::Value* jsobj_dr3dr1 = NULL;
    Mat dr3dr1;
    Napi::Value* jsobj_dr3dt1 = NULL;
    Mat dr3dt1;
    Napi::Value* jsobj_dr3dr2 = NULL;
    Mat dr3dr2;
    Napi::Value* jsobj_dr3dt2 = NULL;
    Mat dr3dt2;
    Napi::Value* jsobj_dt3dr1 = NULL;
    Mat dt3dr1;
    Napi::Value* jsobj_dt3dt1 = NULL;
    Mat dt3dt1;
    Napi::Value* jsobj_dt3dr2 = NULL;
    Mat dt3dr2;
    Napi::Value* jsobj_dt3dt2 = NULL;
    Mat dt3dt2;

    const char* keywords[] = { "rvec1", "tvec1", "rvec2", "tvec2", "rvec3", "tvec3", "dr3dr1", "dr3dt1", "dr3dr2", "dr3dt2", "dt3dr1", "dt3dt1", "dt3dr2", "dt3dt2", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOOOOOOOOO:composeRT", (char**)keywords, &jsobj_rvec1, &jsobj_tvec1, &jsobj_rvec2, &jsobj_tvec2, &jsobj_rvec3, &jsobj_tvec3, &jsobj_dr3dr1, &jsobj_dr3dt1, &jsobj_dr3dr2, &jsobj_dr3dt2, &jsobj_dt3dr1, &jsobj_dt3dt1, &jsobj_dt3dr2, &jsobj_dt3dt2) &&
        jsopencv_to_safe(jsobj_rvec1, rvec1, ArgInfo("rvec1", 0)) &&
        jsopencv_to_safe(jsobj_tvec1, tvec1, ArgInfo("tvec1", 0)) &&
        jsopencv_to_safe(jsobj_rvec2, rvec2, ArgInfo("rvec2", 0)) &&
        jsopencv_to_safe(jsobj_tvec2, tvec2, ArgInfo("tvec2", 0)) &&
        jsopencv_to_safe(jsobj_rvec3, rvec3, ArgInfo("rvec3", 1)) &&
        jsopencv_to_safe(jsobj_tvec3, tvec3, ArgInfo("tvec3", 1)) &&
        jsopencv_to_safe(jsobj_dr3dr1, dr3dr1, ArgInfo("dr3dr1", 1)) &&
        jsopencv_to_safe(jsobj_dr3dt1, dr3dt1, ArgInfo("dr3dt1", 1)) &&
        jsopencv_to_safe(jsobj_dr3dr2, dr3dr2, ArgInfo("dr3dr2", 1)) &&
        jsopencv_to_safe(jsobj_dr3dt2, dr3dt2, ArgInfo("dr3dt2", 1)) &&
        jsopencv_to_safe(jsobj_dt3dr1, dt3dr1, ArgInfo("dt3dr1", 1)) &&
        jsopencv_to_safe(jsobj_dt3dt1, dt3dt1, ArgInfo("dt3dt1", 1)) &&
        jsopencv_to_safe(jsobj_dt3dr2, dt3dr2, ArgInfo("dt3dr2", 1)) &&
        jsopencv_to_safe(jsobj_dt3dt2, dt3dt2, ArgInfo("dt3dt2", 1)))
    {
        ERRWRAP2_NAPI(info, cv::composeRT(rvec1, tvec1, rvec2, tvec2, rvec3, tvec3, dr3dr1, dr3dt1, dr3dr2, dr3dt2, dt3dr1, dt3dt1, dt3dr2, dt3dt2));
        return Js_BuildValue(info, "(NNNNNNNNNN)", jsopencv_from(info, rvec3), jsopencv_from(info, tvec3), jsopencv_from(info, dr3dr1), jsopencv_from(info, dr3dt1), jsopencv_from(info, dr3dr2), jsopencv_from(info, dr3dt2), jsopencv_from(info, dt3dr1), jsopencv_from(info, dt3dt1), jsopencv_from(info, dt3dr2), jsopencv_from(info, dt3dt2));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_rvec1 = NULL;
    UMat rvec1;
    Napi::Value* jsobj_tvec1 = NULL;
    UMat tvec1;
    Napi::Value* jsobj_rvec2 = NULL;
    UMat rvec2;
    Napi::Value* jsobj_tvec2 = NULL;
    UMat tvec2;
    Napi::Value* jsobj_rvec3 = NULL;
    UMat rvec3;
    Napi::Value* jsobj_tvec3 = NULL;
    UMat tvec3;
    Napi::Value* jsobj_dr3dr1 = NULL;
    UMat dr3dr1;
    Napi::Value* jsobj_dr3dt1 = NULL;
    UMat dr3dt1;
    Napi::Value* jsobj_dr3dr2 = NULL;
    UMat dr3dr2;
    Napi::Value* jsobj_dr3dt2 = NULL;
    UMat dr3dt2;
    Napi::Value* jsobj_dt3dr1 = NULL;
    UMat dt3dr1;
    Napi::Value* jsobj_dt3dt1 = NULL;
    UMat dt3dt1;
    Napi::Value* jsobj_dt3dr2 = NULL;
    UMat dt3dr2;
    Napi::Value* jsobj_dt3dt2 = NULL;
    UMat dt3dt2;

    const char* keywords[] = { "rvec1", "tvec1", "rvec2", "tvec2", "rvec3", "tvec3", "dr3dr1", "dr3dt1", "dr3dr2", "dr3dt2", "dt3dr1", "dt3dt1", "dt3dr2", "dt3dt2", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOOOOOOOOO:composeRT", (char**)keywords, &jsobj_rvec1, &jsobj_tvec1, &jsobj_rvec2, &jsobj_tvec2, &jsobj_rvec3, &jsobj_tvec3, &jsobj_dr3dr1, &jsobj_dr3dt1, &jsobj_dr3dr2, &jsobj_dr3dt2, &jsobj_dt3dr1, &jsobj_dt3dt1, &jsobj_dt3dr2, &jsobj_dt3dt2) &&
        jsopencv_to_safe(jsobj_rvec1, rvec1, ArgInfo("rvec1", 0)) &&
        jsopencv_to_safe(jsobj_tvec1, tvec1, ArgInfo("tvec1", 0)) &&
        jsopencv_to_safe(jsobj_rvec2, rvec2, ArgInfo("rvec2", 0)) &&
        jsopencv_to_safe(jsobj_tvec2, tvec2, ArgInfo("tvec2", 0)) &&
        jsopencv_to_safe(jsobj_rvec3, rvec3, ArgInfo("rvec3", 1)) &&
        jsopencv_to_safe(jsobj_tvec3, tvec3, ArgInfo("tvec3", 1)) &&
        jsopencv_to_safe(jsobj_dr3dr1, dr3dr1, ArgInfo("dr3dr1", 1)) &&
        jsopencv_to_safe(jsobj_dr3dt1, dr3dt1, ArgInfo("dr3dt1", 1)) &&
        jsopencv_to_safe(jsobj_dr3dr2, dr3dr2, ArgInfo("dr3dr2", 1)) &&
        jsopencv_to_safe(jsobj_dr3dt2, dr3dt2, ArgInfo("dr3dt2", 1)) &&
        jsopencv_to_safe(jsobj_dt3dr1, dt3dr1, ArgInfo("dt3dr1", 1)) &&
        jsopencv_to_safe(jsobj_dt3dt1, dt3dt1, ArgInfo("dt3dt1", 1)) &&
        jsopencv_to_safe(jsobj_dt3dr2, dt3dr2, ArgInfo("dt3dr2", 1)) &&
        jsopencv_to_safe(jsobj_dt3dt2, dt3dt2, ArgInfo("dt3dt2", 1)))
    {
        ERRWRAP2_NAPI(info, cv::composeRT(rvec1, tvec1, rvec2, tvec2, rvec3, tvec3, dr3dr1, dr3dt1, dr3dr2, dr3dt2, dt3dr1, dt3dt1, dt3dr2, dt3dt2));
        return Js_BuildValue(info, "(NNNNNNNNNN)", jsopencv_from(info, rvec3), jsopencv_from(info, tvec3), jsopencv_from(info, dr3dr1), jsopencv_from(info, dr3dt1), jsopencv_from(info, dr3dr2), jsopencv_from(info, dr3dt2), jsopencv_from(info, dt3dr1), jsopencv_from(info, dt3dt1), jsopencv_from(info, dt3dr2), jsopencv_from(info, dt3dt2));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "composeRT");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_computeCorrespondEpilines(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_points = NULL;
    Mat points;
    Napi::Value* jsobj_whichImage = NULL;
    int whichImage=0;
    Napi::Value* jsobj_F = NULL;
    Mat F;
    Napi::Value* jsobj_lines = NULL;
    Mat lines;

    const char* keywords[] = { "points", "whichImage", "F", "lines", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:computeCorrespondEpilines", (char**)keywords, &jsobj_points, &jsobj_whichImage, &jsobj_F, &jsobj_lines) &&
        jsopencv_to_safe(jsobj_points, points, ArgInfo("points", 0)) &&
        jsopencv_to_safe(jsobj_whichImage, whichImage, ArgInfo("whichImage", 0)) &&
        jsopencv_to_safe(jsobj_F, F, ArgInfo("F", 0)) &&
        jsopencv_to_safe(jsobj_lines, lines, ArgInfo("lines", 1)))
    {
        ERRWRAP2_NAPI(info, cv::computeCorrespondEpilines(points, whichImage, F, lines));
        return jsopencv_from(info, lines);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_points = NULL;
    UMat points;
    Napi::Value* jsobj_whichImage = NULL;
    int whichImage=0;
    Napi::Value* jsobj_F = NULL;
    UMat F;
    Napi::Value* jsobj_lines = NULL;
    UMat lines;

    const char* keywords[] = { "points", "whichImage", "F", "lines", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:computeCorrespondEpilines", (char**)keywords, &jsobj_points, &jsobj_whichImage, &jsobj_F, &jsobj_lines) &&
        jsopencv_to_safe(jsobj_points, points, ArgInfo("points", 0)) &&
        jsopencv_to_safe(jsobj_whichImage, whichImage, ArgInfo("whichImage", 0)) &&
        jsopencv_to_safe(jsobj_F, F, ArgInfo("F", 0)) &&
        jsopencv_to_safe(jsobj_lines, lines, ArgInfo("lines", 1)))
    {
        ERRWRAP2_NAPI(info, cv::computeCorrespondEpilines(points, whichImage, F, lines));
        return jsopencv_from(info, lines);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "computeCorrespondEpilines");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_computeECC(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_templateImage = NULL;
    Mat templateImage;
    Napi::Value* jsobj_inputImage = NULL;
    Mat inputImage;
    Napi::Value* jsobj_inputMask = NULL;
    Mat inputMask;
    double retval;

    const char* keywords[] = { "templateImage", "inputImage", "inputMask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:computeECC", (char**)keywords, &jsobj_templateImage, &jsobj_inputImage, &jsobj_inputMask) &&
        jsopencv_to_safe(jsobj_templateImage, templateImage, ArgInfo("templateImage", 0)) &&
        jsopencv_to_safe(jsobj_inputImage, inputImage, ArgInfo("inputImage", 0)) &&
        jsopencv_to_safe(jsobj_inputMask, inputMask, ArgInfo("inputMask", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::computeECC(templateImage, inputImage, inputMask));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_templateImage = NULL;
    UMat templateImage;
    Napi::Value* jsobj_inputImage = NULL;
    UMat inputImage;
    Napi::Value* jsobj_inputMask = NULL;
    UMat inputMask;
    double retval;

    const char* keywords[] = { "templateImage", "inputImage", "inputMask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:computeECC", (char**)keywords, &jsobj_templateImage, &jsobj_inputImage, &jsobj_inputMask) &&
        jsopencv_to_safe(jsobj_templateImage, templateImage, ArgInfo("templateImage", 0)) &&
        jsopencv_to_safe(jsobj_inputImage, inputImage, ArgInfo("inputImage", 0)) &&
        jsopencv_to_safe(jsobj_inputMask, inputMask, ArgInfo("inputMask", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::computeECC(templateImage, inputImage, inputMask));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "computeECC");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_connectedComponents(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_image = NULL;
    Mat image;
    Napi::Value* jsobj_labels = NULL;
    Mat labels;
    Napi::Value* jsobj_connectivity = NULL;
    int connectivity=8;
    Napi::Value* jsobj_ltype = NULL;
    int ltype=CV_32S;
    int retval;

    const char* keywords[] = { "image", "labels", "connectivity", "ltype", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOO:connectedComponents", (char**)keywords, &jsobj_image, &jsobj_labels, &jsobj_connectivity, &jsobj_ltype) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_labels, labels, ArgInfo("labels", 1)) &&
        jsopencv_to_safe(jsobj_connectivity, connectivity, ArgInfo("connectivity", 0)) &&
        jsopencv_to_safe(jsobj_ltype, ltype, ArgInfo("ltype", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::connectedComponents(image, labels, connectivity, ltype));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, labels));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_image = NULL;
    UMat image;
    Napi::Value* jsobj_labels = NULL;
    UMat labels;
    Napi::Value* jsobj_connectivity = NULL;
    int connectivity=8;
    Napi::Value* jsobj_ltype = NULL;
    int ltype=CV_32S;
    int retval;

    const char* keywords[] = { "image", "labels", "connectivity", "ltype", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOO:connectedComponents", (char**)keywords, &jsobj_image, &jsobj_labels, &jsobj_connectivity, &jsobj_ltype) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_labels, labels, ArgInfo("labels", 1)) &&
        jsopencv_to_safe(jsobj_connectivity, connectivity, ArgInfo("connectivity", 0)) &&
        jsopencv_to_safe(jsobj_ltype, ltype, ArgInfo("ltype", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::connectedComponents(image, labels, connectivity, ltype));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, labels));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "connectedComponents");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_connectedComponentsWithAlgorithm(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_image = NULL;
    Mat image;
    Napi::Value* jsobj_labels = NULL;
    Mat labels;
    Napi::Value* jsobj_connectivity = NULL;
    int connectivity=0;
    Napi::Value* jsobj_ltype = NULL;
    int ltype=0;
    Napi::Value* jsobj_ccltype = NULL;
    int ccltype=0;
    int retval;

    const char* keywords[] = { "image", "connectivity", "ltype", "ccltype", "labels", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|O:connectedComponentsWithAlgorithm", (char**)keywords, &jsobj_image, &jsobj_connectivity, &jsobj_ltype, &jsobj_ccltype, &jsobj_labels) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_labels, labels, ArgInfo("labels", 1)) &&
        jsopencv_to_safe(jsobj_connectivity, connectivity, ArgInfo("connectivity", 0)) &&
        jsopencv_to_safe(jsobj_ltype, ltype, ArgInfo("ltype", 0)) &&
        jsopencv_to_safe(jsobj_ccltype, ccltype, ArgInfo("ccltype", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::connectedComponents(image, labels, connectivity, ltype, ccltype));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, labels));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_image = NULL;
    UMat image;
    Napi::Value* jsobj_labels = NULL;
    UMat labels;
    Napi::Value* jsobj_connectivity = NULL;
    int connectivity=0;
    Napi::Value* jsobj_ltype = NULL;
    int ltype=0;
    Napi::Value* jsobj_ccltype = NULL;
    int ccltype=0;
    int retval;

    const char* keywords[] = { "image", "connectivity", "ltype", "ccltype", "labels", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|O:connectedComponentsWithAlgorithm", (char**)keywords, &jsobj_image, &jsobj_connectivity, &jsobj_ltype, &jsobj_ccltype, &jsobj_labels) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_labels, labels, ArgInfo("labels", 1)) &&
        jsopencv_to_safe(jsobj_connectivity, connectivity, ArgInfo("connectivity", 0)) &&
        jsopencv_to_safe(jsobj_ltype, ltype, ArgInfo("ltype", 0)) &&
        jsopencv_to_safe(jsobj_ccltype, ccltype, ArgInfo("ccltype", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::connectedComponents(image, labels, connectivity, ltype, ccltype));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, labels));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "connectedComponentsWithAlgorithm");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_connectedComponentsWithStats(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_image = NULL;
    Mat image;
    Napi::Value* jsobj_labels = NULL;
    Mat labels;
    Napi::Value* jsobj_stats = NULL;
    Mat stats;
    Napi::Value* jsobj_centroids = NULL;
    Mat centroids;
    Napi::Value* jsobj_connectivity = NULL;
    int connectivity=8;
    Napi::Value* jsobj_ltype = NULL;
    int ltype=CV_32S;
    int retval;

    const char* keywords[] = { "image", "labels", "stats", "centroids", "connectivity", "ltype", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOOOO:connectedComponentsWithStats", (char**)keywords, &jsobj_image, &jsobj_labels, &jsobj_stats, &jsobj_centroids, &jsobj_connectivity, &jsobj_ltype) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_labels, labels, ArgInfo("labels", 1)) &&
        jsopencv_to_safe(jsobj_stats, stats, ArgInfo("stats", 1)) &&
        jsopencv_to_safe(jsobj_centroids, centroids, ArgInfo("centroids", 1)) &&
        jsopencv_to_safe(jsobj_connectivity, connectivity, ArgInfo("connectivity", 0)) &&
        jsopencv_to_safe(jsobj_ltype, ltype, ArgInfo("ltype", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::connectedComponentsWithStats(image, labels, stats, centroids, connectivity, ltype));
        return Js_BuildValue(info, "(NNNN)", jsopencv_from(info, retval), jsopencv_from(info, labels), jsopencv_from(info, stats), jsopencv_from(info, centroids));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_image = NULL;
    UMat image;
    Napi::Value* jsobj_labels = NULL;
    UMat labels;
    Napi::Value* jsobj_stats = NULL;
    UMat stats;
    Napi::Value* jsobj_centroids = NULL;
    UMat centroids;
    Napi::Value* jsobj_connectivity = NULL;
    int connectivity=8;
    Napi::Value* jsobj_ltype = NULL;
    int ltype=CV_32S;
    int retval;

    const char* keywords[] = { "image", "labels", "stats", "centroids", "connectivity", "ltype", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOOOO:connectedComponentsWithStats", (char**)keywords, &jsobj_image, &jsobj_labels, &jsobj_stats, &jsobj_centroids, &jsobj_connectivity, &jsobj_ltype) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_labels, labels, ArgInfo("labels", 1)) &&
        jsopencv_to_safe(jsobj_stats, stats, ArgInfo("stats", 1)) &&
        jsopencv_to_safe(jsobj_centroids, centroids, ArgInfo("centroids", 1)) &&
        jsopencv_to_safe(jsobj_connectivity, connectivity, ArgInfo("connectivity", 0)) &&
        jsopencv_to_safe(jsobj_ltype, ltype, ArgInfo("ltype", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::connectedComponentsWithStats(image, labels, stats, centroids, connectivity, ltype));
        return Js_BuildValue(info, "(NNNN)", jsopencv_from(info, retval), jsopencv_from(info, labels), jsopencv_from(info, stats), jsopencv_from(info, centroids));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "connectedComponentsWithStats");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_connectedComponentsWithStatsWithAlgorithm(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_image = NULL;
    Mat image;
    Napi::Value* jsobj_labels = NULL;
    Mat labels;
    Napi::Value* jsobj_stats = NULL;
    Mat stats;
    Napi::Value* jsobj_centroids = NULL;
    Mat centroids;
    Napi::Value* jsobj_connectivity = NULL;
    int connectivity=0;
    Napi::Value* jsobj_ltype = NULL;
    int ltype=0;
    Napi::Value* jsobj_ccltype = NULL;
    int ccltype=0;
    int retval;

    const char* keywords[] = { "image", "connectivity", "ltype", "ccltype", "labels", "stats", "centroids", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOO:connectedComponentsWithStatsWithAlgorithm", (char**)keywords, &jsobj_image, &jsobj_connectivity, &jsobj_ltype, &jsobj_ccltype, &jsobj_labels, &jsobj_stats, &jsobj_centroids) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_labels, labels, ArgInfo("labels", 1)) &&
        jsopencv_to_safe(jsobj_stats, stats, ArgInfo("stats", 1)) &&
        jsopencv_to_safe(jsobj_centroids, centroids, ArgInfo("centroids", 1)) &&
        jsopencv_to_safe(jsobj_connectivity, connectivity, ArgInfo("connectivity", 0)) &&
        jsopencv_to_safe(jsobj_ltype, ltype, ArgInfo("ltype", 0)) &&
        jsopencv_to_safe(jsobj_ccltype, ccltype, ArgInfo("ccltype", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::connectedComponentsWithStats(image, labels, stats, centroids, connectivity, ltype, ccltype));
        return Js_BuildValue(info, "(NNNN)", jsopencv_from(info, retval), jsopencv_from(info, labels), jsopencv_from(info, stats), jsopencv_from(info, centroids));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_image = NULL;
    UMat image;
    Napi::Value* jsobj_labels = NULL;
    UMat labels;
    Napi::Value* jsobj_stats = NULL;
    UMat stats;
    Napi::Value* jsobj_centroids = NULL;
    UMat centroids;
    Napi::Value* jsobj_connectivity = NULL;
    int connectivity=0;
    Napi::Value* jsobj_ltype = NULL;
    int ltype=0;
    Napi::Value* jsobj_ccltype = NULL;
    int ccltype=0;
    int retval;

    const char* keywords[] = { "image", "connectivity", "ltype", "ccltype", "labels", "stats", "centroids", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOO:connectedComponentsWithStatsWithAlgorithm", (char**)keywords, &jsobj_image, &jsobj_connectivity, &jsobj_ltype, &jsobj_ccltype, &jsobj_labels, &jsobj_stats, &jsobj_centroids) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_labels, labels, ArgInfo("labels", 1)) &&
        jsopencv_to_safe(jsobj_stats, stats, ArgInfo("stats", 1)) &&
        jsopencv_to_safe(jsobj_centroids, centroids, ArgInfo("centroids", 1)) &&
        jsopencv_to_safe(jsobj_connectivity, connectivity, ArgInfo("connectivity", 0)) &&
        jsopencv_to_safe(jsobj_ltype, ltype, ArgInfo("ltype", 0)) &&
        jsopencv_to_safe(jsobj_ccltype, ccltype, ArgInfo("ccltype", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::connectedComponentsWithStats(image, labels, stats, centroids, connectivity, ltype, ccltype));
        return Js_BuildValue(info, "(NNNN)", jsopencv_from(info, retval), jsopencv_from(info, labels), jsopencv_from(info, stats), jsopencv_from(info, centroids));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "connectedComponentsWithStatsWithAlgorithm");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_contourArea(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_contour = NULL;
    Mat contour;
    Napi::Value* jsobj_oriented = NULL;
    bool oriented=false;
    double retval;

    const char* keywords[] = { "contour", "oriented", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:contourArea", (char**)keywords, &jsobj_contour, &jsobj_oriented) &&
        jsopencv_to_safe(jsobj_contour, contour, ArgInfo("contour", 0)) &&
        jsopencv_to_safe(jsobj_oriented, oriented, ArgInfo("oriented", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::contourArea(contour, oriented));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_contour = NULL;
    UMat contour;
    Napi::Value* jsobj_oriented = NULL;
    bool oriented=false;
    double retval;

    const char* keywords[] = { "contour", "oriented", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:contourArea", (char**)keywords, &jsobj_contour, &jsobj_oriented) &&
        jsopencv_to_safe(jsobj_contour, contour, ArgInfo("contour", 0)) &&
        jsopencv_to_safe(jsobj_oriented, oriented, ArgInfo("oriented", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::contourArea(contour, oriented));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "contourArea");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_convertFp16(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;

    const char* keywords[] = { "src", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:convertFp16", (char**)keywords, &jsobj_src, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)))
    {
        ERRWRAP2_NAPI(info, cv::convertFp16(src, dst));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;

    const char* keywords[] = { "src", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:convertFp16", (char**)keywords, &jsobj_src, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)))
    {
        ERRWRAP2_NAPI(info, cv::convertFp16(src, dst));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "convertFp16");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_convertMaps(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_map1 = NULL;
    Mat map1;
    Napi::Value* jsobj_map2 = NULL;
    Mat map2;
    Napi::Value* jsobj_dstmap1 = NULL;
    Mat dstmap1;
    Napi::Value* jsobj_dstmap2 = NULL;
    Mat dstmap2;
    Napi::Value* jsobj_dstmap1type = NULL;
    int dstmap1type=0;
    Napi::Value* jsobj_nninterpolation = NULL;
    bool nninterpolation=false;

    const char* keywords[] = { "map1", "map2", "dstmap1type", "dstmap1", "dstmap2", "nninterpolation", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOO:convertMaps", (char**)keywords, &jsobj_map1, &jsobj_map2, &jsobj_dstmap1type, &jsobj_dstmap1, &jsobj_dstmap2, &jsobj_nninterpolation) &&
        jsopencv_to_safe(jsobj_map1, map1, ArgInfo("map1", 0)) &&
        jsopencv_to_safe(jsobj_map2, map2, ArgInfo("map2", 0)) &&
        jsopencv_to_safe(jsobj_dstmap1, dstmap1, ArgInfo("dstmap1", 1)) &&
        jsopencv_to_safe(jsobj_dstmap2, dstmap2, ArgInfo("dstmap2", 1)) &&
        jsopencv_to_safe(jsobj_dstmap1type, dstmap1type, ArgInfo("dstmap1type", 0)) &&
        jsopencv_to_safe(jsobj_nninterpolation, nninterpolation, ArgInfo("nninterpolation", 0)))
    {
        ERRWRAP2_NAPI(info, cv::convertMaps(map1, map2, dstmap1, dstmap2, dstmap1type, nninterpolation));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, dstmap1), jsopencv_from(info, dstmap2));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_map1 = NULL;
    UMat map1;
    Napi::Value* jsobj_map2 = NULL;
    UMat map2;
    Napi::Value* jsobj_dstmap1 = NULL;
    UMat dstmap1;
    Napi::Value* jsobj_dstmap2 = NULL;
    UMat dstmap2;
    Napi::Value* jsobj_dstmap1type = NULL;
    int dstmap1type=0;
    Napi::Value* jsobj_nninterpolation = NULL;
    bool nninterpolation=false;

    const char* keywords[] = { "map1", "map2", "dstmap1type", "dstmap1", "dstmap2", "nninterpolation", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOO:convertMaps", (char**)keywords, &jsobj_map1, &jsobj_map2, &jsobj_dstmap1type, &jsobj_dstmap1, &jsobj_dstmap2, &jsobj_nninterpolation) &&
        jsopencv_to_safe(jsobj_map1, map1, ArgInfo("map1", 0)) &&
        jsopencv_to_safe(jsobj_map2, map2, ArgInfo("map2", 0)) &&
        jsopencv_to_safe(jsobj_dstmap1, dstmap1, ArgInfo("dstmap1", 1)) &&
        jsopencv_to_safe(jsobj_dstmap2, dstmap2, ArgInfo("dstmap2", 1)) &&
        jsopencv_to_safe(jsobj_dstmap1type, dstmap1type, ArgInfo("dstmap1type", 0)) &&
        jsopencv_to_safe(jsobj_nninterpolation, nninterpolation, ArgInfo("nninterpolation", 0)))
    {
        ERRWRAP2_NAPI(info, cv::convertMaps(map1, map2, dstmap1, dstmap2, dstmap1type, nninterpolation));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, dstmap1), jsopencv_from(info, dstmap2));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "convertMaps");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_convertPointsFromHomogeneous(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;

    const char* keywords[] = { "src", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:convertPointsFromHomogeneous", (char**)keywords, &jsobj_src, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)))
    {
        ERRWRAP2_NAPI(info, cv::convertPointsFromHomogeneous(src, dst));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;

    const char* keywords[] = { "src", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:convertPointsFromHomogeneous", (char**)keywords, &jsobj_src, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)))
    {
        ERRWRAP2_NAPI(info, cv::convertPointsFromHomogeneous(src, dst));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "convertPointsFromHomogeneous");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_convertPointsToHomogeneous(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;

    const char* keywords[] = { "src", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:convertPointsToHomogeneous", (char**)keywords, &jsobj_src, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)))
    {
        ERRWRAP2_NAPI(info, cv::convertPointsToHomogeneous(src, dst));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;

    const char* keywords[] = { "src", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:convertPointsToHomogeneous", (char**)keywords, &jsobj_src, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)))
    {
        ERRWRAP2_NAPI(info, cv::convertPointsToHomogeneous(src, dst));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "convertPointsToHomogeneous");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_convertScaleAbs(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_alpha = NULL;
    double alpha=1;
    Napi::Value* jsobj_beta = NULL;
    double beta=0;

    const char* keywords[] = { "src", "dst", "alpha", "beta", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOO:convertScaleAbs", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_alpha, &jsobj_beta) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_alpha, alpha, ArgInfo("alpha", 0)) &&
        jsopencv_to_safe(jsobj_beta, beta, ArgInfo("beta", 0)))
    {
        ERRWRAP2_NAPI(info, cv::convertScaleAbs(src, dst, alpha, beta));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_alpha = NULL;
    double alpha=1;
    Napi::Value* jsobj_beta = NULL;
    double beta=0;

    const char* keywords[] = { "src", "dst", "alpha", "beta", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOO:convertScaleAbs", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_alpha, &jsobj_beta) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_alpha, alpha, ArgInfo("alpha", 0)) &&
        jsopencv_to_safe(jsobj_beta, beta, ArgInfo("beta", 0)))
    {
        ERRWRAP2_NAPI(info, cv::convertScaleAbs(src, dst, alpha, beta));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "convertScaleAbs");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_convexHull(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_points = NULL;
    Mat points;
    Napi::Value* jsobj_hull = NULL;
    Mat hull;
    Napi::Value* jsobj_clockwise = NULL;
    bool clockwise=false;
    Napi::Value* jsobj_returnPoints = NULL;
    bool returnPoints=true;

    const char* keywords[] = { "points", "hull", "clockwise", "returnPoints", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOO:convexHull", (char**)keywords, &jsobj_points, &jsobj_hull, &jsobj_clockwise, &jsobj_returnPoints) &&
        jsopencv_to_safe(jsobj_points, points, ArgInfo("points", 0)) &&
        jsopencv_to_safe(jsobj_hull, hull, ArgInfo("hull", 1)) &&
        jsopencv_to_safe(jsobj_clockwise, clockwise, ArgInfo("clockwise", 0)) &&
        jsopencv_to_safe(jsobj_returnPoints, returnPoints, ArgInfo("returnPoints", 0)))
    {
        ERRWRAP2_NAPI(info, cv::convexHull(points, hull, clockwise, returnPoints));
        return jsopencv_from(info, hull);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_points = NULL;
    UMat points;
    Napi::Value* jsobj_hull = NULL;
    UMat hull;
    Napi::Value* jsobj_clockwise = NULL;
    bool clockwise=false;
    Napi::Value* jsobj_returnPoints = NULL;
    bool returnPoints=true;

    const char* keywords[] = { "points", "hull", "clockwise", "returnPoints", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOO:convexHull", (char**)keywords, &jsobj_points, &jsobj_hull, &jsobj_clockwise, &jsobj_returnPoints) &&
        jsopencv_to_safe(jsobj_points, points, ArgInfo("points", 0)) &&
        jsopencv_to_safe(jsobj_hull, hull, ArgInfo("hull", 1)) &&
        jsopencv_to_safe(jsobj_clockwise, clockwise, ArgInfo("clockwise", 0)) &&
        jsopencv_to_safe(jsobj_returnPoints, returnPoints, ArgInfo("returnPoints", 0)))
    {
        ERRWRAP2_NAPI(info, cv::convexHull(points, hull, clockwise, returnPoints));
        return jsopencv_from(info, hull);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "convexHull");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_convexityDefects(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_contour = NULL;
    Mat contour;
    Napi::Value* jsobj_convexhull = NULL;
    Mat convexhull;
    Napi::Value* jsobj_convexityDefects = NULL;
    Mat convexityDefects;

    const char* keywords[] = { "contour", "convexhull", "convexityDefects", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:convexityDefects", (char**)keywords, &jsobj_contour, &jsobj_convexhull, &jsobj_convexityDefects) &&
        jsopencv_to_safe(jsobj_contour, contour, ArgInfo("contour", 0)) &&
        jsopencv_to_safe(jsobj_convexhull, convexhull, ArgInfo("convexhull", 0)) &&
        jsopencv_to_safe(jsobj_convexityDefects, convexityDefects, ArgInfo("convexityDefects", 1)))
    {
        ERRWRAP2_NAPI(info, cv::convexityDefects(contour, convexhull, convexityDefects));
        return jsopencv_from(info, convexityDefects);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_contour = NULL;
    UMat contour;
    Napi::Value* jsobj_convexhull = NULL;
    UMat convexhull;
    Napi::Value* jsobj_convexityDefects = NULL;
    UMat convexityDefects;

    const char* keywords[] = { "contour", "convexhull", "convexityDefects", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:convexityDefects", (char**)keywords, &jsobj_contour, &jsobj_convexhull, &jsobj_convexityDefects) &&
        jsopencv_to_safe(jsobj_contour, contour, ArgInfo("contour", 0)) &&
        jsopencv_to_safe(jsobj_convexhull, convexhull, ArgInfo("convexhull", 0)) &&
        jsopencv_to_safe(jsobj_convexityDefects, convexityDefects, ArgInfo("convexityDefects", 1)))
    {
        ERRWRAP2_NAPI(info, cv::convexityDefects(contour, convexhull, convexityDefects));
        return jsopencv_from(info, convexityDefects);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "convexityDefects");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_copyMakeBorder(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_top = NULL;
    int top=0;
    Napi::Value* jsobj_bottom = NULL;
    int bottom=0;
    Napi::Value* jsobj_left = NULL;
    int left=0;
    Napi::Value* jsobj_right = NULL;
    int right=0;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=0;
    Napi::Value* jsobj_value = NULL;
    Scalar value;

    const char* keywords[] = { "src", "top", "bottom", "left", "right", "borderType", "dst", "value", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOO|OO:copyMakeBorder", (char**)keywords, &jsobj_src, &jsobj_top, &jsobj_bottom, &jsobj_left, &jsobj_right, &jsobj_borderType, &jsobj_dst, &jsobj_value) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_top, top, ArgInfo("top", 0)) &&
        jsopencv_to_safe(jsobj_bottom, bottom, ArgInfo("bottom", 0)) &&
        jsopencv_to_safe(jsobj_left, left, ArgInfo("left", 0)) &&
        jsopencv_to_safe(jsobj_right, right, ArgInfo("right", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)) &&
        jsopencv_to_safe(jsobj_value, value, ArgInfo("value", 0)))
    {
        ERRWRAP2_NAPI(info, cv::copyMakeBorder(src, dst, top, bottom, left, right, borderType, value));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_top = NULL;
    int top=0;
    Napi::Value* jsobj_bottom = NULL;
    int bottom=0;
    Napi::Value* jsobj_left = NULL;
    int left=0;
    Napi::Value* jsobj_right = NULL;
    int right=0;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=0;
    Napi::Value* jsobj_value = NULL;
    Scalar value;

    const char* keywords[] = { "src", "top", "bottom", "left", "right", "borderType", "dst", "value", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOO|OO:copyMakeBorder", (char**)keywords, &jsobj_src, &jsobj_top, &jsobj_bottom, &jsobj_left, &jsobj_right, &jsobj_borderType, &jsobj_dst, &jsobj_value) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_top, top, ArgInfo("top", 0)) &&
        jsopencv_to_safe(jsobj_bottom, bottom, ArgInfo("bottom", 0)) &&
        jsopencv_to_safe(jsobj_left, left, ArgInfo("left", 0)) &&
        jsopencv_to_safe(jsobj_right, right, ArgInfo("right", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)) &&
        jsopencv_to_safe(jsobj_value, value, ArgInfo("value", 0)))
    {
        ERRWRAP2_NAPI(info, cv::copyMakeBorder(src, dst, top, bottom, left, right, borderType, value));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "copyMakeBorder");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_copyTo(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_mask = NULL;
    Mat mask;

    const char* keywords[] = { "src", "mask", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:copyTo", (char**)keywords, &jsobj_src, &jsobj_mask, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)))
    {
        ERRWRAP2_NAPI(info, cv::copyTo(src, dst, mask));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_mask = NULL;
    UMat mask;

    const char* keywords[] = { "src", "mask", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:copyTo", (char**)keywords, &jsobj_src, &jsobj_mask, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)))
    {
        ERRWRAP2_NAPI(info, cv::copyTo(src, dst, mask));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "copyTo");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_cornerEigenValsAndVecs(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_blockSize = NULL;
    int blockSize=0;
    Napi::Value* jsobj_ksize = NULL;
    int ksize=0;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_DEFAULT;

    const char* keywords[] = { "src", "blockSize", "ksize", "dst", "borderType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OO:cornerEigenValsAndVecs", (char**)keywords, &jsobj_src, &jsobj_blockSize, &jsobj_ksize, &jsobj_dst, &jsobj_borderType) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_blockSize, blockSize, ArgInfo("blockSize", 0)) &&
        jsopencv_to_safe(jsobj_ksize, ksize, ArgInfo("ksize", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)))
    {
        ERRWRAP2_NAPI(info, cv::cornerEigenValsAndVecs(src, dst, blockSize, ksize, borderType));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_blockSize = NULL;
    int blockSize=0;
    Napi::Value* jsobj_ksize = NULL;
    int ksize=0;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_DEFAULT;

    const char* keywords[] = { "src", "blockSize", "ksize", "dst", "borderType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OO:cornerEigenValsAndVecs", (char**)keywords, &jsobj_src, &jsobj_blockSize, &jsobj_ksize, &jsobj_dst, &jsobj_borderType) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_blockSize, blockSize, ArgInfo("blockSize", 0)) &&
        jsopencv_to_safe(jsobj_ksize, ksize, ArgInfo("ksize", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)))
    {
        ERRWRAP2_NAPI(info, cv::cornerEigenValsAndVecs(src, dst, blockSize, ksize, borderType));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "cornerEigenValsAndVecs");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_cornerHarris(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_blockSize = NULL;
    int blockSize=0;
    Napi::Value* jsobj_ksize = NULL;
    int ksize=0;
    Napi::Value* jsobj_k = NULL;
    double k=0;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_DEFAULT;

    const char* keywords[] = { "src", "blockSize", "ksize", "k", "dst", "borderType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OO:cornerHarris", (char**)keywords, &jsobj_src, &jsobj_blockSize, &jsobj_ksize, &jsobj_k, &jsobj_dst, &jsobj_borderType) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_blockSize, blockSize, ArgInfo("blockSize", 0)) &&
        jsopencv_to_safe(jsobj_ksize, ksize, ArgInfo("ksize", 0)) &&
        jsopencv_to_safe(jsobj_k, k, ArgInfo("k", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)))
    {
        ERRWRAP2_NAPI(info, cv::cornerHarris(src, dst, blockSize, ksize, k, borderType));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_blockSize = NULL;
    int blockSize=0;
    Napi::Value* jsobj_ksize = NULL;
    int ksize=0;
    Napi::Value* jsobj_k = NULL;
    double k=0;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_DEFAULT;

    const char* keywords[] = { "src", "blockSize", "ksize", "k", "dst", "borderType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OO:cornerHarris", (char**)keywords, &jsobj_src, &jsobj_blockSize, &jsobj_ksize, &jsobj_k, &jsobj_dst, &jsobj_borderType) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_blockSize, blockSize, ArgInfo("blockSize", 0)) &&
        jsopencv_to_safe(jsobj_ksize, ksize, ArgInfo("ksize", 0)) &&
        jsopencv_to_safe(jsobj_k, k, ArgInfo("k", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)))
    {
        ERRWRAP2_NAPI(info, cv::cornerHarris(src, dst, blockSize, ksize, k, borderType));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "cornerHarris");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_cornerMinEigenVal(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_blockSize = NULL;
    int blockSize=0;
    Napi::Value* jsobj_ksize = NULL;
    int ksize=3;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_DEFAULT;

    const char* keywords[] = { "src", "blockSize", "dst", "ksize", "borderType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOO:cornerMinEigenVal", (char**)keywords, &jsobj_src, &jsobj_blockSize, &jsobj_dst, &jsobj_ksize, &jsobj_borderType) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_blockSize, blockSize, ArgInfo("blockSize", 0)) &&
        jsopencv_to_safe(jsobj_ksize, ksize, ArgInfo("ksize", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)))
    {
        ERRWRAP2_NAPI(info, cv::cornerMinEigenVal(src, dst, blockSize, ksize, borderType));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_blockSize = NULL;
    int blockSize=0;
    Napi::Value* jsobj_ksize = NULL;
    int ksize=3;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_DEFAULT;

    const char* keywords[] = { "src", "blockSize", "dst", "ksize", "borderType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOO:cornerMinEigenVal", (char**)keywords, &jsobj_src, &jsobj_blockSize, &jsobj_dst, &jsobj_ksize, &jsobj_borderType) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_blockSize, blockSize, ArgInfo("blockSize", 0)) &&
        jsopencv_to_safe(jsobj_ksize, ksize, ArgInfo("ksize", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)))
    {
        ERRWRAP2_NAPI(info, cv::cornerMinEigenVal(src, dst, blockSize, ksize, borderType));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "cornerMinEigenVal");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_cornerSubPix(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_image = NULL;
    Mat image;
    Napi::Value* jsobj_corners = NULL;
    Mat corners;
    Napi::Value* jsobj_winSize = NULL;
    Size winSize;
    Napi::Value* jsobj_zeroZone = NULL;
    Size zeroZone;
    Napi::Value* jsobj_criteria = NULL;
    TermCriteria criteria;

    const char* keywords[] = { "image", "corners", "winSize", "zeroZone", "criteria", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOO:cornerSubPix", (char**)keywords, &jsobj_image, &jsobj_corners, &jsobj_winSize, &jsobj_zeroZone, &jsobj_criteria) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_corners, corners, ArgInfo("corners", 1)) &&
        jsopencv_to_safe(jsobj_winSize, winSize, ArgInfo("winSize", 0)) &&
        jsopencv_to_safe(jsobj_zeroZone, zeroZone, ArgInfo("zeroZone", 0)) &&
        jsopencv_to_safe(jsobj_criteria, criteria, ArgInfo("criteria", 0)))
    {
        ERRWRAP2_NAPI(info, cv::cornerSubPix(image, corners, winSize, zeroZone, criteria));
        return jsopencv_from(info, corners);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_image = NULL;
    UMat image;
    Napi::Value* jsobj_corners = NULL;
    UMat corners;
    Napi::Value* jsobj_winSize = NULL;
    Size winSize;
    Napi::Value* jsobj_zeroZone = NULL;
    Size zeroZone;
    Napi::Value* jsobj_criteria = NULL;
    TermCriteria criteria;

    const char* keywords[] = { "image", "corners", "winSize", "zeroZone", "criteria", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOO:cornerSubPix", (char**)keywords, &jsobj_image, &jsobj_corners, &jsobj_winSize, &jsobj_zeroZone, &jsobj_criteria) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_corners, corners, ArgInfo("corners", 1)) &&
        jsopencv_to_safe(jsobj_winSize, winSize, ArgInfo("winSize", 0)) &&
        jsopencv_to_safe(jsobj_zeroZone, zeroZone, ArgInfo("zeroZone", 0)) &&
        jsopencv_to_safe(jsobj_criteria, criteria, ArgInfo("criteria", 0)))
    {
        ERRWRAP2_NAPI(info, cv::cornerSubPix(image, corners, winSize, zeroZone, criteria));
        return jsopencv_from(info, corners);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "cornerSubPix");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_correctMatches(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_F = NULL;
    Mat F;
    Napi::Value* jsobj_points1 = NULL;
    Mat points1;
    Napi::Value* jsobj_points2 = NULL;
    Mat points2;
    Napi::Value* jsobj_newPoints1 = NULL;
    Mat newPoints1;
    Napi::Value* jsobj_newPoints2 = NULL;
    Mat newPoints2;

    const char* keywords[] = { "F", "points1", "points2", "newPoints1", "newPoints2", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OO:correctMatches", (char**)keywords, &jsobj_F, &jsobj_points1, &jsobj_points2, &jsobj_newPoints1, &jsobj_newPoints2) &&
        jsopencv_to_safe(jsobj_F, F, ArgInfo("F", 0)) &&
        jsopencv_to_safe(jsobj_points1, points1, ArgInfo("points1", 0)) &&
        jsopencv_to_safe(jsobj_points2, points2, ArgInfo("points2", 0)) &&
        jsopencv_to_safe(jsobj_newPoints1, newPoints1, ArgInfo("newPoints1", 1)) &&
        jsopencv_to_safe(jsobj_newPoints2, newPoints2, ArgInfo("newPoints2", 1)))
    {
        ERRWRAP2_NAPI(info, cv::correctMatches(F, points1, points2, newPoints1, newPoints2));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, newPoints1), jsopencv_from(info, newPoints2));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_F = NULL;
    UMat F;
    Napi::Value* jsobj_points1 = NULL;
    UMat points1;
    Napi::Value* jsobj_points2 = NULL;
    UMat points2;
    Napi::Value* jsobj_newPoints1 = NULL;
    UMat newPoints1;
    Napi::Value* jsobj_newPoints2 = NULL;
    UMat newPoints2;

    const char* keywords[] = { "F", "points1", "points2", "newPoints1", "newPoints2", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OO:correctMatches", (char**)keywords, &jsobj_F, &jsobj_points1, &jsobj_points2, &jsobj_newPoints1, &jsobj_newPoints2) &&
        jsopencv_to_safe(jsobj_F, F, ArgInfo("F", 0)) &&
        jsopencv_to_safe(jsobj_points1, points1, ArgInfo("points1", 0)) &&
        jsopencv_to_safe(jsobj_points2, points2, ArgInfo("points2", 0)) &&
        jsopencv_to_safe(jsobj_newPoints1, newPoints1, ArgInfo("newPoints1", 1)) &&
        jsopencv_to_safe(jsobj_newPoints2, newPoints2, ArgInfo("newPoints2", 1)))
    {
        ERRWRAP2_NAPI(info, cv::correctMatches(F, points1, points2, newPoints1, newPoints2));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, newPoints1), jsopencv_from(info, newPoints2));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "correctMatches");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_countNonZero(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    int retval;

    const char* keywords[] = { "src", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:countNonZero", (char**)keywords, &jsobj_src) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::countNonZero(src));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    int retval;

    const char* keywords[] = { "src", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:countNonZero", (char**)keywords, &jsobj_src) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::countNonZero(src));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "countNonZero");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_createAlignMTB(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_max_bits = NULL;
    int max_bits=6;
    Napi::Value* jsobj_exclude_range = NULL;
    int exclude_range=4;
    Napi::Value* jsobj_cut = NULL;
    bool cut=true;
    Ptr<AlignMTB> retval;

    const char* keywords[] = { "max_bits", "exclude_range", "cut", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OOO:createAlignMTB", (char**)keywords, &jsobj_max_bits, &jsobj_exclude_range, &jsobj_cut) &&
        jsopencv_to_safe(jsobj_max_bits, max_bits, ArgInfo("max_bits", 0)) &&
        jsopencv_to_safe(jsobj_exclude_range, exclude_range, ArgInfo("exclude_range", 0)) &&
        jsopencv_to_safe(jsobj_cut, cut, ArgInfo("cut", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::createAlignMTB(max_bits, exclude_range, cut));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_createBackgroundSubtractorKNN(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_history = NULL;
    int history=500;
    Napi::Value* jsobj_dist2Threshold = NULL;
    double dist2Threshold=400.0;
    Napi::Value* jsobj_detectShadows = NULL;
    bool detectShadows=true;
    Ptr<BackgroundSubtractorKNN> retval;

    const char* keywords[] = { "history", "dist2Threshold", "detectShadows", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OOO:createBackgroundSubtractorKNN", (char**)keywords, &jsobj_history, &jsobj_dist2Threshold, &jsobj_detectShadows) &&
        jsopencv_to_safe(jsobj_history, history, ArgInfo("history", 0)) &&
        jsopencv_to_safe(jsobj_dist2Threshold, dist2Threshold, ArgInfo("dist2Threshold", 0)) &&
        jsopencv_to_safe(jsobj_detectShadows, detectShadows, ArgInfo("detectShadows", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::createBackgroundSubtractorKNN(history, dist2Threshold, detectShadows));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_createBackgroundSubtractorMOG2(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_history = NULL;
    int history=500;
    Napi::Value* jsobj_varThreshold = NULL;
    double varThreshold=16;
    Napi::Value* jsobj_detectShadows = NULL;
    bool detectShadows=true;
    Ptr<BackgroundSubtractorMOG2> retval;

    const char* keywords[] = { "history", "varThreshold", "detectShadows", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OOO:createBackgroundSubtractorMOG2", (char**)keywords, &jsobj_history, &jsobj_varThreshold, &jsobj_detectShadows) &&
        jsopencv_to_safe(jsobj_history, history, ArgInfo("history", 0)) &&
        jsopencv_to_safe(jsobj_varThreshold, varThreshold, ArgInfo("varThreshold", 0)) &&
        jsopencv_to_safe(jsobj_detectShadows, detectShadows, ArgInfo("detectShadows", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::createBackgroundSubtractorMOG2(history, varThreshold, detectShadows));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_createCLAHE(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_clipLimit = NULL;
    double clipLimit=40.0;
    Napi::Value* jsobj_tileGridSize = NULL;
    Size tileGridSize=Size(8, 8);
    Ptr<CLAHE> retval;

    const char* keywords[] = { "clipLimit", "tileGridSize", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OO:createCLAHE", (char**)keywords, &jsobj_clipLimit, &jsobj_tileGridSize) &&
        jsopencv_to_safe(jsobj_clipLimit, clipLimit, ArgInfo("clipLimit", 0)) &&
        jsopencv_to_safe(jsobj_tileGridSize, tileGridSize, ArgInfo("tileGridSize", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::createCLAHE(clipLimit, tileGridSize));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_createCalibrateDebevec(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_samples = NULL;
    int samples=70;
    Napi::Value* jsobj_lambda = NULL;
    float lambda=10.0f;
    Napi::Value* jsobj_random = NULL;
    bool random=false;
    Ptr<CalibrateDebevec> retval;

    const char* keywords[] = { "samples", "lambda_", "random", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OOO:createCalibrateDebevec", (char**)keywords, &jsobj_samples, &jsobj_lambda, &jsobj_random) &&
        jsopencv_to_safe(jsobj_samples, samples, ArgInfo("samples", 0)) &&
        jsopencv_to_safe(jsobj_lambda, lambda, ArgInfo("lambda", 0)) &&
        jsopencv_to_safe(jsobj_random, random, ArgInfo("random", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::createCalibrateDebevec(samples, lambda, random));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_createCalibrateRobertson(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_max_iter = NULL;
    int max_iter=30;
    Napi::Value* jsobj_threshold = NULL;
    float threshold=0.01f;
    Ptr<CalibrateRobertson> retval;

    const char* keywords[] = { "max_iter", "threshold", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OO:createCalibrateRobertson", (char**)keywords, &jsobj_max_iter, &jsobj_threshold) &&
        jsopencv_to_safe(jsobj_max_iter, max_iter, ArgInfo("max_iter", 0)) &&
        jsopencv_to_safe(jsobj_threshold, threshold, ArgInfo("threshold", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::createCalibrateRobertson(max_iter, threshold));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_createGeneralizedHoughBallard(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Ptr<GeneralizedHoughBallard> retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::createGeneralizedHoughBallard());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_createGeneralizedHoughGuil(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Ptr<GeneralizedHoughGuil> retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::createGeneralizedHoughGuil());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_createHanningWindow(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_winSize = NULL;
    Size winSize;
    Napi::Value* jsobj_type = NULL;
    int type=0;

    const char* keywords[] = { "winSize", "type", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:createHanningWindow", (char**)keywords, &jsobj_winSize, &jsobj_type, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_winSize, winSize, ArgInfo("winSize", 0)) &&
        jsopencv_to_safe(jsobj_type, type, ArgInfo("type", 0)))
    {
        ERRWRAP2_NAPI(info, cv::createHanningWindow(dst, winSize, type));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_winSize = NULL;
    Size winSize;
    Napi::Value* jsobj_type = NULL;
    int type=0;

    const char* keywords[] = { "winSize", "type", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:createHanningWindow", (char**)keywords, &jsobj_winSize, &jsobj_type, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_winSize, winSize, ArgInfo("winSize", 0)) &&
        jsopencv_to_safe(jsobj_type, type, ArgInfo("type", 0)))
    {
        ERRWRAP2_NAPI(info, cv::createHanningWindow(dst, winSize, type));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "createHanningWindow");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_createLineSegmentDetector(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_refine = NULL;
    int refine=LSD_REFINE_STD;
    Napi::Value* jsobj_scale = NULL;
    double scale=0.8;
    Napi::Value* jsobj_sigma_scale = NULL;
    double sigma_scale=0.6;
    Napi::Value* jsobj_quant = NULL;
    double quant=2.0;
    Napi::Value* jsobj_ang_th = NULL;
    double ang_th=22.5;
    Napi::Value* jsobj_log_eps = NULL;
    double log_eps=0;
    Napi::Value* jsobj_density_th = NULL;
    double density_th=0.7;
    Napi::Value* jsobj_n_bins = NULL;
    int n_bins=1024;
    Ptr<LineSegmentDetector> retval;

    const char* keywords[] = { "refine", "scale", "sigma_scale", "quant", "ang_th", "log_eps", "density_th", "n_bins", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OOOOOOOO:createLineSegmentDetector", (char**)keywords, &jsobj_refine, &jsobj_scale, &jsobj_sigma_scale, &jsobj_quant, &jsobj_ang_th, &jsobj_log_eps, &jsobj_density_th, &jsobj_n_bins) &&
        jsopencv_to_safe(jsobj_refine, refine, ArgInfo("refine", 0)) &&
        jsopencv_to_safe(jsobj_scale, scale, ArgInfo("scale", 0)) &&
        jsopencv_to_safe(jsobj_sigma_scale, sigma_scale, ArgInfo("sigma_scale", 0)) &&
        jsopencv_to_safe(jsobj_quant, quant, ArgInfo("quant", 0)) &&
        jsopencv_to_safe(jsobj_ang_th, ang_th, ArgInfo("ang_th", 0)) &&
        jsopencv_to_safe(jsobj_log_eps, log_eps, ArgInfo("log_eps", 0)) &&
        jsopencv_to_safe(jsobj_density_th, density_th, ArgInfo("density_th", 0)) &&
        jsopencv_to_safe(jsobj_n_bins, n_bins, ArgInfo("n_bins", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::createLineSegmentDetector(refine, scale, sigma_scale, quant, ang_th, log_eps, density_th, n_bins));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_createMergeDebevec(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Ptr<MergeDebevec> retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::createMergeDebevec());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_createMergeMertens(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_contrast_weight = NULL;
    float contrast_weight=1.0f;
    Napi::Value* jsobj_saturation_weight = NULL;
    float saturation_weight=1.0f;
    Napi::Value* jsobj_exposure_weight = NULL;
    float exposure_weight=0.0f;
    Ptr<MergeMertens> retval;

    const char* keywords[] = { "contrast_weight", "saturation_weight", "exposure_weight", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OOO:createMergeMertens", (char**)keywords, &jsobj_contrast_weight, &jsobj_saturation_weight, &jsobj_exposure_weight) &&
        jsopencv_to_safe(jsobj_contrast_weight, contrast_weight, ArgInfo("contrast_weight", 0)) &&
        jsopencv_to_safe(jsobj_saturation_weight, saturation_weight, ArgInfo("saturation_weight", 0)) &&
        jsopencv_to_safe(jsobj_exposure_weight, exposure_weight, ArgInfo("exposure_weight", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::createMergeMertens(contrast_weight, saturation_weight, exposure_weight));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_createMergeRobertson(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Ptr<MergeRobertson> retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::createMergeRobertson());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_createTonemap(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_gamma = NULL;
    float gamma=1.0f;
    Ptr<Tonemap> retval;

    const char* keywords[] = { "gamma", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|O:createTonemap", (char**)keywords, &jsobj_gamma) &&
        jsopencv_to_safe(jsobj_gamma, gamma, ArgInfo("gamma", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::createTonemap(gamma));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_createTonemapDrago(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_gamma = NULL;
    float gamma=1.0f;
    Napi::Value* jsobj_saturation = NULL;
    float saturation=1.0f;
    Napi::Value* jsobj_bias = NULL;
    float bias=0.85f;
    Ptr<TonemapDrago> retval;

    const char* keywords[] = { "gamma", "saturation", "bias", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OOO:createTonemapDrago", (char**)keywords, &jsobj_gamma, &jsobj_saturation, &jsobj_bias) &&
        jsopencv_to_safe(jsobj_gamma, gamma, ArgInfo("gamma", 0)) &&
        jsopencv_to_safe(jsobj_saturation, saturation, ArgInfo("saturation", 0)) &&
        jsopencv_to_safe(jsobj_bias, bias, ArgInfo("bias", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::createTonemapDrago(gamma, saturation, bias));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_createTonemapMantiuk(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_gamma = NULL;
    float gamma=1.0f;
    Napi::Value* jsobj_scale = NULL;
    float scale=0.7f;
    Napi::Value* jsobj_saturation = NULL;
    float saturation=1.0f;
    Ptr<TonemapMantiuk> retval;

    const char* keywords[] = { "gamma", "scale", "saturation", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OOO:createTonemapMantiuk", (char**)keywords, &jsobj_gamma, &jsobj_scale, &jsobj_saturation) &&
        jsopencv_to_safe(jsobj_gamma, gamma, ArgInfo("gamma", 0)) &&
        jsopencv_to_safe(jsobj_scale, scale, ArgInfo("scale", 0)) &&
        jsopencv_to_safe(jsobj_saturation, saturation, ArgInfo("saturation", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::createTonemapMantiuk(gamma, scale, saturation));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_createTonemapReinhard(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_gamma = NULL;
    float gamma=1.0f;
    Napi::Value* jsobj_intensity = NULL;
    float intensity=0.0f;
    Napi::Value* jsobj_light_adapt = NULL;
    float light_adapt=1.0f;
    Napi::Value* jsobj_color_adapt = NULL;
    float color_adapt=0.0f;
    Ptr<TonemapReinhard> retval;

    const char* keywords[] = { "gamma", "intensity", "light_adapt", "color_adapt", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OOOO:createTonemapReinhard", (char**)keywords, &jsobj_gamma, &jsobj_intensity, &jsobj_light_adapt, &jsobj_color_adapt) &&
        jsopencv_to_safe(jsobj_gamma, gamma, ArgInfo("gamma", 0)) &&
        jsopencv_to_safe(jsobj_intensity, intensity, ArgInfo("intensity", 0)) &&
        jsopencv_to_safe(jsobj_light_adapt, light_adapt, ArgInfo("light_adapt", 0)) &&
        jsopencv_to_safe(jsobj_color_adapt, color_adapt, ArgInfo("color_adapt", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::createTonemapReinhard(gamma, intensity, light_adapt, color_adapt));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_cubeRoot(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_val = NULL;
    float val=0.f;
    float retval;

    const char* keywords[] = { "val", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:cubeRoot", (char**)keywords, &jsobj_val) &&
        jsopencv_to_safe(jsobj_val, val, ArgInfo("val", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::cubeRoot(val));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_cvtColor(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_code = NULL;
    int code=0;
    Napi::Value* jsobj_dstCn = NULL;
    int dstCn=0;

    const char* keywords[] = { "src", "code", "dst", "dstCn", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:cvtColor", (char**)keywords, &jsobj_src, &jsobj_code, &jsobj_dst, &jsobj_dstCn) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_code, code, ArgInfo("code", 0)) &&
        jsopencv_to_safe(jsobj_dstCn, dstCn, ArgInfo("dstCn", 0)))
    {
        ERRWRAP2_NAPI(info, cv::cvtColor(src, dst, code, dstCn));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_code = NULL;
    int code=0;
    Napi::Value* jsobj_dstCn = NULL;
    int dstCn=0;

    const char* keywords[] = { "src", "code", "dst", "dstCn", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:cvtColor", (char**)keywords, &jsobj_src, &jsobj_code, &jsobj_dst, &jsobj_dstCn) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_code, code, ArgInfo("code", 0)) &&
        jsopencv_to_safe(jsobj_dstCn, dstCn, ArgInfo("dstCn", 0)))
    {
        ERRWRAP2_NAPI(info, cv::cvtColor(src, dst, code, dstCn));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "cvtColor");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_cvtColorTwoPlane(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src1 = NULL;
    Mat src1;
    Napi::Value* jsobj_src2 = NULL;
    Mat src2;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_code = NULL;
    int code=0;

    const char* keywords[] = { "src1", "src2", "code", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:cvtColorTwoPlane", (char**)keywords, &jsobj_src1, &jsobj_src2, &jsobj_code, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_code, code, ArgInfo("code", 0)))
    {
        ERRWRAP2_NAPI(info, cv::cvtColorTwoPlane(src1, src2, dst, code));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src1 = NULL;
    UMat src1;
    Napi::Value* jsobj_src2 = NULL;
    UMat src2;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_code = NULL;
    int code=0;

    const char* keywords[] = { "src1", "src2", "code", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:cvtColorTwoPlane", (char**)keywords, &jsobj_src1, &jsobj_src2, &jsobj_code, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_code, code, ArgInfo("code", 0)))
    {
        ERRWRAP2_NAPI(info, cv::cvtColorTwoPlane(src1, src2, dst, code));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "cvtColorTwoPlane");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_dct(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;

    const char* keywords[] = { "src", "dst", "flags", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OO:dct", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_flags) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, cv::dct(src, dst, flags));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;

    const char* keywords[] = { "src", "dst", "flags", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OO:dct", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_flags) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, cv::dct(src, dst, flags));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "dct");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_decolor(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_grayscale = NULL;
    Mat grayscale;
    Napi::Value* jsobj_color_boost = NULL;
    Mat color_boost;

    const char* keywords[] = { "src", "grayscale", "color_boost", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OO:decolor", (char**)keywords, &jsobj_src, &jsobj_grayscale, &jsobj_color_boost) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_grayscale, grayscale, ArgInfo("grayscale", 1)) &&
        jsopencv_to_safe(jsobj_color_boost, color_boost, ArgInfo("color_boost", 1)))
    {
        ERRWRAP2_NAPI(info, cv::decolor(src, grayscale, color_boost));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, grayscale), jsopencv_from(info, color_boost));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_grayscale = NULL;
    UMat grayscale;
    Napi::Value* jsobj_color_boost = NULL;
    UMat color_boost;

    const char* keywords[] = { "src", "grayscale", "color_boost", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OO:decolor", (char**)keywords, &jsobj_src, &jsobj_grayscale, &jsobj_color_boost) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_grayscale, grayscale, ArgInfo("grayscale", 1)) &&
        jsopencv_to_safe(jsobj_color_boost, color_boost, ArgInfo("color_boost", 1)))
    {
        ERRWRAP2_NAPI(info, cv::decolor(src, grayscale, color_boost));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, grayscale), jsopencv_from(info, color_boost));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "decolor");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_decomposeEssentialMat(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_E = NULL;
    Mat E;
    Napi::Value* jsobj_R1 = NULL;
    Mat R1;
    Napi::Value* jsobj_R2 = NULL;
    Mat R2;
    Napi::Value* jsobj_t = NULL;
    Mat t;

    const char* keywords[] = { "E", "R1", "R2", "t", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOO:decomposeEssentialMat", (char**)keywords, &jsobj_E, &jsobj_R1, &jsobj_R2, &jsobj_t) &&
        jsopencv_to_safe(jsobj_E, E, ArgInfo("E", 0)) &&
        jsopencv_to_safe(jsobj_R1, R1, ArgInfo("R1", 1)) &&
        jsopencv_to_safe(jsobj_R2, R2, ArgInfo("R2", 1)) &&
        jsopencv_to_safe(jsobj_t, t, ArgInfo("t", 1)))
    {
        ERRWRAP2_NAPI(info, cv::decomposeEssentialMat(E, R1, R2, t));
        return Js_BuildValue(info, "(NNN)", jsopencv_from(info, R1), jsopencv_from(info, R2), jsopencv_from(info, t));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_E = NULL;
    UMat E;
    Napi::Value* jsobj_R1 = NULL;
    UMat R1;
    Napi::Value* jsobj_R2 = NULL;
    UMat R2;
    Napi::Value* jsobj_t = NULL;
    UMat t;

    const char* keywords[] = { "E", "R1", "R2", "t", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOO:decomposeEssentialMat", (char**)keywords, &jsobj_E, &jsobj_R1, &jsobj_R2, &jsobj_t) &&
        jsopencv_to_safe(jsobj_E, E, ArgInfo("E", 0)) &&
        jsopencv_to_safe(jsobj_R1, R1, ArgInfo("R1", 1)) &&
        jsopencv_to_safe(jsobj_R2, R2, ArgInfo("R2", 1)) &&
        jsopencv_to_safe(jsobj_t, t, ArgInfo("t", 1)))
    {
        ERRWRAP2_NAPI(info, cv::decomposeEssentialMat(E, R1, R2, t));
        return Js_BuildValue(info, "(NNN)", jsopencv_from(info, R1), jsopencv_from(info, R2), jsopencv_from(info, t));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "decomposeEssentialMat");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_decomposeHomographyMat(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_H = NULL;
    Mat H;
    Napi::Value* jsobj_K = NULL;
    Mat K;
    Napi::Value* jsobj_rotations = NULL;
    vector_Mat rotations;
    Napi::Value* jsobj_translations = NULL;
    vector_Mat translations;
    Napi::Value* jsobj_normals = NULL;
    vector_Mat normals;
    int retval;

    const char* keywords[] = { "H", "K", "rotations", "translations", "normals", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOO:decomposeHomographyMat", (char**)keywords, &jsobj_H, &jsobj_K, &jsobj_rotations, &jsobj_translations, &jsobj_normals) &&
        jsopencv_to_safe(jsobj_H, H, ArgInfo("H", 0)) &&
        jsopencv_to_safe(jsobj_K, K, ArgInfo("K", 0)) &&
        jsopencv_to_safe(jsobj_rotations, rotations, ArgInfo("rotations", 1)) &&
        jsopencv_to_safe(jsobj_translations, translations, ArgInfo("translations", 1)) &&
        jsopencv_to_safe(jsobj_normals, normals, ArgInfo("normals", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::decomposeHomographyMat(H, K, rotations, translations, normals));
        return Js_BuildValue(info, "(NNNN)", jsopencv_from(info, retval), jsopencv_from(info, rotations), jsopencv_from(info, translations), jsopencv_from(info, normals));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_H = NULL;
    UMat H;
    Napi::Value* jsobj_K = NULL;
    UMat K;
    Napi::Value* jsobj_rotations = NULL;
    vector_UMat rotations;
    Napi::Value* jsobj_translations = NULL;
    vector_UMat translations;
    Napi::Value* jsobj_normals = NULL;
    vector_UMat normals;
    int retval;

    const char* keywords[] = { "H", "K", "rotations", "translations", "normals", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOO:decomposeHomographyMat", (char**)keywords, &jsobj_H, &jsobj_K, &jsobj_rotations, &jsobj_translations, &jsobj_normals) &&
        jsopencv_to_safe(jsobj_H, H, ArgInfo("H", 0)) &&
        jsopencv_to_safe(jsobj_K, K, ArgInfo("K", 0)) &&
        jsopencv_to_safe(jsobj_rotations, rotations, ArgInfo("rotations", 1)) &&
        jsopencv_to_safe(jsobj_translations, translations, ArgInfo("translations", 1)) &&
        jsopencv_to_safe(jsobj_normals, normals, ArgInfo("normals", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::decomposeHomographyMat(H, K, rotations, translations, normals));
        return Js_BuildValue(info, "(NNNN)", jsopencv_from(info, retval), jsopencv_from(info, rotations), jsopencv_from(info, translations), jsopencv_from(info, normals));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "decomposeHomographyMat");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_decomposeProjectionMatrix(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_projMatrix = NULL;
    Mat projMatrix;
    Napi::Value* jsobj_cameraMatrix = NULL;
    Mat cameraMatrix;
    Napi::Value* jsobj_rotMatrix = NULL;
    Mat rotMatrix;
    Napi::Value* jsobj_transVect = NULL;
    Mat transVect;
    Napi::Value* jsobj_rotMatrixX = NULL;
    Mat rotMatrixX;
    Napi::Value* jsobj_rotMatrixY = NULL;
    Mat rotMatrixY;
    Napi::Value* jsobj_rotMatrixZ = NULL;
    Mat rotMatrixZ;
    Napi::Value* jsobj_eulerAngles = NULL;
    Mat eulerAngles;

    const char* keywords[] = { "projMatrix", "cameraMatrix", "rotMatrix", "transVect", "rotMatrixX", "rotMatrixY", "rotMatrixZ", "eulerAngles", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOOOOOO:decomposeProjectionMatrix", (char**)keywords, &jsobj_projMatrix, &jsobj_cameraMatrix, &jsobj_rotMatrix, &jsobj_transVect, &jsobj_rotMatrixX, &jsobj_rotMatrixY, &jsobj_rotMatrixZ, &jsobj_eulerAngles) &&
        jsopencv_to_safe(jsobj_projMatrix, projMatrix, ArgInfo("projMatrix", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 1)) &&
        jsopencv_to_safe(jsobj_rotMatrix, rotMatrix, ArgInfo("rotMatrix", 1)) &&
        jsopencv_to_safe(jsobj_transVect, transVect, ArgInfo("transVect", 1)) &&
        jsopencv_to_safe(jsobj_rotMatrixX, rotMatrixX, ArgInfo("rotMatrixX", 1)) &&
        jsopencv_to_safe(jsobj_rotMatrixY, rotMatrixY, ArgInfo("rotMatrixY", 1)) &&
        jsopencv_to_safe(jsobj_rotMatrixZ, rotMatrixZ, ArgInfo("rotMatrixZ", 1)) &&
        jsopencv_to_safe(jsobj_eulerAngles, eulerAngles, ArgInfo("eulerAngles", 1)))
    {
        ERRWRAP2_NAPI(info, cv::decomposeProjectionMatrix(projMatrix, cameraMatrix, rotMatrix, transVect, rotMatrixX, rotMatrixY, rotMatrixZ, eulerAngles));
        return Js_BuildValue(info, "(NNNNNNN)", jsopencv_from(info, cameraMatrix), jsopencv_from(info, rotMatrix), jsopencv_from(info, transVect), jsopencv_from(info, rotMatrixX), jsopencv_from(info, rotMatrixY), jsopencv_from(info, rotMatrixZ), jsopencv_from(info, eulerAngles));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_projMatrix = NULL;
    UMat projMatrix;
    Napi::Value* jsobj_cameraMatrix = NULL;
    UMat cameraMatrix;
    Napi::Value* jsobj_rotMatrix = NULL;
    UMat rotMatrix;
    Napi::Value* jsobj_transVect = NULL;
    UMat transVect;
    Napi::Value* jsobj_rotMatrixX = NULL;
    UMat rotMatrixX;
    Napi::Value* jsobj_rotMatrixY = NULL;
    UMat rotMatrixY;
    Napi::Value* jsobj_rotMatrixZ = NULL;
    UMat rotMatrixZ;
    Napi::Value* jsobj_eulerAngles = NULL;
    UMat eulerAngles;

    const char* keywords[] = { "projMatrix", "cameraMatrix", "rotMatrix", "transVect", "rotMatrixX", "rotMatrixY", "rotMatrixZ", "eulerAngles", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOOOOOO:decomposeProjectionMatrix", (char**)keywords, &jsobj_projMatrix, &jsobj_cameraMatrix, &jsobj_rotMatrix, &jsobj_transVect, &jsobj_rotMatrixX, &jsobj_rotMatrixY, &jsobj_rotMatrixZ, &jsobj_eulerAngles) &&
        jsopencv_to_safe(jsobj_projMatrix, projMatrix, ArgInfo("projMatrix", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 1)) &&
        jsopencv_to_safe(jsobj_rotMatrix, rotMatrix, ArgInfo("rotMatrix", 1)) &&
        jsopencv_to_safe(jsobj_transVect, transVect, ArgInfo("transVect", 1)) &&
        jsopencv_to_safe(jsobj_rotMatrixX, rotMatrixX, ArgInfo("rotMatrixX", 1)) &&
        jsopencv_to_safe(jsobj_rotMatrixY, rotMatrixY, ArgInfo("rotMatrixY", 1)) &&
        jsopencv_to_safe(jsobj_rotMatrixZ, rotMatrixZ, ArgInfo("rotMatrixZ", 1)) &&
        jsopencv_to_safe(jsobj_eulerAngles, eulerAngles, ArgInfo("eulerAngles", 1)))
    {
        ERRWRAP2_NAPI(info, cv::decomposeProjectionMatrix(projMatrix, cameraMatrix, rotMatrix, transVect, rotMatrixX, rotMatrixY, rotMatrixZ, eulerAngles));
        return Js_BuildValue(info, "(NNNNNNN)", jsopencv_from(info, cameraMatrix), jsopencv_from(info, rotMatrix), jsopencv_from(info, transVect), jsopencv_from(info, rotMatrixX), jsopencv_from(info, rotMatrixY), jsopencv_from(info, rotMatrixZ), jsopencv_from(info, eulerAngles));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "decomposeProjectionMatrix");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_demosaicing(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_code = NULL;
    int code=0;
    Napi::Value* jsobj_dstCn = NULL;
    int dstCn=0;

    const char* keywords[] = { "src", "code", "dst", "dstCn", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:demosaicing", (char**)keywords, &jsobj_src, &jsobj_code, &jsobj_dst, &jsobj_dstCn) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_code, code, ArgInfo("code", 0)) &&
        jsopencv_to_safe(jsobj_dstCn, dstCn, ArgInfo("dstCn", 0)))
    {
        ERRWRAP2_NAPI(info, cv::demosaicing(src, dst, code, dstCn));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_code = NULL;
    int code=0;
    Napi::Value* jsobj_dstCn = NULL;
    int dstCn=0;

    const char* keywords[] = { "src", "code", "dst", "dstCn", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:demosaicing", (char**)keywords, &jsobj_src, &jsobj_code, &jsobj_dst, &jsobj_dstCn) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_code, code, ArgInfo("code", 0)) &&
        jsopencv_to_safe(jsobj_dstCn, dstCn, ArgInfo("dstCn", 0)))
    {
        ERRWRAP2_NAPI(info, cv::demosaicing(src, dst, code, dstCn));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "demosaicing");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_denoise_TVL1(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_observations = NULL;
    vector_Mat observations;
    Napi::Value* jsobj_result = NULL;
    Mat result;
    Napi::Value* jsobj_lambda = NULL;
    double lambda=1.0;
    Napi::Value* jsobj_niters = NULL;
    int niters=30;

    const char* keywords[] = { "observations", "result", "lambda_", "niters", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:denoise_TVL1", (char**)keywords, &jsobj_observations, &jsobj_result, &jsobj_lambda, &jsobj_niters) &&
        jsopencv_to_safe(jsobj_observations, observations, ArgInfo("observations", 0)) &&
        jsopencv_to_safe(jsobj_result, result, ArgInfo("result", 0)) &&
        jsopencv_to_safe(jsobj_lambda, lambda, ArgInfo("lambda", 0)) &&
        jsopencv_to_safe(jsobj_niters, niters, ArgInfo("niters", 0)))
    {
        ERRWRAP2_NAPI(info, cv::denoise_TVL1(observations, result, lambda, niters));
        return info.Env().Null();;
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_destroyAllWindows(const Napi::CallbackInfo &info)
{
    using namespace cv;


    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, cv::destroyAllWindows());
        return info.Env().Null();;
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_destroyWindow(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_winname = NULL;
    String winname;

    const char* keywords[] = { "winname", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:destroyWindow", (char**)keywords, &jsobj_winname) &&
        jsopencv_to_safe(jsobj_winname, winname, ArgInfo("winname", 0)))
    {
        ERRWRAP2_NAPI(info, cv::destroyWindow(winname));
        return info.Env().Null();;
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_detailEnhance(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_sigma_s = NULL;
    float sigma_s=10;
    Napi::Value* jsobj_sigma_r = NULL;
    float sigma_r=0.15f;

    const char* keywords[] = { "src", "dst", "sigma_s", "sigma_r", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOO:detailEnhance", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_sigma_s, &jsobj_sigma_r) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_sigma_s, sigma_s, ArgInfo("sigma_s", 0)) &&
        jsopencv_to_safe(jsobj_sigma_r, sigma_r, ArgInfo("sigma_r", 0)))
    {
        ERRWRAP2_NAPI(info, cv::detailEnhance(src, dst, sigma_s, sigma_r));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_sigma_s = NULL;
    float sigma_s=10;
    Napi::Value* jsobj_sigma_r = NULL;
    float sigma_r=0.15f;

    const char* keywords[] = { "src", "dst", "sigma_s", "sigma_r", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOO:detailEnhance", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_sigma_s, &jsobj_sigma_r) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_sigma_s, sigma_s, ArgInfo("sigma_s", 0)) &&
        jsopencv_to_safe(jsobj_sigma_r, sigma_r, ArgInfo("sigma_r", 0)))
    {
        ERRWRAP2_NAPI(info, cv::detailEnhance(src, dst, sigma_s, sigma_r));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "detailEnhance");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_determinant(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_mtx = NULL;
    Mat mtx;
    double retval;

    const char* keywords[] = { "mtx", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:determinant", (char**)keywords, &jsobj_mtx) &&
        jsopencv_to_safe(jsobj_mtx, mtx, ArgInfo("mtx", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::determinant(mtx));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_mtx = NULL;
    UMat mtx;
    double retval;

    const char* keywords[] = { "mtx", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:determinant", (char**)keywords, &jsobj_mtx) &&
        jsopencv_to_safe(jsobj_mtx, mtx, ArgInfo("mtx", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::determinant(mtx));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "determinant");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_dft(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;
    Napi::Value* jsobj_nonzeroRows = NULL;
    int nonzeroRows=0;

    const char* keywords[] = { "src", "dst", "flags", "nonzeroRows", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOO:dft", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_flags, &jsobj_nonzeroRows) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_nonzeroRows, nonzeroRows, ArgInfo("nonzeroRows", 0)))
    {
        ERRWRAP2_NAPI(info, cv::dft(src, dst, flags, nonzeroRows));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;
    Napi::Value* jsobj_nonzeroRows = NULL;
    int nonzeroRows=0;

    const char* keywords[] = { "src", "dst", "flags", "nonzeroRows", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOO:dft", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_flags, &jsobj_nonzeroRows) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_nonzeroRows, nonzeroRows, ArgInfo("nonzeroRows", 0)))
    {
        ERRWRAP2_NAPI(info, cv::dft(src, dst, flags, nonzeroRows));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "dft");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_dilate(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_kernel = NULL;
    Mat kernel;
    Napi::Value* jsobj_anchor = NULL;
    Point anchor=Point(-1,-1);
    Napi::Value* jsobj_iterations = NULL;
    int iterations=1;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_CONSTANT;
    Napi::Value* jsobj_borderValue = NULL;
    Scalar borderValue=morphologyDefaultBorderValue();

    const char* keywords[] = { "src", "kernel", "dst", "anchor", "iterations", "borderType", "borderValue", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOOOO:dilate", (char**)keywords, &jsobj_src, &jsobj_kernel, &jsobj_dst, &jsobj_anchor, &jsobj_iterations, &jsobj_borderType, &jsobj_borderValue) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_kernel, kernel, ArgInfo("kernel", 0)) &&
        jsopencv_to_safe(jsobj_anchor, anchor, ArgInfo("anchor", 0)) &&
        jsopencv_to_safe(jsobj_iterations, iterations, ArgInfo("iterations", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)) &&
        jsopencv_to_safe(jsobj_borderValue, borderValue, ArgInfo("borderValue", 0)))
    {
        ERRWRAP2_NAPI(info, cv::dilate(src, dst, kernel, anchor, iterations, borderType, borderValue));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_kernel = NULL;
    UMat kernel;
    Napi::Value* jsobj_anchor = NULL;
    Point anchor=Point(-1,-1);
    Napi::Value* jsobj_iterations = NULL;
    int iterations=1;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_CONSTANT;
    Napi::Value* jsobj_borderValue = NULL;
    Scalar borderValue=morphologyDefaultBorderValue();

    const char* keywords[] = { "src", "kernel", "dst", "anchor", "iterations", "borderType", "borderValue", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOOOO:dilate", (char**)keywords, &jsobj_src, &jsobj_kernel, &jsobj_dst, &jsobj_anchor, &jsobj_iterations, &jsobj_borderType, &jsobj_borderValue) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_kernel, kernel, ArgInfo("kernel", 0)) &&
        jsopencv_to_safe(jsobj_anchor, anchor, ArgInfo("anchor", 0)) &&
        jsopencv_to_safe(jsobj_iterations, iterations, ArgInfo("iterations", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)) &&
        jsopencv_to_safe(jsobj_borderValue, borderValue, ArgInfo("borderValue", 0)))
    {
        ERRWRAP2_NAPI(info, cv::dilate(src, dst, kernel, anchor, iterations, borderType, borderValue));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "dilate");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_displayOverlay(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_winname = NULL;
    String winname;
    Napi::Value* jsobj_text = NULL;
    String text;
    Napi::Value* jsobj_delayms = NULL;
    int delayms=0;

    const char* keywords[] = { "winname", "text", "delayms", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:displayOverlay", (char**)keywords, &jsobj_winname, &jsobj_text, &jsobj_delayms) &&
        jsopencv_to_safe(jsobj_winname, winname, ArgInfo("winname", 0)) &&
        jsopencv_to_safe(jsobj_text, text, ArgInfo("text", 0)) &&
        jsopencv_to_safe(jsobj_delayms, delayms, ArgInfo("delayms", 0)))
    {
        ERRWRAP2_NAPI(info, cv::displayOverlay(winname, text, delayms));
        return info.Env().Null();;
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_displayStatusBar(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_winname = NULL;
    String winname;
    Napi::Value* jsobj_text = NULL;
    String text;
    Napi::Value* jsobj_delayms = NULL;
    int delayms=0;

    const char* keywords[] = { "winname", "text", "delayms", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:displayStatusBar", (char**)keywords, &jsobj_winname, &jsobj_text, &jsobj_delayms) &&
        jsopencv_to_safe(jsobj_winname, winname, ArgInfo("winname", 0)) &&
        jsopencv_to_safe(jsobj_text, text, ArgInfo("text", 0)) &&
        jsopencv_to_safe(jsobj_delayms, delayms, ArgInfo("delayms", 0)))
    {
        ERRWRAP2_NAPI(info, cv::displayStatusBar(winname, text, delayms));
        return info.Env().Null();;
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_distanceTransform(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_distanceType = NULL;
    int distanceType=0;
    Napi::Value* jsobj_maskSize = NULL;
    int maskSize=0;
    Napi::Value* jsobj_dstType = NULL;
    int dstType=CV_32F;

    const char* keywords[] = { "src", "distanceType", "maskSize", "dst", "dstType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OO:distanceTransform", (char**)keywords, &jsobj_src, &jsobj_distanceType, &jsobj_maskSize, &jsobj_dst, &jsobj_dstType) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_distanceType, distanceType, ArgInfo("distanceType", 0)) &&
        jsopencv_to_safe(jsobj_maskSize, maskSize, ArgInfo("maskSize", 0)) &&
        jsopencv_to_safe(jsobj_dstType, dstType, ArgInfo("dstType", 0)))
    {
        ERRWRAP2_NAPI(info, cv::distanceTransform(src, dst, distanceType, maskSize, dstType));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_distanceType = NULL;
    int distanceType=0;
    Napi::Value* jsobj_maskSize = NULL;
    int maskSize=0;
    Napi::Value* jsobj_dstType = NULL;
    int dstType=CV_32F;

    const char* keywords[] = { "src", "distanceType", "maskSize", "dst", "dstType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OO:distanceTransform", (char**)keywords, &jsobj_src, &jsobj_distanceType, &jsobj_maskSize, &jsobj_dst, &jsobj_dstType) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_distanceType, distanceType, ArgInfo("distanceType", 0)) &&
        jsopencv_to_safe(jsobj_maskSize, maskSize, ArgInfo("maskSize", 0)) &&
        jsopencv_to_safe(jsobj_dstType, dstType, ArgInfo("dstType", 0)))
    {
        ERRWRAP2_NAPI(info, cv::distanceTransform(src, dst, distanceType, maskSize, dstType));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "distanceTransform");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_distanceTransformWithLabels(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_labels = NULL;
    Mat labels;
    Napi::Value* jsobj_distanceType = NULL;
    int distanceType=0;
    Napi::Value* jsobj_maskSize = NULL;
    int maskSize=0;
    Napi::Value* jsobj_labelType = NULL;
    int labelType=DIST_LABEL_CCOMP;

    const char* keywords[] = { "src", "distanceType", "maskSize", "dst", "labels", "labelType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOO:distanceTransformWithLabels", (char**)keywords, &jsobj_src, &jsobj_distanceType, &jsobj_maskSize, &jsobj_dst, &jsobj_labels, &jsobj_labelType) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_labels, labels, ArgInfo("labels", 1)) &&
        jsopencv_to_safe(jsobj_distanceType, distanceType, ArgInfo("distanceType", 0)) &&
        jsopencv_to_safe(jsobj_maskSize, maskSize, ArgInfo("maskSize", 0)) &&
        jsopencv_to_safe(jsobj_labelType, labelType, ArgInfo("labelType", 0)))
    {
        ERRWRAP2_NAPI(info, cv::distanceTransform(src, dst, labels, distanceType, maskSize, labelType));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, dst), jsopencv_from(info, labels));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_labels = NULL;
    UMat labels;
    Napi::Value* jsobj_distanceType = NULL;
    int distanceType=0;
    Napi::Value* jsobj_maskSize = NULL;
    int maskSize=0;
    Napi::Value* jsobj_labelType = NULL;
    int labelType=DIST_LABEL_CCOMP;

    const char* keywords[] = { "src", "distanceType", "maskSize", "dst", "labels", "labelType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOO:distanceTransformWithLabels", (char**)keywords, &jsobj_src, &jsobj_distanceType, &jsobj_maskSize, &jsobj_dst, &jsobj_labels, &jsobj_labelType) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_labels, labels, ArgInfo("labels", 1)) &&
        jsopencv_to_safe(jsobj_distanceType, distanceType, ArgInfo("distanceType", 0)) &&
        jsopencv_to_safe(jsobj_maskSize, maskSize, ArgInfo("maskSize", 0)) &&
        jsopencv_to_safe(jsobj_labelType, labelType, ArgInfo("labelType", 0)))
    {
        ERRWRAP2_NAPI(info, cv::distanceTransform(src, dst, labels, distanceType, maskSize, labelType));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, dst), jsopencv_from(info, labels));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "distanceTransformWithLabels");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_divSpectrums(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_a = NULL;
    Mat a;
    Napi::Value* jsobj_b = NULL;
    Mat b;
    Napi::Value* jsobj_c = NULL;
    Mat c;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;
    Napi::Value* jsobj_conjB = NULL;
    bool conjB=false;

    const char* keywords[] = { "a", "b", "flags", "c", "conjB", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OO:divSpectrums", (char**)keywords, &jsobj_a, &jsobj_b, &jsobj_flags, &jsobj_c, &jsobj_conjB) &&
        jsopencv_to_safe(jsobj_a, a, ArgInfo("a", 0)) &&
        jsopencv_to_safe(jsobj_b, b, ArgInfo("b", 0)) &&
        jsopencv_to_safe(jsobj_c, c, ArgInfo("c", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_conjB, conjB, ArgInfo("conjB", 0)))
    {
        ERRWRAP2_NAPI(info, cv::divSpectrums(a, b, c, flags, conjB));
        return jsopencv_from(info, c);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_a = NULL;
    UMat a;
    Napi::Value* jsobj_b = NULL;
    UMat b;
    Napi::Value* jsobj_c = NULL;
    UMat c;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;
    Napi::Value* jsobj_conjB = NULL;
    bool conjB=false;

    const char* keywords[] = { "a", "b", "flags", "c", "conjB", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OO:divSpectrums", (char**)keywords, &jsobj_a, &jsobj_b, &jsobj_flags, &jsobj_c, &jsobj_conjB) &&
        jsopencv_to_safe(jsobj_a, a, ArgInfo("a", 0)) &&
        jsopencv_to_safe(jsobj_b, b, ArgInfo("b", 0)) &&
        jsopencv_to_safe(jsobj_c, c, ArgInfo("c", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_conjB, conjB, ArgInfo("conjB", 0)))
    {
        ERRWRAP2_NAPI(info, cv::divSpectrums(a, b, c, flags, conjB));
        return jsopencv_from(info, c);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "divSpectrums");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_divide(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(4);

    {
    Napi::Value* jsobj_src1 = NULL;
    Mat src1;
    Napi::Value* jsobj_src2 = NULL;
    Mat src2;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_scale = NULL;
    double scale=1;
    Napi::Value* jsobj_dtype = NULL;
    int dtype=-1;

    const char* keywords[] = { "src1", "src2", "dst", "scale", "dtype", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOO:divide", (char**)keywords, &jsobj_src1, &jsobj_src2, &jsobj_dst, &jsobj_scale, &jsobj_dtype) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_scale, scale, ArgInfo("scale", 0)) &&
        jsopencv_to_safe(jsobj_dtype, dtype, ArgInfo("dtype", 0)))
    {
        ERRWRAP2_NAPI(info, cv::divide(src1, src2, dst, scale, dtype));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src1 = NULL;
    UMat src1;
    Napi::Value* jsobj_src2 = NULL;
    UMat src2;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_scale = NULL;
    double scale=1;
    Napi::Value* jsobj_dtype = NULL;
    int dtype=-1;

    const char* keywords[] = { "src1", "src2", "dst", "scale", "dtype", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOO:divide", (char**)keywords, &jsobj_src1, &jsobj_src2, &jsobj_dst, &jsobj_scale, &jsobj_dtype) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_scale, scale, ArgInfo("scale", 0)) &&
        jsopencv_to_safe(jsobj_dtype, dtype, ArgInfo("dtype", 0)))
    {
        ERRWRAP2_NAPI(info, cv::divide(src1, src2, dst, scale, dtype));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_scale = NULL;
    double scale=0;
    Napi::Value* jsobj_src2 = NULL;
    Mat src2;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_dtype = NULL;
    int dtype=-1;

    const char* keywords[] = { "scale", "src2", "dst", "dtype", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:divide", (char**)keywords, &jsobj_scale, &jsobj_src2, &jsobj_dst, &jsobj_dtype) &&
        jsopencv_to_safe(jsobj_scale, scale, ArgInfo("scale", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_dtype, dtype, ArgInfo("dtype", 0)))
    {
        ERRWRAP2_NAPI(info, cv::divide(scale, src2, dst, dtype));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_scale = NULL;
    double scale=0;
    Napi::Value* jsobj_src2 = NULL;
    UMat src2;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_dtype = NULL;
    int dtype=-1;

    const char* keywords[] = { "scale", "src2", "dst", "dtype", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:divide", (char**)keywords, &jsobj_scale, &jsobj_src2, &jsobj_dst, &jsobj_dtype) &&
        jsopencv_to_safe(jsobj_scale, scale, ArgInfo("scale", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_dtype, dtype, ArgInfo("dtype", 0)))
    {
        ERRWRAP2_NAPI(info, cv::divide(scale, src2, dst, dtype));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "divide");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_drawChessboardCorners(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_image = NULL;
    Mat image;
    Napi::Value* jsobj_patternSize = NULL;
    Size patternSize;
    Napi::Value* jsobj_corners = NULL;
    Mat corners;
    Napi::Value* jsobj_patternWasFound = NULL;
    bool patternWasFound=0;

    const char* keywords[] = { "image", "patternSize", "corners", "patternWasFound", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO:drawChessboardCorners", (char**)keywords, &jsobj_image, &jsobj_patternSize, &jsobj_corners, &jsobj_patternWasFound) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 1)) &&
        jsopencv_to_safe(jsobj_patternSize, patternSize, ArgInfo("patternSize", 0)) &&
        jsopencv_to_safe(jsobj_corners, corners, ArgInfo("corners", 0)) &&
        jsopencv_to_safe(jsobj_patternWasFound, patternWasFound, ArgInfo("patternWasFound", 0)))
    {
        ERRWRAP2_NAPI(info, cv::drawChessboardCorners(image, patternSize, corners, patternWasFound));
        return jsopencv_from(info, image);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_image = NULL;
    UMat image;
    Napi::Value* jsobj_patternSize = NULL;
    Size patternSize;
    Napi::Value* jsobj_corners = NULL;
    UMat corners;
    Napi::Value* jsobj_patternWasFound = NULL;
    bool patternWasFound=0;

    const char* keywords[] = { "image", "patternSize", "corners", "patternWasFound", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO:drawChessboardCorners", (char**)keywords, &jsobj_image, &jsobj_patternSize, &jsobj_corners, &jsobj_patternWasFound) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 1)) &&
        jsopencv_to_safe(jsobj_patternSize, patternSize, ArgInfo("patternSize", 0)) &&
        jsopencv_to_safe(jsobj_corners, corners, ArgInfo("corners", 0)) &&
        jsopencv_to_safe(jsobj_patternWasFound, patternWasFound, ArgInfo("patternWasFound", 0)))
    {
        ERRWRAP2_NAPI(info, cv::drawChessboardCorners(image, patternSize, corners, patternWasFound));
        return jsopencv_from(info, image);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "drawChessboardCorners");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_drawContours(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_image = NULL;
    Mat image;
    Napi::Value* jsobj_contours = NULL;
    vector_Mat contours;
    Napi::Value* jsobj_contourIdx = NULL;
    int contourIdx=0;
    Napi::Value* jsobj_color = NULL;
    Scalar color;
    Napi::Value* jsobj_thickness = NULL;
    int thickness=1;
    Napi::Value* jsobj_lineType = NULL;
    int lineType=LINE_8;
    Napi::Value* jsobj_hierarchy = NULL;
    Mat hierarchy;
    Napi::Value* jsobj_maxLevel = NULL;
    int maxLevel=INT_MAX;
    Napi::Value* jsobj_offset = NULL;
    Point offset;

    const char* keywords[] = { "image", "contours", "contourIdx", "color", "thickness", "lineType", "hierarchy", "maxLevel", "offset", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOOOO:drawContours", (char**)keywords, &jsobj_image, &jsobj_contours, &jsobj_contourIdx, &jsobj_color, &jsobj_thickness, &jsobj_lineType, &jsobj_hierarchy, &jsobj_maxLevel, &jsobj_offset) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 1)) &&
        jsopencv_to_safe(jsobj_contours, contours, ArgInfo("contours", 0)) &&
        jsopencv_to_safe(jsobj_contourIdx, contourIdx, ArgInfo("contourIdx", 0)) &&
        jsopencv_to_safe(jsobj_color, color, ArgInfo("color", 0)) &&
        jsopencv_to_safe(jsobj_thickness, thickness, ArgInfo("thickness", 0)) &&
        jsopencv_to_safe(jsobj_lineType, lineType, ArgInfo("lineType", 0)) &&
        jsopencv_to_safe(jsobj_hierarchy, hierarchy, ArgInfo("hierarchy", 0)) &&
        jsopencv_to_safe(jsobj_maxLevel, maxLevel, ArgInfo("maxLevel", 0)) &&
        jsopencv_to_safe(jsobj_offset, offset, ArgInfo("offset", 0)))
    {
        ERRWRAP2_NAPI(info, cv::drawContours(image, contours, contourIdx, color, thickness, lineType, hierarchy, maxLevel, offset));
        return jsopencv_from(info, image);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_image = NULL;
    UMat image;
    Napi::Value* jsobj_contours = NULL;
    vector_UMat contours;
    Napi::Value* jsobj_contourIdx = NULL;
    int contourIdx=0;
    Napi::Value* jsobj_color = NULL;
    Scalar color;
    Napi::Value* jsobj_thickness = NULL;
    int thickness=1;
    Napi::Value* jsobj_lineType = NULL;
    int lineType=LINE_8;
    Napi::Value* jsobj_hierarchy = NULL;
    UMat hierarchy;
    Napi::Value* jsobj_maxLevel = NULL;
    int maxLevel=INT_MAX;
    Napi::Value* jsobj_offset = NULL;
    Point offset;

    const char* keywords[] = { "image", "contours", "contourIdx", "color", "thickness", "lineType", "hierarchy", "maxLevel", "offset", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOOOO:drawContours", (char**)keywords, &jsobj_image, &jsobj_contours, &jsobj_contourIdx, &jsobj_color, &jsobj_thickness, &jsobj_lineType, &jsobj_hierarchy, &jsobj_maxLevel, &jsobj_offset) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 1)) &&
        jsopencv_to_safe(jsobj_contours, contours, ArgInfo("contours", 0)) &&
        jsopencv_to_safe(jsobj_contourIdx, contourIdx, ArgInfo("contourIdx", 0)) &&
        jsopencv_to_safe(jsobj_color, color, ArgInfo("color", 0)) &&
        jsopencv_to_safe(jsobj_thickness, thickness, ArgInfo("thickness", 0)) &&
        jsopencv_to_safe(jsobj_lineType, lineType, ArgInfo("lineType", 0)) &&
        jsopencv_to_safe(jsobj_hierarchy, hierarchy, ArgInfo("hierarchy", 0)) &&
        jsopencv_to_safe(jsobj_maxLevel, maxLevel, ArgInfo("maxLevel", 0)) &&
        jsopencv_to_safe(jsobj_offset, offset, ArgInfo("offset", 0)))
    {
        ERRWRAP2_NAPI(info, cv::drawContours(image, contours, contourIdx, color, thickness, lineType, hierarchy, maxLevel, offset));
        return jsopencv_from(info, image);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "drawContours");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_drawFrameAxes(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_image = NULL;
    Mat image;
    Napi::Value* jsobj_cameraMatrix = NULL;
    Mat cameraMatrix;
    Napi::Value* jsobj_distCoeffs = NULL;
    Mat distCoeffs;
    Napi::Value* jsobj_rvec = NULL;
    Mat rvec;
    Napi::Value* jsobj_tvec = NULL;
    Mat tvec;
    Napi::Value* jsobj_length = NULL;
    float length=0.f;
    Napi::Value* jsobj_thickness = NULL;
    int thickness=3;

    const char* keywords[] = { "image", "cameraMatrix", "distCoeffs", "rvec", "tvec", "length", "thickness", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOO|O:drawFrameAxes", (char**)keywords, &jsobj_image, &jsobj_cameraMatrix, &jsobj_distCoeffs, &jsobj_rvec, &jsobj_tvec, &jsobj_length, &jsobj_thickness) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 1)) &&
        jsopencv_to_safe(jsobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 0)) &&
        jsopencv_to_safe(jsobj_distCoeffs, distCoeffs, ArgInfo("distCoeffs", 0)) &&
        jsopencv_to_safe(jsobj_rvec, rvec, ArgInfo("rvec", 0)) &&
        jsopencv_to_safe(jsobj_tvec, tvec, ArgInfo("tvec", 0)) &&
        jsopencv_to_safe(jsobj_length, length, ArgInfo("length", 0)) &&
        jsopencv_to_safe(jsobj_thickness, thickness, ArgInfo("thickness", 0)))
    {
        ERRWRAP2_NAPI(info, cv::drawFrameAxes(image, cameraMatrix, distCoeffs, rvec, tvec, length, thickness));
        return jsopencv_from(info, image);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_image = NULL;
    UMat image;
    Napi::Value* jsobj_cameraMatrix = NULL;
    UMat cameraMatrix;
    Napi::Value* jsobj_distCoeffs = NULL;
    UMat distCoeffs;
    Napi::Value* jsobj_rvec = NULL;
    UMat rvec;
    Napi::Value* jsobj_tvec = NULL;
    UMat tvec;
    Napi::Value* jsobj_length = NULL;
    float length=0.f;
    Napi::Value* jsobj_thickness = NULL;
    int thickness=3;

    const char* keywords[] = { "image", "cameraMatrix", "distCoeffs", "rvec", "tvec", "length", "thickness", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOO|O:drawFrameAxes", (char**)keywords, &jsobj_image, &jsobj_cameraMatrix, &jsobj_distCoeffs, &jsobj_rvec, &jsobj_tvec, &jsobj_length, &jsobj_thickness) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 1)) &&
        jsopencv_to_safe(jsobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 0)) &&
        jsopencv_to_safe(jsobj_distCoeffs, distCoeffs, ArgInfo("distCoeffs", 0)) &&
        jsopencv_to_safe(jsobj_rvec, rvec, ArgInfo("rvec", 0)) &&
        jsopencv_to_safe(jsobj_tvec, tvec, ArgInfo("tvec", 0)) &&
        jsopencv_to_safe(jsobj_length, length, ArgInfo("length", 0)) &&
        jsopencv_to_safe(jsobj_thickness, thickness, ArgInfo("thickness", 0)))
    {
        ERRWRAP2_NAPI(info, cv::drawFrameAxes(image, cameraMatrix, distCoeffs, rvec, tvec, length, thickness));
        return jsopencv_from(info, image);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "drawFrameAxes");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_drawKeypoints(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_image = NULL;
    Mat image;
    Napi::Value* jsobj_keypoints = NULL;
    vector_KeyPoint keypoints;
    Napi::Value* jsobj_outImage = NULL;
    Mat outImage;
    Napi::Value* jsobj_color = NULL;
    Scalar color=Scalar::all(-1);
    Napi::Value* jsobj_flags = NULL;
    DrawMatchesFlags flags=DrawMatchesFlags::DEFAULT;

    const char* keywords[] = { "image", "keypoints", "outImage", "color", "flags", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OO:drawKeypoints", (char**)keywords, &jsobj_image, &jsobj_keypoints, &jsobj_outImage, &jsobj_color, &jsobj_flags) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_keypoints, keypoints, ArgInfo("keypoints", 0)) &&
        jsopencv_to_safe(jsobj_outImage, outImage, ArgInfo("outImage", 1)) &&
        jsopencv_to_safe(jsobj_color, color, ArgInfo("color", 0)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, cv::drawKeypoints(image, keypoints, outImage, color, flags));
        return jsopencv_from(info, outImage);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_image = NULL;
    UMat image;
    Napi::Value* jsobj_keypoints = NULL;
    vector_KeyPoint keypoints;
    Napi::Value* jsobj_outImage = NULL;
    UMat outImage;
    Napi::Value* jsobj_color = NULL;
    Scalar color=Scalar::all(-1);
    Napi::Value* jsobj_flags = NULL;
    DrawMatchesFlags flags=DrawMatchesFlags::DEFAULT;

    const char* keywords[] = { "image", "keypoints", "outImage", "color", "flags", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OO:drawKeypoints", (char**)keywords, &jsobj_image, &jsobj_keypoints, &jsobj_outImage, &jsobj_color, &jsobj_flags) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_keypoints, keypoints, ArgInfo("keypoints", 0)) &&
        jsopencv_to_safe(jsobj_outImage, outImage, ArgInfo("outImage", 1)) &&
        jsopencv_to_safe(jsobj_color, color, ArgInfo("color", 0)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, cv::drawKeypoints(image, keypoints, outImage, color, flags));
        return jsopencv_from(info, outImage);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "drawKeypoints");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_drawMarker(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_img = NULL;
    Mat img;
    Napi::Value* jsobj_position = NULL;
    Point position;
    Napi::Value* jsobj_color = NULL;
    Scalar color;
    Napi::Value* jsobj_markerType = NULL;
    int markerType=MARKER_CROSS;
    Napi::Value* jsobj_markerSize = NULL;
    int markerSize=20;
    Napi::Value* jsobj_thickness = NULL;
    int thickness=1;
    Napi::Value* jsobj_line_type = NULL;
    int line_type=8;

    const char* keywords[] = { "img", "position", "color", "markerType", "markerSize", "thickness", "line_type", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOOO:drawMarker", (char**)keywords, &jsobj_img, &jsobj_position, &jsobj_color, &jsobj_markerType, &jsobj_markerSize, &jsobj_thickness, &jsobj_line_type) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 1)) &&
        jsopencv_to_safe(jsobj_position, position, ArgInfo("position", 0)) &&
        jsopencv_to_safe(jsobj_color, color, ArgInfo("color", 0)) &&
        jsopencv_to_safe(jsobj_markerType, markerType, ArgInfo("markerType", 0)) &&
        jsopencv_to_safe(jsobj_markerSize, markerSize, ArgInfo("markerSize", 0)) &&
        jsopencv_to_safe(jsobj_thickness, thickness, ArgInfo("thickness", 0)) &&
        jsopencv_to_safe(jsobj_line_type, line_type, ArgInfo("line_type", 0)))
    {
        ERRWRAP2_NAPI(info, cv::drawMarker(img, position, color, markerType, markerSize, thickness, line_type));
        return jsopencv_from(info, img);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_img = NULL;
    UMat img;
    Napi::Value* jsobj_position = NULL;
    Point position;
    Napi::Value* jsobj_color = NULL;
    Scalar color;
    Napi::Value* jsobj_markerType = NULL;
    int markerType=MARKER_CROSS;
    Napi::Value* jsobj_markerSize = NULL;
    int markerSize=20;
    Napi::Value* jsobj_thickness = NULL;
    int thickness=1;
    Napi::Value* jsobj_line_type = NULL;
    int line_type=8;

    const char* keywords[] = { "img", "position", "color", "markerType", "markerSize", "thickness", "line_type", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOOO:drawMarker", (char**)keywords, &jsobj_img, &jsobj_position, &jsobj_color, &jsobj_markerType, &jsobj_markerSize, &jsobj_thickness, &jsobj_line_type) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 1)) &&
        jsopencv_to_safe(jsobj_position, position, ArgInfo("position", 0)) &&
        jsopencv_to_safe(jsobj_color, color, ArgInfo("color", 0)) &&
        jsopencv_to_safe(jsobj_markerType, markerType, ArgInfo("markerType", 0)) &&
        jsopencv_to_safe(jsobj_markerSize, markerSize, ArgInfo("markerSize", 0)) &&
        jsopencv_to_safe(jsobj_thickness, thickness, ArgInfo("thickness", 0)) &&
        jsopencv_to_safe(jsobj_line_type, line_type, ArgInfo("line_type", 0)))
    {
        ERRWRAP2_NAPI(info, cv::drawMarker(img, position, color, markerType, markerSize, thickness, line_type));
        return jsopencv_from(info, img);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "drawMarker");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_drawMatches(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(4);

    {
    Napi::Value* jsobj_img1 = NULL;
    Mat img1;
    Napi::Value* jsobj_keypoints1 = NULL;
    vector_KeyPoint keypoints1;
    Napi::Value* jsobj_img2 = NULL;
    Mat img2;
    Napi::Value* jsobj_keypoints2 = NULL;
    vector_KeyPoint keypoints2;
    Napi::Value* jsobj_matches1to2 = NULL;
    vector_DMatch matches1to2;
    Napi::Value* jsobj_outImg = NULL;
    Mat outImg;
    Napi::Value* jsobj_matchColor = NULL;
    Scalar matchColor=Scalar::all(-1);
    Napi::Value* jsobj_singlePointColor = NULL;
    Scalar singlePointColor=Scalar::all(-1);
    Napi::Value* jsobj_matchesMask = NULL;
    vector_char matchesMask=std::vector<char>();
    Napi::Value* jsobj_flags = NULL;
    DrawMatchesFlags flags=DrawMatchesFlags::DEFAULT;

    const char* keywords[] = { "img1", "keypoints1", "img2", "keypoints2", "matches1to2", "outImg", "matchColor", "singlePointColor", "matchesMask", "flags", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOO|OOOO:drawMatches", (char**)keywords, &jsobj_img1, &jsobj_keypoints1, &jsobj_img2, &jsobj_keypoints2, &jsobj_matches1to2, &jsobj_outImg, &jsobj_matchColor, &jsobj_singlePointColor, &jsobj_matchesMask, &jsobj_flags) &&
        jsopencv_to_safe(jsobj_img1, img1, ArgInfo("img1", 0)) &&
        jsopencv_to_safe(jsobj_keypoints1, keypoints1, ArgInfo("keypoints1", 0)) &&
        jsopencv_to_safe(jsobj_img2, img2, ArgInfo("img2", 0)) &&
        jsopencv_to_safe(jsobj_keypoints2, keypoints2, ArgInfo("keypoints2", 0)) &&
        jsopencv_to_safe(jsobj_matches1to2, matches1to2, ArgInfo("matches1to2", 0)) &&
        jsopencv_to_safe(jsobj_outImg, outImg, ArgInfo("outImg", 1)) &&
        jsopencv_to_safe(jsobj_matchColor, matchColor, ArgInfo("matchColor", 0)) &&
        jsopencv_to_safe(jsobj_singlePointColor, singlePointColor, ArgInfo("singlePointColor", 0)) &&
        jsopencv_to_safe(jsobj_matchesMask, matchesMask, ArgInfo("matchesMask", 0)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, cv::drawMatches(img1, keypoints1, img2, keypoints2, matches1to2, outImg, matchColor, singlePointColor, matchesMask, flags));
        return jsopencv_from(info, outImg);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_img1 = NULL;
    UMat img1;
    Napi::Value* jsobj_keypoints1 = NULL;
    vector_KeyPoint keypoints1;
    Napi::Value* jsobj_img2 = NULL;
    UMat img2;
    Napi::Value* jsobj_keypoints2 = NULL;
    vector_KeyPoint keypoints2;
    Napi::Value* jsobj_matches1to2 = NULL;
    vector_DMatch matches1to2;
    Napi::Value* jsobj_outImg = NULL;
    UMat outImg;
    Napi::Value* jsobj_matchColor = NULL;
    Scalar matchColor=Scalar::all(-1);
    Napi::Value* jsobj_singlePointColor = NULL;
    Scalar singlePointColor=Scalar::all(-1);
    Napi::Value* jsobj_matchesMask = NULL;
    vector_char matchesMask=std::vector<char>();
    Napi::Value* jsobj_flags = NULL;
    DrawMatchesFlags flags=DrawMatchesFlags::DEFAULT;

    const char* keywords[] = { "img1", "keypoints1", "img2", "keypoints2", "matches1to2", "outImg", "matchColor", "singlePointColor", "matchesMask", "flags", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOO|OOOO:drawMatches", (char**)keywords, &jsobj_img1, &jsobj_keypoints1, &jsobj_img2, &jsobj_keypoints2, &jsobj_matches1to2, &jsobj_outImg, &jsobj_matchColor, &jsobj_singlePointColor, &jsobj_matchesMask, &jsobj_flags) &&
        jsopencv_to_safe(jsobj_img1, img1, ArgInfo("img1", 0)) &&
        jsopencv_to_safe(jsobj_keypoints1, keypoints1, ArgInfo("keypoints1", 0)) &&
        jsopencv_to_safe(jsobj_img2, img2, ArgInfo("img2", 0)) &&
        jsopencv_to_safe(jsobj_keypoints2, keypoints2, ArgInfo("keypoints2", 0)) &&
        jsopencv_to_safe(jsobj_matches1to2, matches1to2, ArgInfo("matches1to2", 0)) &&
        jsopencv_to_safe(jsobj_outImg, outImg, ArgInfo("outImg", 1)) &&
        jsopencv_to_safe(jsobj_matchColor, matchColor, ArgInfo("matchColor", 0)) &&
        jsopencv_to_safe(jsobj_singlePointColor, singlePointColor, ArgInfo("singlePointColor", 0)) &&
        jsopencv_to_safe(jsobj_matchesMask, matchesMask, ArgInfo("matchesMask", 0)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, cv::drawMatches(img1, keypoints1, img2, keypoints2, matches1to2, outImg, matchColor, singlePointColor, matchesMask, flags));
        return jsopencv_from(info, outImg);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_img1 = NULL;
    Mat img1;
    Napi::Value* jsobj_keypoints1 = NULL;
    vector_KeyPoint keypoints1;
    Napi::Value* jsobj_img2 = NULL;
    Mat img2;
    Napi::Value* jsobj_keypoints2 = NULL;
    vector_KeyPoint keypoints2;
    Napi::Value* jsobj_matches1to2 = NULL;
    vector_DMatch matches1to2;
    Napi::Value* jsobj_outImg = NULL;
    Mat outImg;
    Napi::Value* jsobj_matchesThickness = NULL;
    int matchesThickness=0;
    Napi::Value* jsobj_matchColor = NULL;
    Scalar matchColor=Scalar::all(-1);
    Napi::Value* jsobj_singlePointColor = NULL;
    Scalar singlePointColor=Scalar::all(-1);
    Napi::Value* jsobj_matchesMask = NULL;
    vector_char matchesMask=std::vector<char>();
    Napi::Value* jsobj_flags = NULL;
    DrawMatchesFlags flags=DrawMatchesFlags::DEFAULT;

    const char* keywords[] = { "img1", "keypoints1", "img2", "keypoints2", "matches1to2", "outImg", "matchesThickness", "matchColor", "singlePointColor", "matchesMask", "flags", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOOO|OOOO:drawMatches", (char**)keywords, &jsobj_img1, &jsobj_keypoints1, &jsobj_img2, &jsobj_keypoints2, &jsobj_matches1to2, &jsobj_outImg, &jsobj_matchesThickness, &jsobj_matchColor, &jsobj_singlePointColor, &jsobj_matchesMask, &jsobj_flags) &&
        jsopencv_to_safe(jsobj_img1, img1, ArgInfo("img1", 0)) &&
        jsopencv_to_safe(jsobj_keypoints1, keypoints1, ArgInfo("keypoints1", 0)) &&
        jsopencv_to_safe(jsobj_img2, img2, ArgInfo("img2", 0)) &&
        jsopencv_to_safe(jsobj_keypoints2, keypoints2, ArgInfo("keypoints2", 0)) &&
        jsopencv_to_safe(jsobj_matches1to2, matches1to2, ArgInfo("matches1to2", 0)) &&
        jsopencv_to_safe(jsobj_outImg, outImg, ArgInfo("outImg", 1)) &&
        jsopencv_to_safe(jsobj_matchesThickness, matchesThickness, ArgInfo("matchesThickness", 0)) &&
        jsopencv_to_safe(jsobj_matchColor, matchColor, ArgInfo("matchColor", 0)) &&
        jsopencv_to_safe(jsobj_singlePointColor, singlePointColor, ArgInfo("singlePointColor", 0)) &&
        jsopencv_to_safe(jsobj_matchesMask, matchesMask, ArgInfo("matchesMask", 0)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, cv::drawMatches(img1, keypoints1, img2, keypoints2, matches1to2, outImg, matchesThickness, matchColor, singlePointColor, matchesMask, flags));
        return jsopencv_from(info, outImg);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_img1 = NULL;
    UMat img1;
    Napi::Value* jsobj_keypoints1 = NULL;
    vector_KeyPoint keypoints1;
    Napi::Value* jsobj_img2 = NULL;
    UMat img2;
    Napi::Value* jsobj_keypoints2 = NULL;
    vector_KeyPoint keypoints2;
    Napi::Value* jsobj_matches1to2 = NULL;
    vector_DMatch matches1to2;
    Napi::Value* jsobj_outImg = NULL;
    UMat outImg;
    Napi::Value* jsobj_matchesThickness = NULL;
    int matchesThickness=0;
    Napi::Value* jsobj_matchColor = NULL;
    Scalar matchColor=Scalar::all(-1);
    Napi::Value* jsobj_singlePointColor = NULL;
    Scalar singlePointColor=Scalar::all(-1);
    Napi::Value* jsobj_matchesMask = NULL;
    vector_char matchesMask=std::vector<char>();
    Napi::Value* jsobj_flags = NULL;
    DrawMatchesFlags flags=DrawMatchesFlags::DEFAULT;

    const char* keywords[] = { "img1", "keypoints1", "img2", "keypoints2", "matches1to2", "outImg", "matchesThickness", "matchColor", "singlePointColor", "matchesMask", "flags", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOOO|OOOO:drawMatches", (char**)keywords, &jsobj_img1, &jsobj_keypoints1, &jsobj_img2, &jsobj_keypoints2, &jsobj_matches1to2, &jsobj_outImg, &jsobj_matchesThickness, &jsobj_matchColor, &jsobj_singlePointColor, &jsobj_matchesMask, &jsobj_flags) &&
        jsopencv_to_safe(jsobj_img1, img1, ArgInfo("img1", 0)) &&
        jsopencv_to_safe(jsobj_keypoints1, keypoints1, ArgInfo("keypoints1", 0)) &&
        jsopencv_to_safe(jsobj_img2, img2, ArgInfo("img2", 0)) &&
        jsopencv_to_safe(jsobj_keypoints2, keypoints2, ArgInfo("keypoints2", 0)) &&
        jsopencv_to_safe(jsobj_matches1to2, matches1to2, ArgInfo("matches1to2", 0)) &&
        jsopencv_to_safe(jsobj_outImg, outImg, ArgInfo("outImg", 1)) &&
        jsopencv_to_safe(jsobj_matchesThickness, matchesThickness, ArgInfo("matchesThickness", 0)) &&
        jsopencv_to_safe(jsobj_matchColor, matchColor, ArgInfo("matchColor", 0)) &&
        jsopencv_to_safe(jsobj_singlePointColor, singlePointColor, ArgInfo("singlePointColor", 0)) &&
        jsopencv_to_safe(jsobj_matchesMask, matchesMask, ArgInfo("matchesMask", 0)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, cv::drawMatches(img1, keypoints1, img2, keypoints2, matches1to2, outImg, matchesThickness, matchColor, singlePointColor, matchesMask, flags));
        return jsopencv_from(info, outImg);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "drawMatches");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_drawMatchesKnn(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_img1 = NULL;
    Mat img1;
    Napi::Value* jsobj_keypoints1 = NULL;
    vector_KeyPoint keypoints1;
    Napi::Value* jsobj_img2 = NULL;
    Mat img2;
    Napi::Value* jsobj_keypoints2 = NULL;
    vector_KeyPoint keypoints2;
    Napi::Value* jsobj_matches1to2 = NULL;
    vector_vector_DMatch matches1to2;
    Napi::Value* jsobj_outImg = NULL;
    Mat outImg;
    Napi::Value* jsobj_matchColor = NULL;
    Scalar matchColor=Scalar::all(-1);
    Napi::Value* jsobj_singlePointColor = NULL;
    Scalar singlePointColor=Scalar::all(-1);
    Napi::Value* jsobj_matchesMask = NULL;
    vector_vector_char matchesMask=std::vector<std::vector<char> >();
    Napi::Value* jsobj_flags = NULL;
    DrawMatchesFlags flags=DrawMatchesFlags::DEFAULT;

    const char* keywords[] = { "img1", "keypoints1", "img2", "keypoints2", "matches1to2", "outImg", "matchColor", "singlePointColor", "matchesMask", "flags", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOO|OOOO:drawMatchesKnn", (char**)keywords, &jsobj_img1, &jsobj_keypoints1, &jsobj_img2, &jsobj_keypoints2, &jsobj_matches1to2, &jsobj_outImg, &jsobj_matchColor, &jsobj_singlePointColor, &jsobj_matchesMask, &jsobj_flags) &&
        jsopencv_to_safe(jsobj_img1, img1, ArgInfo("img1", 0)) &&
        jsopencv_to_safe(jsobj_keypoints1, keypoints1, ArgInfo("keypoints1", 0)) &&
        jsopencv_to_safe(jsobj_img2, img2, ArgInfo("img2", 0)) &&
        jsopencv_to_safe(jsobj_keypoints2, keypoints2, ArgInfo("keypoints2", 0)) &&
        jsopencv_to_safe(jsobj_matches1to2, matches1to2, ArgInfo("matches1to2", 0)) &&
        jsopencv_to_safe(jsobj_outImg, outImg, ArgInfo("outImg", 1)) &&
        jsopencv_to_safe(jsobj_matchColor, matchColor, ArgInfo("matchColor", 0)) &&
        jsopencv_to_safe(jsobj_singlePointColor, singlePointColor, ArgInfo("singlePointColor", 0)) &&
        jsopencv_to_safe(jsobj_matchesMask, matchesMask, ArgInfo("matchesMask", 0)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, cv::drawMatches(img1, keypoints1, img2, keypoints2, matches1to2, outImg, matchColor, singlePointColor, matchesMask, flags));
        return jsopencv_from(info, outImg);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_img1 = NULL;
    UMat img1;
    Napi::Value* jsobj_keypoints1 = NULL;
    vector_KeyPoint keypoints1;
    Napi::Value* jsobj_img2 = NULL;
    UMat img2;
    Napi::Value* jsobj_keypoints2 = NULL;
    vector_KeyPoint keypoints2;
    Napi::Value* jsobj_matches1to2 = NULL;
    vector_vector_DMatch matches1to2;
    Napi::Value* jsobj_outImg = NULL;
    UMat outImg;
    Napi::Value* jsobj_matchColor = NULL;
    Scalar matchColor=Scalar::all(-1);
    Napi::Value* jsobj_singlePointColor = NULL;
    Scalar singlePointColor=Scalar::all(-1);
    Napi::Value* jsobj_matchesMask = NULL;
    vector_vector_char matchesMask=std::vector<std::vector<char> >();
    Napi::Value* jsobj_flags = NULL;
    DrawMatchesFlags flags=DrawMatchesFlags::DEFAULT;

    const char* keywords[] = { "img1", "keypoints1", "img2", "keypoints2", "matches1to2", "outImg", "matchColor", "singlePointColor", "matchesMask", "flags", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOO|OOOO:drawMatchesKnn", (char**)keywords, &jsobj_img1, &jsobj_keypoints1, &jsobj_img2, &jsobj_keypoints2, &jsobj_matches1to2, &jsobj_outImg, &jsobj_matchColor, &jsobj_singlePointColor, &jsobj_matchesMask, &jsobj_flags) &&
        jsopencv_to_safe(jsobj_img1, img1, ArgInfo("img1", 0)) &&
        jsopencv_to_safe(jsobj_keypoints1, keypoints1, ArgInfo("keypoints1", 0)) &&
        jsopencv_to_safe(jsobj_img2, img2, ArgInfo("img2", 0)) &&
        jsopencv_to_safe(jsobj_keypoints2, keypoints2, ArgInfo("keypoints2", 0)) &&
        jsopencv_to_safe(jsobj_matches1to2, matches1to2, ArgInfo("matches1to2", 0)) &&
        jsopencv_to_safe(jsobj_outImg, outImg, ArgInfo("outImg", 1)) &&
        jsopencv_to_safe(jsobj_matchColor, matchColor, ArgInfo("matchColor", 0)) &&
        jsopencv_to_safe(jsobj_singlePointColor, singlePointColor, ArgInfo("singlePointColor", 0)) &&
        jsopencv_to_safe(jsobj_matchesMask, matchesMask, ArgInfo("matchesMask", 0)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, cv::drawMatches(img1, keypoints1, img2, keypoints2, matches1to2, outImg, matchColor, singlePointColor, matchesMask, flags));
        return jsopencv_from(info, outImg);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "drawMatchesKnn");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_edgePreservingFilter(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_flags = NULL;
    int flags=1;
    Napi::Value* jsobj_sigma_s = NULL;
    float sigma_s=60;
    Napi::Value* jsobj_sigma_r = NULL;
    float sigma_r=0.4f;

    const char* keywords[] = { "src", "dst", "flags", "sigma_s", "sigma_r", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOOO:edgePreservingFilter", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_flags, &jsobj_sigma_s, &jsobj_sigma_r) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_sigma_s, sigma_s, ArgInfo("sigma_s", 0)) &&
        jsopencv_to_safe(jsobj_sigma_r, sigma_r, ArgInfo("sigma_r", 0)))
    {
        ERRWRAP2_NAPI(info, cv::edgePreservingFilter(src, dst, flags, sigma_s, sigma_r));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_flags = NULL;
    int flags=1;
    Napi::Value* jsobj_sigma_s = NULL;
    float sigma_s=60;
    Napi::Value* jsobj_sigma_r = NULL;
    float sigma_r=0.4f;

    const char* keywords[] = { "src", "dst", "flags", "sigma_s", "sigma_r", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOOO:edgePreservingFilter", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_flags, &jsobj_sigma_s, &jsobj_sigma_r) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_sigma_s, sigma_s, ArgInfo("sigma_s", 0)) &&
        jsopencv_to_safe(jsobj_sigma_r, sigma_r, ArgInfo("sigma_r", 0)))
    {
        ERRWRAP2_NAPI(info, cv::edgePreservingFilter(src, dst, flags, sigma_s, sigma_r));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "edgePreservingFilter");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_eigen(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_eigenvalues = NULL;
    Mat eigenvalues;
    Napi::Value* jsobj_eigenvectors = NULL;
    Mat eigenvectors;
    bool retval;

    const char* keywords[] = { "src", "eigenvalues", "eigenvectors", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OO:eigen", (char**)keywords, &jsobj_src, &jsobj_eigenvalues, &jsobj_eigenvectors) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_eigenvalues, eigenvalues, ArgInfo("eigenvalues", 1)) &&
        jsopencv_to_safe(jsobj_eigenvectors, eigenvectors, ArgInfo("eigenvectors", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::eigen(src, eigenvalues, eigenvectors));
        return Js_BuildValue(info, "(NNN)", jsopencv_from(info, retval), jsopencv_from(info, eigenvalues), jsopencv_from(info, eigenvectors));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_eigenvalues = NULL;
    UMat eigenvalues;
    Napi::Value* jsobj_eigenvectors = NULL;
    UMat eigenvectors;
    bool retval;

    const char* keywords[] = { "src", "eigenvalues", "eigenvectors", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OO:eigen", (char**)keywords, &jsobj_src, &jsobj_eigenvalues, &jsobj_eigenvectors) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_eigenvalues, eigenvalues, ArgInfo("eigenvalues", 1)) &&
        jsopencv_to_safe(jsobj_eigenvectors, eigenvectors, ArgInfo("eigenvectors", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::eigen(src, eigenvalues, eigenvectors));
        return Js_BuildValue(info, "(NNN)", jsopencv_from(info, retval), jsopencv_from(info, eigenvalues), jsopencv_from(info, eigenvectors));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "eigen");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_eigenNonSymmetric(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_eigenvalues = NULL;
    Mat eigenvalues;
    Napi::Value* jsobj_eigenvectors = NULL;
    Mat eigenvectors;

    const char* keywords[] = { "src", "eigenvalues", "eigenvectors", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OO:eigenNonSymmetric", (char**)keywords, &jsobj_src, &jsobj_eigenvalues, &jsobj_eigenvectors) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_eigenvalues, eigenvalues, ArgInfo("eigenvalues", 1)) &&
        jsopencv_to_safe(jsobj_eigenvectors, eigenvectors, ArgInfo("eigenvectors", 1)))
    {
        ERRWRAP2_NAPI(info, cv::eigenNonSymmetric(src, eigenvalues, eigenvectors));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, eigenvalues), jsopencv_from(info, eigenvectors));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_eigenvalues = NULL;
    UMat eigenvalues;
    Napi::Value* jsobj_eigenvectors = NULL;
    UMat eigenvectors;

    const char* keywords[] = { "src", "eigenvalues", "eigenvectors", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OO:eigenNonSymmetric", (char**)keywords, &jsobj_src, &jsobj_eigenvalues, &jsobj_eigenvectors) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_eigenvalues, eigenvalues, ArgInfo("eigenvalues", 1)) &&
        jsopencv_to_safe(jsobj_eigenvectors, eigenvectors, ArgInfo("eigenvectors", 1)))
    {
        ERRWRAP2_NAPI(info, cv::eigenNonSymmetric(src, eigenvalues, eigenvectors));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, eigenvalues), jsopencv_from(info, eigenvectors));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "eigenNonSymmetric");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ellipse(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(4);

    {
    Napi::Value* jsobj_img = NULL;
    Mat img;
    Napi::Value* jsobj_center = NULL;
    Point center;
    Napi::Value* jsobj_axes = NULL;
    Size axes;
    Napi::Value* jsobj_angle = NULL;
    double angle=0;
    Napi::Value* jsobj_startAngle = NULL;
    double startAngle=0;
    Napi::Value* jsobj_endAngle = NULL;
    double endAngle=0;
    Napi::Value* jsobj_color = NULL;
    Scalar color;
    Napi::Value* jsobj_thickness = NULL;
    int thickness=1;
    Napi::Value* jsobj_lineType = NULL;
    int lineType=LINE_8;
    Napi::Value* jsobj_shift = NULL;
    int shift=0;

    const char* keywords[] = { "img", "center", "axes", "angle", "startAngle", "endAngle", "color", "thickness", "lineType", "shift", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOOO|OOO:ellipse", (char**)keywords, &jsobj_img, &jsobj_center, &jsobj_axes, &jsobj_angle, &jsobj_startAngle, &jsobj_endAngle, &jsobj_color, &jsobj_thickness, &jsobj_lineType, &jsobj_shift) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 1)) &&
        jsopencv_to_safe(jsobj_center, center, ArgInfo("center", 0)) &&
        jsopencv_to_safe(jsobj_axes, axes, ArgInfo("axes", 0)) &&
        jsopencv_to_safe(jsobj_angle, angle, ArgInfo("angle", 0)) &&
        jsopencv_to_safe(jsobj_startAngle, startAngle, ArgInfo("startAngle", 0)) &&
        jsopencv_to_safe(jsobj_endAngle, endAngle, ArgInfo("endAngle", 0)) &&
        jsopencv_to_safe(jsobj_color, color, ArgInfo("color", 0)) &&
        jsopencv_to_safe(jsobj_thickness, thickness, ArgInfo("thickness", 0)) &&
        jsopencv_to_safe(jsobj_lineType, lineType, ArgInfo("lineType", 0)) &&
        jsopencv_to_safe(jsobj_shift, shift, ArgInfo("shift", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ellipse(img, center, axes, angle, startAngle, endAngle, color, thickness, lineType, shift));
        return jsopencv_from(info, img);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_img = NULL;
    UMat img;
    Napi::Value* jsobj_center = NULL;
    Point center;
    Napi::Value* jsobj_axes = NULL;
    Size axes;
    Napi::Value* jsobj_angle = NULL;
    double angle=0;
    Napi::Value* jsobj_startAngle = NULL;
    double startAngle=0;
    Napi::Value* jsobj_endAngle = NULL;
    double endAngle=0;
    Napi::Value* jsobj_color = NULL;
    Scalar color;
    Napi::Value* jsobj_thickness = NULL;
    int thickness=1;
    Napi::Value* jsobj_lineType = NULL;
    int lineType=LINE_8;
    Napi::Value* jsobj_shift = NULL;
    int shift=0;

    const char* keywords[] = { "img", "center", "axes", "angle", "startAngle", "endAngle", "color", "thickness", "lineType", "shift", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOOO|OOO:ellipse", (char**)keywords, &jsobj_img, &jsobj_center, &jsobj_axes, &jsobj_angle, &jsobj_startAngle, &jsobj_endAngle, &jsobj_color, &jsobj_thickness, &jsobj_lineType, &jsobj_shift) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 1)) &&
        jsopencv_to_safe(jsobj_center, center, ArgInfo("center", 0)) &&
        jsopencv_to_safe(jsobj_axes, axes, ArgInfo("axes", 0)) &&
        jsopencv_to_safe(jsobj_angle, angle, ArgInfo("angle", 0)) &&
        jsopencv_to_safe(jsobj_startAngle, startAngle, ArgInfo("startAngle", 0)) &&
        jsopencv_to_safe(jsobj_endAngle, endAngle, ArgInfo("endAngle", 0)) &&
        jsopencv_to_safe(jsobj_color, color, ArgInfo("color", 0)) &&
        jsopencv_to_safe(jsobj_thickness, thickness, ArgInfo("thickness", 0)) &&
        jsopencv_to_safe(jsobj_lineType, lineType, ArgInfo("lineType", 0)) &&
        jsopencv_to_safe(jsobj_shift, shift, ArgInfo("shift", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ellipse(img, center, axes, angle, startAngle, endAngle, color, thickness, lineType, shift));
        return jsopencv_from(info, img);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_img = NULL;
    Mat img;
    Napi::Value* jsobj_box = NULL;
    RotatedRect box;
    Napi::Value* jsobj_color = NULL;
    Scalar color;
    Napi::Value* jsobj_thickness = NULL;
    int thickness=1;
    Napi::Value* jsobj_lineType = NULL;
    int lineType=LINE_8;

    const char* keywords[] = { "img", "box", "color", "thickness", "lineType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OO:ellipse", (char**)keywords, &jsobj_img, &jsobj_box, &jsobj_color, &jsobj_thickness, &jsobj_lineType) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 1)) &&
        jsopencv_to_safe(jsobj_box, box, ArgInfo("box", 0)) &&
        jsopencv_to_safe(jsobj_color, color, ArgInfo("color", 0)) &&
        jsopencv_to_safe(jsobj_thickness, thickness, ArgInfo("thickness", 0)) &&
        jsopencv_to_safe(jsobj_lineType, lineType, ArgInfo("lineType", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ellipse(img, box, color, thickness, lineType));
        return jsopencv_from(info, img);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_img = NULL;
    UMat img;
    Napi::Value* jsobj_box = NULL;
    RotatedRect box;
    Napi::Value* jsobj_color = NULL;
    Scalar color;
    Napi::Value* jsobj_thickness = NULL;
    int thickness=1;
    Napi::Value* jsobj_lineType = NULL;
    int lineType=LINE_8;

    const char* keywords[] = { "img", "box", "color", "thickness", "lineType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OO:ellipse", (char**)keywords, &jsobj_img, &jsobj_box, &jsobj_color, &jsobj_thickness, &jsobj_lineType) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 1)) &&
        jsopencv_to_safe(jsobj_box, box, ArgInfo("box", 0)) &&
        jsopencv_to_safe(jsobj_color, color, ArgInfo("color", 0)) &&
        jsopencv_to_safe(jsobj_thickness, thickness, ArgInfo("thickness", 0)) &&
        jsopencv_to_safe(jsobj_lineType, lineType, ArgInfo("lineType", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ellipse(img, box, color, thickness, lineType));
        return jsopencv_from(info, img);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "ellipse");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ellipse2Poly(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_center = NULL;
    Point center;
    Napi::Value* jsobj_axes = NULL;
    Size axes;
    Napi::Value* jsobj_angle = NULL;
    int angle=0;
    Napi::Value* jsobj_arcStart = NULL;
    int arcStart=0;
    Napi::Value* jsobj_arcEnd = NULL;
    int arcEnd=0;
    Napi::Value* jsobj_delta = NULL;
    int delta=0;
    vector_Point pts;

    const char* keywords[] = { "center", "axes", "angle", "arcStart", "arcEnd", "delta", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOO:ellipse2Poly", (char**)keywords, &jsobj_center, &jsobj_axes, &jsobj_angle, &jsobj_arcStart, &jsobj_arcEnd, &jsobj_delta) &&
        jsopencv_to_safe(jsobj_center, center, ArgInfo("center", 0)) &&
        jsopencv_to_safe(jsobj_axes, axes, ArgInfo("axes", 0)) &&
        jsopencv_to_safe(jsobj_angle, angle, ArgInfo("angle", 0)) &&
        jsopencv_to_safe(jsobj_arcStart, arcStart, ArgInfo("arcStart", 0)) &&
        jsopencv_to_safe(jsobj_arcEnd, arcEnd, ArgInfo("arcEnd", 0)) &&
        jsopencv_to_safe(jsobj_delta, delta, ArgInfo("delta", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ellipse2Poly(center, axes, angle, arcStart, arcEnd, delta, pts));
        return jsopencv_from(info, pts);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_empty_array_desc(const Napi::CallbackInfo &info)
{
    using namespace cv;

    GArrayDesc retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::empty_array_desc());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_empty_gopaque_desc(const Napi::CallbackInfo &info)
{
    using namespace cv;

    GOpaqueDesc retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::empty_gopaque_desc());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_empty_scalar_desc(const Napi::CallbackInfo &info)
{
    using namespace cv;

    GScalarDesc retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::empty_scalar_desc());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_equalizeHist(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;

    const char* keywords[] = { "src", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:equalizeHist", (char**)keywords, &jsobj_src, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)))
    {
        ERRWRAP2_NAPI(info, cv::equalizeHist(src, dst));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;

    const char* keywords[] = { "src", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:equalizeHist", (char**)keywords, &jsobj_src, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)))
    {
        ERRWRAP2_NAPI(info, cv::equalizeHist(src, dst));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "equalizeHist");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_erode(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_kernel = NULL;
    Mat kernel;
    Napi::Value* jsobj_anchor = NULL;
    Point anchor=Point(-1,-1);
    Napi::Value* jsobj_iterations = NULL;
    int iterations=1;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_CONSTANT;
    Napi::Value* jsobj_borderValue = NULL;
    Scalar borderValue=morphologyDefaultBorderValue();

    const char* keywords[] = { "src", "kernel", "dst", "anchor", "iterations", "borderType", "borderValue", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOOOO:erode", (char**)keywords, &jsobj_src, &jsobj_kernel, &jsobj_dst, &jsobj_anchor, &jsobj_iterations, &jsobj_borderType, &jsobj_borderValue) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_kernel, kernel, ArgInfo("kernel", 0)) &&
        jsopencv_to_safe(jsobj_anchor, anchor, ArgInfo("anchor", 0)) &&
        jsopencv_to_safe(jsobj_iterations, iterations, ArgInfo("iterations", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)) &&
        jsopencv_to_safe(jsobj_borderValue, borderValue, ArgInfo("borderValue", 0)))
    {
        ERRWRAP2_NAPI(info, cv::erode(src, dst, kernel, anchor, iterations, borderType, borderValue));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_kernel = NULL;
    UMat kernel;
    Napi::Value* jsobj_anchor = NULL;
    Point anchor=Point(-1,-1);
    Napi::Value* jsobj_iterations = NULL;
    int iterations=1;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_CONSTANT;
    Napi::Value* jsobj_borderValue = NULL;
    Scalar borderValue=morphologyDefaultBorderValue();

    const char* keywords[] = { "src", "kernel", "dst", "anchor", "iterations", "borderType", "borderValue", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOOOO:erode", (char**)keywords, &jsobj_src, &jsobj_kernel, &jsobj_dst, &jsobj_anchor, &jsobj_iterations, &jsobj_borderType, &jsobj_borderValue) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_kernel, kernel, ArgInfo("kernel", 0)) &&
        jsopencv_to_safe(jsobj_anchor, anchor, ArgInfo("anchor", 0)) &&
        jsopencv_to_safe(jsobj_iterations, iterations, ArgInfo("iterations", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)) &&
        jsopencv_to_safe(jsobj_borderValue, borderValue, ArgInfo("borderValue", 0)))
    {
        ERRWRAP2_NAPI(info, cv::erode(src, dst, kernel, anchor, iterations, borderType, borderValue));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "erode");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_estimateAffine2D(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(4);

    {
    Napi::Value* jsobj_from = NULL;
    Mat from;
    Napi::Value* jsobj_to = NULL;
    Mat to;
    Napi::Value* jsobj_inliers = NULL;
    Mat inliers;
    Napi::Value* jsobj_method = NULL;
    int method=RANSAC;
    Napi::Value* jsobj_ransacReprojThreshold = NULL;
    double ransacReprojThreshold=3;
    Napi::Value* jsobj_maxIters = NULL;
    size_t maxIters=2000;
    Napi::Value* jsobj_confidence = NULL;
    double confidence=0.99;
    Napi::Value* jsobj_refineIters = NULL;
    size_t refineIters=10;
    cv::Mat retval;

    const char* keywords[] = { "from_", "to", "inliers", "method", "ransacReprojThreshold", "maxIters", "confidence", "refineIters", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOOOOO:estimateAffine2D", (char**)keywords, &jsobj_from, &jsobj_to, &jsobj_inliers, &jsobj_method, &jsobj_ransacReprojThreshold, &jsobj_maxIters, &jsobj_confidence, &jsobj_refineIters) &&
        jsopencv_to_safe(jsobj_from, from, ArgInfo("from", 0)) &&
        jsopencv_to_safe(jsobj_to, to, ArgInfo("to", 0)) &&
        jsopencv_to_safe(jsobj_inliers, inliers, ArgInfo("inliers", 1)) &&
        jsopencv_to_safe(jsobj_method, method, ArgInfo("method", 0)) &&
        jsopencv_to_safe(jsobj_ransacReprojThreshold, ransacReprojThreshold, ArgInfo("ransacReprojThreshold", 0)) &&
        jsopencv_to_safe(jsobj_maxIters, maxIters, ArgInfo("maxIters", 0)) &&
        jsopencv_to_safe(jsobj_confidence, confidence, ArgInfo("confidence", 0)) &&
        jsopencv_to_safe(jsobj_refineIters, refineIters, ArgInfo("refineIters", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::estimateAffine2D(from, to, inliers, method, ransacReprojThreshold, maxIters, confidence, refineIters));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, inliers));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_from = NULL;
    UMat from;
    Napi::Value* jsobj_to = NULL;
    UMat to;
    Napi::Value* jsobj_inliers = NULL;
    UMat inliers;
    Napi::Value* jsobj_method = NULL;
    int method=RANSAC;
    Napi::Value* jsobj_ransacReprojThreshold = NULL;
    double ransacReprojThreshold=3;
    Napi::Value* jsobj_maxIters = NULL;
    size_t maxIters=2000;
    Napi::Value* jsobj_confidence = NULL;
    double confidence=0.99;
    Napi::Value* jsobj_refineIters = NULL;
    size_t refineIters=10;
    cv::Mat retval;

    const char* keywords[] = { "from_", "to", "inliers", "method", "ransacReprojThreshold", "maxIters", "confidence", "refineIters", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOOOOO:estimateAffine2D", (char**)keywords, &jsobj_from, &jsobj_to, &jsobj_inliers, &jsobj_method, &jsobj_ransacReprojThreshold, &jsobj_maxIters, &jsobj_confidence, &jsobj_refineIters) &&
        jsopencv_to_safe(jsobj_from, from, ArgInfo("from", 0)) &&
        jsopencv_to_safe(jsobj_to, to, ArgInfo("to", 0)) &&
        jsopencv_to_safe(jsobj_inliers, inliers, ArgInfo("inliers", 1)) &&
        jsopencv_to_safe(jsobj_method, method, ArgInfo("method", 0)) &&
        jsopencv_to_safe(jsobj_ransacReprojThreshold, ransacReprojThreshold, ArgInfo("ransacReprojThreshold", 0)) &&
        jsopencv_to_safe(jsobj_maxIters, maxIters, ArgInfo("maxIters", 0)) &&
        jsopencv_to_safe(jsobj_confidence, confidence, ArgInfo("confidence", 0)) &&
        jsopencv_to_safe(jsobj_refineIters, refineIters, ArgInfo("refineIters", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::estimateAffine2D(from, to, inliers, method, ransacReprojThreshold, maxIters, confidence, refineIters));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, inliers));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_pts1 = NULL;
    Mat pts1;
    Napi::Value* jsobj_pts2 = NULL;
    Mat pts2;
    Napi::Value* jsobj_inliers = NULL;
    Mat inliers;
    Napi::Value* jsobj_params = NULL;
    cv::UsacParams params;
    cv::Mat retval;

    const char* keywords[] = { "pts1", "pts2", "params", "inliers", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:estimateAffine2D", (char**)keywords, &jsobj_pts1, &jsobj_pts2, &jsobj_params, &jsobj_inliers) &&
        jsopencv_to_safe(jsobj_pts1, pts1, ArgInfo("pts1", 0)) &&
        jsopencv_to_safe(jsobj_pts2, pts2, ArgInfo("pts2", 0)) &&
        jsopencv_to_safe(jsobj_inliers, inliers, ArgInfo("inliers", 1)) &&
        jsopencv_to_safe(jsobj_params, params, ArgInfo("params", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::estimateAffine2D(pts1, pts2, inliers, params));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, inliers));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_pts1 = NULL;
    UMat pts1;
    Napi::Value* jsobj_pts2 = NULL;
    UMat pts2;
    Napi::Value* jsobj_inliers = NULL;
    UMat inliers;
    Napi::Value* jsobj_params = NULL;
    cv::UsacParams params;
    cv::Mat retval;

    const char* keywords[] = { "pts1", "pts2", "params", "inliers", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:estimateAffine2D", (char**)keywords, &jsobj_pts1, &jsobj_pts2, &jsobj_params, &jsobj_inliers) &&
        jsopencv_to_safe(jsobj_pts1, pts1, ArgInfo("pts1", 0)) &&
        jsopencv_to_safe(jsobj_pts2, pts2, ArgInfo("pts2", 0)) &&
        jsopencv_to_safe(jsobj_inliers, inliers, ArgInfo("inliers", 1)) &&
        jsopencv_to_safe(jsobj_params, params, ArgInfo("params", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::estimateAffine2D(pts1, pts2, inliers, params));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, inliers));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "estimateAffine2D");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_estimateAffine3D(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(4);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_out = NULL;
    Mat out;
    Napi::Value* jsobj_inliers = NULL;
    Mat inliers;
    Napi::Value* jsobj_ransacThreshold = NULL;
    double ransacThreshold=3;
    Napi::Value* jsobj_confidence = NULL;
    double confidence=0.99;
    int retval;

    const char* keywords[] = { "src", "dst", "out", "inliers", "ransacThreshold", "confidence", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOOO:estimateAffine3D", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_out, &jsobj_inliers, &jsobj_ransacThreshold, &jsobj_confidence) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 0)) &&
        jsopencv_to_safe(jsobj_out, out, ArgInfo("out", 1)) &&
        jsopencv_to_safe(jsobj_inliers, inliers, ArgInfo("inliers", 1)) &&
        jsopencv_to_safe(jsobj_ransacThreshold, ransacThreshold, ArgInfo("ransacThreshold", 0)) &&
        jsopencv_to_safe(jsobj_confidence, confidence, ArgInfo("confidence", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::estimateAffine3D(src, dst, out, inliers, ransacThreshold, confidence));
        return Js_BuildValue(info, "(NNN)", jsopencv_from(info, retval), jsopencv_from(info, out), jsopencv_from(info, inliers));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_out = NULL;
    UMat out;
    Napi::Value* jsobj_inliers = NULL;
    UMat inliers;
    Napi::Value* jsobj_ransacThreshold = NULL;
    double ransacThreshold=3;
    Napi::Value* jsobj_confidence = NULL;
    double confidence=0.99;
    int retval;

    const char* keywords[] = { "src", "dst", "out", "inliers", "ransacThreshold", "confidence", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOOO:estimateAffine3D", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_out, &jsobj_inliers, &jsobj_ransacThreshold, &jsobj_confidence) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 0)) &&
        jsopencv_to_safe(jsobj_out, out, ArgInfo("out", 1)) &&
        jsopencv_to_safe(jsobj_inliers, inliers, ArgInfo("inliers", 1)) &&
        jsopencv_to_safe(jsobj_ransacThreshold, ransacThreshold, ArgInfo("ransacThreshold", 0)) &&
        jsopencv_to_safe(jsobj_confidence, confidence, ArgInfo("confidence", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::estimateAffine3D(src, dst, out, inliers, ransacThreshold, confidence));
        return Js_BuildValue(info, "(NNN)", jsopencv_from(info, retval), jsopencv_from(info, out), jsopencv_from(info, inliers));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    double scale;
    Napi::Value* jsobj_force_rotation = NULL;
    bool force_rotation=true;
    cv::Mat retval;

    const char* keywords[] = { "src", "dst", "force_rotation", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:estimateAffine3D", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_force_rotation) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 0)) &&
        jsopencv_to_safe(jsobj_force_rotation, force_rotation, ArgInfo("force_rotation", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::estimateAffine3D(src, dst, &scale, force_rotation));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, scale));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    double scale;
    Napi::Value* jsobj_force_rotation = NULL;
    bool force_rotation=true;
    cv::Mat retval;

    const char* keywords[] = { "src", "dst", "force_rotation", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:estimateAffine3D", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_force_rotation) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 0)) &&
        jsopencv_to_safe(jsobj_force_rotation, force_rotation, ArgInfo("force_rotation", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::estimateAffine3D(src, dst, &scale, force_rotation));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, scale));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "estimateAffine3D");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_estimateAffinePartial2D(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_from = NULL;
    Mat from;
    Napi::Value* jsobj_to = NULL;
    Mat to;
    Napi::Value* jsobj_inliers = NULL;
    Mat inliers;
    Napi::Value* jsobj_method = NULL;
    int method=RANSAC;
    Napi::Value* jsobj_ransacReprojThreshold = NULL;
    double ransacReprojThreshold=3;
    Napi::Value* jsobj_maxIters = NULL;
    size_t maxIters=2000;
    Napi::Value* jsobj_confidence = NULL;
    double confidence=0.99;
    Napi::Value* jsobj_refineIters = NULL;
    size_t refineIters=10;
    cv::Mat retval;

    const char* keywords[] = { "from_", "to", "inliers", "method", "ransacReprojThreshold", "maxIters", "confidence", "refineIters", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOOOOO:estimateAffinePartial2D", (char**)keywords, &jsobj_from, &jsobj_to, &jsobj_inliers, &jsobj_method, &jsobj_ransacReprojThreshold, &jsobj_maxIters, &jsobj_confidence, &jsobj_refineIters) &&
        jsopencv_to_safe(jsobj_from, from, ArgInfo("from", 0)) &&
        jsopencv_to_safe(jsobj_to, to, ArgInfo("to", 0)) &&
        jsopencv_to_safe(jsobj_inliers, inliers, ArgInfo("inliers", 1)) &&
        jsopencv_to_safe(jsobj_method, method, ArgInfo("method", 0)) &&
        jsopencv_to_safe(jsobj_ransacReprojThreshold, ransacReprojThreshold, ArgInfo("ransacReprojThreshold", 0)) &&
        jsopencv_to_safe(jsobj_maxIters, maxIters, ArgInfo("maxIters", 0)) &&
        jsopencv_to_safe(jsobj_confidence, confidence, ArgInfo("confidence", 0)) &&
        jsopencv_to_safe(jsobj_refineIters, refineIters, ArgInfo("refineIters", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::estimateAffinePartial2D(from, to, inliers, method, ransacReprojThreshold, maxIters, confidence, refineIters));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, inliers));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_from = NULL;
    UMat from;
    Napi::Value* jsobj_to = NULL;
    UMat to;
    Napi::Value* jsobj_inliers = NULL;
    UMat inliers;
    Napi::Value* jsobj_method = NULL;
    int method=RANSAC;
    Napi::Value* jsobj_ransacReprojThreshold = NULL;
    double ransacReprojThreshold=3;
    Napi::Value* jsobj_maxIters = NULL;
    size_t maxIters=2000;
    Napi::Value* jsobj_confidence = NULL;
    double confidence=0.99;
    Napi::Value* jsobj_refineIters = NULL;
    size_t refineIters=10;
    cv::Mat retval;

    const char* keywords[] = { "from_", "to", "inliers", "method", "ransacReprojThreshold", "maxIters", "confidence", "refineIters", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOOOOO:estimateAffinePartial2D", (char**)keywords, &jsobj_from, &jsobj_to, &jsobj_inliers, &jsobj_method, &jsobj_ransacReprojThreshold, &jsobj_maxIters, &jsobj_confidence, &jsobj_refineIters) &&
        jsopencv_to_safe(jsobj_from, from, ArgInfo("from", 0)) &&
        jsopencv_to_safe(jsobj_to, to, ArgInfo("to", 0)) &&
        jsopencv_to_safe(jsobj_inliers, inliers, ArgInfo("inliers", 1)) &&
        jsopencv_to_safe(jsobj_method, method, ArgInfo("method", 0)) &&
        jsopencv_to_safe(jsobj_ransacReprojThreshold, ransacReprojThreshold, ArgInfo("ransacReprojThreshold", 0)) &&
        jsopencv_to_safe(jsobj_maxIters, maxIters, ArgInfo("maxIters", 0)) &&
        jsopencv_to_safe(jsobj_confidence, confidence, ArgInfo("confidence", 0)) &&
        jsopencv_to_safe(jsobj_refineIters, refineIters, ArgInfo("refineIters", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::estimateAffinePartial2D(from, to, inliers, method, ransacReprojThreshold, maxIters, confidence, refineIters));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, inliers));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "estimateAffinePartial2D");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_estimateChessboardSharpness(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_image = NULL;
    Mat image;
    Napi::Value* jsobj_patternSize = NULL;
    Size patternSize;
    Napi::Value* jsobj_corners = NULL;
    Mat corners;
    Napi::Value* jsobj_rise_distance = NULL;
    float rise_distance=0.8F;
    Napi::Value* jsobj_vertical = NULL;
    bool vertical=false;
    Napi::Value* jsobj_sharpness = NULL;
    Mat sharpness;
    Scalar retval;

    const char* keywords[] = { "image", "patternSize", "corners", "rise_distance", "vertical", "sharpness", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOO:estimateChessboardSharpness", (char**)keywords, &jsobj_image, &jsobj_patternSize, &jsobj_corners, &jsobj_rise_distance, &jsobj_vertical, &jsobj_sharpness) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_patternSize, patternSize, ArgInfo("patternSize", 0)) &&
        jsopencv_to_safe(jsobj_corners, corners, ArgInfo("corners", 0)) &&
        jsopencv_to_safe(jsobj_rise_distance, rise_distance, ArgInfo("rise_distance", 0)) &&
        jsopencv_to_safe(jsobj_vertical, vertical, ArgInfo("vertical", 0)) &&
        jsopencv_to_safe(jsobj_sharpness, sharpness, ArgInfo("sharpness", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::estimateChessboardSharpness(image, patternSize, corners, rise_distance, vertical, sharpness));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, sharpness));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_image = NULL;
    UMat image;
    Napi::Value* jsobj_patternSize = NULL;
    Size patternSize;
    Napi::Value* jsobj_corners = NULL;
    UMat corners;
    Napi::Value* jsobj_rise_distance = NULL;
    float rise_distance=0.8F;
    Napi::Value* jsobj_vertical = NULL;
    bool vertical=false;
    Napi::Value* jsobj_sharpness = NULL;
    UMat sharpness;
    Scalar retval;

    const char* keywords[] = { "image", "patternSize", "corners", "rise_distance", "vertical", "sharpness", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOO:estimateChessboardSharpness", (char**)keywords, &jsobj_image, &jsobj_patternSize, &jsobj_corners, &jsobj_rise_distance, &jsobj_vertical, &jsobj_sharpness) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_patternSize, patternSize, ArgInfo("patternSize", 0)) &&
        jsopencv_to_safe(jsobj_corners, corners, ArgInfo("corners", 0)) &&
        jsopencv_to_safe(jsobj_rise_distance, rise_distance, ArgInfo("rise_distance", 0)) &&
        jsopencv_to_safe(jsobj_vertical, vertical, ArgInfo("vertical", 0)) &&
        jsopencv_to_safe(jsobj_sharpness, sharpness, ArgInfo("sharpness", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::estimateChessboardSharpness(image, patternSize, corners, rise_distance, vertical, sharpness));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, sharpness));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "estimateChessboardSharpness");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_estimateTranslation3D(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_out = NULL;
    Mat out;
    Napi::Value* jsobj_inliers = NULL;
    Mat inliers;
    Napi::Value* jsobj_ransacThreshold = NULL;
    double ransacThreshold=3;
    Napi::Value* jsobj_confidence = NULL;
    double confidence=0.99;
    int retval;

    const char* keywords[] = { "src", "dst", "out", "inliers", "ransacThreshold", "confidence", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOOO:estimateTranslation3D", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_out, &jsobj_inliers, &jsobj_ransacThreshold, &jsobj_confidence) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 0)) &&
        jsopencv_to_safe(jsobj_out, out, ArgInfo("out", 1)) &&
        jsopencv_to_safe(jsobj_inliers, inliers, ArgInfo("inliers", 1)) &&
        jsopencv_to_safe(jsobj_ransacThreshold, ransacThreshold, ArgInfo("ransacThreshold", 0)) &&
        jsopencv_to_safe(jsobj_confidence, confidence, ArgInfo("confidence", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::estimateTranslation3D(src, dst, out, inliers, ransacThreshold, confidence));
        return Js_BuildValue(info, "(NNN)", jsopencv_from(info, retval), jsopencv_from(info, out), jsopencv_from(info, inliers));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_out = NULL;
    UMat out;
    Napi::Value* jsobj_inliers = NULL;
    UMat inliers;
    Napi::Value* jsobj_ransacThreshold = NULL;
    double ransacThreshold=3;
    Napi::Value* jsobj_confidence = NULL;
    double confidence=0.99;
    int retval;

    const char* keywords[] = { "src", "dst", "out", "inliers", "ransacThreshold", "confidence", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOOO:estimateTranslation3D", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_out, &jsobj_inliers, &jsobj_ransacThreshold, &jsobj_confidence) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 0)) &&
        jsopencv_to_safe(jsobj_out, out, ArgInfo("out", 1)) &&
        jsopencv_to_safe(jsobj_inliers, inliers, ArgInfo("inliers", 1)) &&
        jsopencv_to_safe(jsobj_ransacThreshold, ransacThreshold, ArgInfo("ransacThreshold", 0)) &&
        jsopencv_to_safe(jsobj_confidence, confidence, ArgInfo("confidence", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::estimateTranslation3D(src, dst, out, inliers, ransacThreshold, confidence));
        return Js_BuildValue(info, "(NNN)", jsopencv_from(info, retval), jsopencv_from(info, out), jsopencv_from(info, inliers));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "estimateTranslation3D");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_exp(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;

    const char* keywords[] = { "src", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:exp", (char**)keywords, &jsobj_src, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)))
    {
        ERRWRAP2_NAPI(info, cv::exp(src, dst));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;

    const char* keywords[] = { "src", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:exp", (char**)keywords, &jsobj_src, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)))
    {
        ERRWRAP2_NAPI(info, cv::exp(src, dst));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "exp");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_extractChannel(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_coi = NULL;
    int coi=0;

    const char* keywords[] = { "src", "coi", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:extractChannel", (char**)keywords, &jsobj_src, &jsobj_coi, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_coi, coi, ArgInfo("coi", 0)))
    {
        ERRWRAP2_NAPI(info, cv::extractChannel(src, dst, coi));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_coi = NULL;
    int coi=0;

    const char* keywords[] = { "src", "coi", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:extractChannel", (char**)keywords, &jsobj_src, &jsobj_coi, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_coi, coi, ArgInfo("coi", 0)))
    {
        ERRWRAP2_NAPI(info, cv::extractChannel(src, dst, coi));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "extractChannel");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_fastAtan2(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_y = NULL;
    float y=0.f;
    Napi::Value* jsobj_x = NULL;
    float x=0.f;
    float retval;

    const char* keywords[] = { "y", "x", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:fastAtan2", (char**)keywords, &jsobj_y, &jsobj_x) &&
        jsopencv_to_safe(jsobj_y, y, ArgInfo("y", 0)) &&
        jsopencv_to_safe(jsobj_x, x, ArgInfo("x", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::fastAtan2(y, x));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_fastNlMeansDenoising(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(4);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_h = NULL;
    float h=3;
    Napi::Value* jsobj_templateWindowSize = NULL;
    int templateWindowSize=7;
    Napi::Value* jsobj_searchWindowSize = NULL;
    int searchWindowSize=21;

    const char* keywords[] = { "src", "dst", "h", "templateWindowSize", "searchWindowSize", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOOO:fastNlMeansDenoising", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_h, &jsobj_templateWindowSize, &jsobj_searchWindowSize) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_h, h, ArgInfo("h", 0)) &&
        jsopencv_to_safe(jsobj_templateWindowSize, templateWindowSize, ArgInfo("templateWindowSize", 0)) &&
        jsopencv_to_safe(jsobj_searchWindowSize, searchWindowSize, ArgInfo("searchWindowSize", 0)))
    {
        ERRWRAP2_NAPI(info, cv::fastNlMeansDenoising(src, dst, h, templateWindowSize, searchWindowSize));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_h = NULL;
    float h=3;
    Napi::Value* jsobj_templateWindowSize = NULL;
    int templateWindowSize=7;
    Napi::Value* jsobj_searchWindowSize = NULL;
    int searchWindowSize=21;

    const char* keywords[] = { "src", "dst", "h", "templateWindowSize", "searchWindowSize", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOOO:fastNlMeansDenoising", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_h, &jsobj_templateWindowSize, &jsobj_searchWindowSize) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_h, h, ArgInfo("h", 0)) &&
        jsopencv_to_safe(jsobj_templateWindowSize, templateWindowSize, ArgInfo("templateWindowSize", 0)) &&
        jsopencv_to_safe(jsobj_searchWindowSize, searchWindowSize, ArgInfo("searchWindowSize", 0)))
    {
        ERRWRAP2_NAPI(info, cv::fastNlMeansDenoising(src, dst, h, templateWindowSize, searchWindowSize));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_h = NULL;
    vector_float h;
    Napi::Value* jsobj_templateWindowSize = NULL;
    int templateWindowSize=7;
    Napi::Value* jsobj_searchWindowSize = NULL;
    int searchWindowSize=21;
    Napi::Value* jsobj_normType = NULL;
    int normType=NORM_L2;

    const char* keywords[] = { "src", "h", "dst", "templateWindowSize", "searchWindowSize", "normType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOOO:fastNlMeansDenoising", (char**)keywords, &jsobj_src, &jsobj_h, &jsobj_dst, &jsobj_templateWindowSize, &jsobj_searchWindowSize, &jsobj_normType) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_h, h, ArgInfo("h", 0)) &&
        jsopencv_to_safe(jsobj_templateWindowSize, templateWindowSize, ArgInfo("templateWindowSize", 0)) &&
        jsopencv_to_safe(jsobj_searchWindowSize, searchWindowSize, ArgInfo("searchWindowSize", 0)) &&
        jsopencv_to_safe(jsobj_normType, normType, ArgInfo("normType", 0)))
    {
        ERRWRAP2_NAPI(info, cv::fastNlMeansDenoising(src, dst, h, templateWindowSize, searchWindowSize, normType));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_h = NULL;
    vector_float h;
    Napi::Value* jsobj_templateWindowSize = NULL;
    int templateWindowSize=7;
    Napi::Value* jsobj_searchWindowSize = NULL;
    int searchWindowSize=21;
    Napi::Value* jsobj_normType = NULL;
    int normType=NORM_L2;

    const char* keywords[] = { "src", "h", "dst", "templateWindowSize", "searchWindowSize", "normType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOOO:fastNlMeansDenoising", (char**)keywords, &jsobj_src, &jsobj_h, &jsobj_dst, &jsobj_templateWindowSize, &jsobj_searchWindowSize, &jsobj_normType) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_h, h, ArgInfo("h", 0)) &&
        jsopencv_to_safe(jsobj_templateWindowSize, templateWindowSize, ArgInfo("templateWindowSize", 0)) &&
        jsopencv_to_safe(jsobj_searchWindowSize, searchWindowSize, ArgInfo("searchWindowSize", 0)) &&
        jsopencv_to_safe(jsobj_normType, normType, ArgInfo("normType", 0)))
    {
        ERRWRAP2_NAPI(info, cv::fastNlMeansDenoising(src, dst, h, templateWindowSize, searchWindowSize, normType));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "fastNlMeansDenoising");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_fastNlMeansDenoisingColored(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_h = NULL;
    float h=3;
    Napi::Value* jsobj_hColor = NULL;
    float hColor=3;
    Napi::Value* jsobj_templateWindowSize = NULL;
    int templateWindowSize=7;
    Napi::Value* jsobj_searchWindowSize = NULL;
    int searchWindowSize=21;

    const char* keywords[] = { "src", "dst", "h", "hColor", "templateWindowSize", "searchWindowSize", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOOOO:fastNlMeansDenoisingColored", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_h, &jsobj_hColor, &jsobj_templateWindowSize, &jsobj_searchWindowSize) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_h, h, ArgInfo("h", 0)) &&
        jsopencv_to_safe(jsobj_hColor, hColor, ArgInfo("hColor", 0)) &&
        jsopencv_to_safe(jsobj_templateWindowSize, templateWindowSize, ArgInfo("templateWindowSize", 0)) &&
        jsopencv_to_safe(jsobj_searchWindowSize, searchWindowSize, ArgInfo("searchWindowSize", 0)))
    {
        ERRWRAP2_NAPI(info, cv::fastNlMeansDenoisingColored(src, dst, h, hColor, templateWindowSize, searchWindowSize));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_h = NULL;
    float h=3;
    Napi::Value* jsobj_hColor = NULL;
    float hColor=3;
    Napi::Value* jsobj_templateWindowSize = NULL;
    int templateWindowSize=7;
    Napi::Value* jsobj_searchWindowSize = NULL;
    int searchWindowSize=21;

    const char* keywords[] = { "src", "dst", "h", "hColor", "templateWindowSize", "searchWindowSize", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOOOO:fastNlMeansDenoisingColored", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_h, &jsobj_hColor, &jsobj_templateWindowSize, &jsobj_searchWindowSize) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_h, h, ArgInfo("h", 0)) &&
        jsopencv_to_safe(jsobj_hColor, hColor, ArgInfo("hColor", 0)) &&
        jsopencv_to_safe(jsobj_templateWindowSize, templateWindowSize, ArgInfo("templateWindowSize", 0)) &&
        jsopencv_to_safe(jsobj_searchWindowSize, searchWindowSize, ArgInfo("searchWindowSize", 0)))
    {
        ERRWRAP2_NAPI(info, cv::fastNlMeansDenoisingColored(src, dst, h, hColor, templateWindowSize, searchWindowSize));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "fastNlMeansDenoisingColored");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_fastNlMeansDenoisingColoredMulti(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_srcImgs = NULL;
    vector_Mat srcImgs;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_imgToDenoiseIndex = NULL;
    int imgToDenoiseIndex=0;
    Napi::Value* jsobj_temporalWindowSize = NULL;
    int temporalWindowSize=0;
    Napi::Value* jsobj_h = NULL;
    float h=3;
    Napi::Value* jsobj_hColor = NULL;
    float hColor=3;
    Napi::Value* jsobj_templateWindowSize = NULL;
    int templateWindowSize=7;
    Napi::Value* jsobj_searchWindowSize = NULL;
    int searchWindowSize=21;

    const char* keywords[] = { "srcImgs", "imgToDenoiseIndex", "temporalWindowSize", "dst", "h", "hColor", "templateWindowSize", "searchWindowSize", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOOOO:fastNlMeansDenoisingColoredMulti", (char**)keywords, &jsobj_srcImgs, &jsobj_imgToDenoiseIndex, &jsobj_temporalWindowSize, &jsobj_dst, &jsobj_h, &jsobj_hColor, &jsobj_templateWindowSize, &jsobj_searchWindowSize) &&
        jsopencv_to_safe(jsobj_srcImgs, srcImgs, ArgInfo("srcImgs", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_imgToDenoiseIndex, imgToDenoiseIndex, ArgInfo("imgToDenoiseIndex", 0)) &&
        jsopencv_to_safe(jsobj_temporalWindowSize, temporalWindowSize, ArgInfo("temporalWindowSize", 0)) &&
        jsopencv_to_safe(jsobj_h, h, ArgInfo("h", 0)) &&
        jsopencv_to_safe(jsobj_hColor, hColor, ArgInfo("hColor", 0)) &&
        jsopencv_to_safe(jsobj_templateWindowSize, templateWindowSize, ArgInfo("templateWindowSize", 0)) &&
        jsopencv_to_safe(jsobj_searchWindowSize, searchWindowSize, ArgInfo("searchWindowSize", 0)))
    {
        ERRWRAP2_NAPI(info, cv::fastNlMeansDenoisingColoredMulti(srcImgs, dst, imgToDenoiseIndex, temporalWindowSize, h, hColor, templateWindowSize, searchWindowSize));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_srcImgs = NULL;
    vector_UMat srcImgs;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_imgToDenoiseIndex = NULL;
    int imgToDenoiseIndex=0;
    Napi::Value* jsobj_temporalWindowSize = NULL;
    int temporalWindowSize=0;
    Napi::Value* jsobj_h = NULL;
    float h=3;
    Napi::Value* jsobj_hColor = NULL;
    float hColor=3;
    Napi::Value* jsobj_templateWindowSize = NULL;
    int templateWindowSize=7;
    Napi::Value* jsobj_searchWindowSize = NULL;
    int searchWindowSize=21;

    const char* keywords[] = { "srcImgs", "imgToDenoiseIndex", "temporalWindowSize", "dst", "h", "hColor", "templateWindowSize", "searchWindowSize", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOOOO:fastNlMeansDenoisingColoredMulti", (char**)keywords, &jsobj_srcImgs, &jsobj_imgToDenoiseIndex, &jsobj_temporalWindowSize, &jsobj_dst, &jsobj_h, &jsobj_hColor, &jsobj_templateWindowSize, &jsobj_searchWindowSize) &&
        jsopencv_to_safe(jsobj_srcImgs, srcImgs, ArgInfo("srcImgs", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_imgToDenoiseIndex, imgToDenoiseIndex, ArgInfo("imgToDenoiseIndex", 0)) &&
        jsopencv_to_safe(jsobj_temporalWindowSize, temporalWindowSize, ArgInfo("temporalWindowSize", 0)) &&
        jsopencv_to_safe(jsobj_h, h, ArgInfo("h", 0)) &&
        jsopencv_to_safe(jsobj_hColor, hColor, ArgInfo("hColor", 0)) &&
        jsopencv_to_safe(jsobj_templateWindowSize, templateWindowSize, ArgInfo("templateWindowSize", 0)) &&
        jsopencv_to_safe(jsobj_searchWindowSize, searchWindowSize, ArgInfo("searchWindowSize", 0)))
    {
        ERRWRAP2_NAPI(info, cv::fastNlMeansDenoisingColoredMulti(srcImgs, dst, imgToDenoiseIndex, temporalWindowSize, h, hColor, templateWindowSize, searchWindowSize));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "fastNlMeansDenoisingColoredMulti");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_fastNlMeansDenoisingMulti(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(4);

    {
    Napi::Value* jsobj_srcImgs = NULL;
    vector_Mat srcImgs;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_imgToDenoiseIndex = NULL;
    int imgToDenoiseIndex=0;
    Napi::Value* jsobj_temporalWindowSize = NULL;
    int temporalWindowSize=0;
    Napi::Value* jsobj_h = NULL;
    float h=3;
    Napi::Value* jsobj_templateWindowSize = NULL;
    int templateWindowSize=7;
    Napi::Value* jsobj_searchWindowSize = NULL;
    int searchWindowSize=21;

    const char* keywords[] = { "srcImgs", "imgToDenoiseIndex", "temporalWindowSize", "dst", "h", "templateWindowSize", "searchWindowSize", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOOO:fastNlMeansDenoisingMulti", (char**)keywords, &jsobj_srcImgs, &jsobj_imgToDenoiseIndex, &jsobj_temporalWindowSize, &jsobj_dst, &jsobj_h, &jsobj_templateWindowSize, &jsobj_searchWindowSize) &&
        jsopencv_to_safe(jsobj_srcImgs, srcImgs, ArgInfo("srcImgs", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_imgToDenoiseIndex, imgToDenoiseIndex, ArgInfo("imgToDenoiseIndex", 0)) &&
        jsopencv_to_safe(jsobj_temporalWindowSize, temporalWindowSize, ArgInfo("temporalWindowSize", 0)) &&
        jsopencv_to_safe(jsobj_h, h, ArgInfo("h", 0)) &&
        jsopencv_to_safe(jsobj_templateWindowSize, templateWindowSize, ArgInfo("templateWindowSize", 0)) &&
        jsopencv_to_safe(jsobj_searchWindowSize, searchWindowSize, ArgInfo("searchWindowSize", 0)))
    {
        ERRWRAP2_NAPI(info, cv::fastNlMeansDenoisingMulti(srcImgs, dst, imgToDenoiseIndex, temporalWindowSize, h, templateWindowSize, searchWindowSize));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_srcImgs = NULL;
    vector_UMat srcImgs;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_imgToDenoiseIndex = NULL;
    int imgToDenoiseIndex=0;
    Napi::Value* jsobj_temporalWindowSize = NULL;
    int temporalWindowSize=0;
    Napi::Value* jsobj_h = NULL;
    float h=3;
    Napi::Value* jsobj_templateWindowSize = NULL;
    int templateWindowSize=7;
    Napi::Value* jsobj_searchWindowSize = NULL;
    int searchWindowSize=21;

    const char* keywords[] = { "srcImgs", "imgToDenoiseIndex", "temporalWindowSize", "dst", "h", "templateWindowSize", "searchWindowSize", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOOO:fastNlMeansDenoisingMulti", (char**)keywords, &jsobj_srcImgs, &jsobj_imgToDenoiseIndex, &jsobj_temporalWindowSize, &jsobj_dst, &jsobj_h, &jsobj_templateWindowSize, &jsobj_searchWindowSize) &&
        jsopencv_to_safe(jsobj_srcImgs, srcImgs, ArgInfo("srcImgs", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_imgToDenoiseIndex, imgToDenoiseIndex, ArgInfo("imgToDenoiseIndex", 0)) &&
        jsopencv_to_safe(jsobj_temporalWindowSize, temporalWindowSize, ArgInfo("temporalWindowSize", 0)) &&
        jsopencv_to_safe(jsobj_h, h, ArgInfo("h", 0)) &&
        jsopencv_to_safe(jsobj_templateWindowSize, templateWindowSize, ArgInfo("templateWindowSize", 0)) &&
        jsopencv_to_safe(jsobj_searchWindowSize, searchWindowSize, ArgInfo("searchWindowSize", 0)))
    {
        ERRWRAP2_NAPI(info, cv::fastNlMeansDenoisingMulti(srcImgs, dst, imgToDenoiseIndex, temporalWindowSize, h, templateWindowSize, searchWindowSize));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_srcImgs = NULL;
    vector_Mat srcImgs;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_imgToDenoiseIndex = NULL;
    int imgToDenoiseIndex=0;
    Napi::Value* jsobj_temporalWindowSize = NULL;
    int temporalWindowSize=0;
    Napi::Value* jsobj_h = NULL;
    vector_float h;
    Napi::Value* jsobj_templateWindowSize = NULL;
    int templateWindowSize=7;
    Napi::Value* jsobj_searchWindowSize = NULL;
    int searchWindowSize=21;
    Napi::Value* jsobj_normType = NULL;
    int normType=NORM_L2;

    const char* keywords[] = { "srcImgs", "imgToDenoiseIndex", "temporalWindowSize", "h", "dst", "templateWindowSize", "searchWindowSize", "normType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOOO:fastNlMeansDenoisingMulti", (char**)keywords, &jsobj_srcImgs, &jsobj_imgToDenoiseIndex, &jsobj_temporalWindowSize, &jsobj_h, &jsobj_dst, &jsobj_templateWindowSize, &jsobj_searchWindowSize, &jsobj_normType) &&
        jsopencv_to_safe(jsobj_srcImgs, srcImgs, ArgInfo("srcImgs", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_imgToDenoiseIndex, imgToDenoiseIndex, ArgInfo("imgToDenoiseIndex", 0)) &&
        jsopencv_to_safe(jsobj_temporalWindowSize, temporalWindowSize, ArgInfo("temporalWindowSize", 0)) &&
        jsopencv_to_safe(jsobj_h, h, ArgInfo("h", 0)) &&
        jsopencv_to_safe(jsobj_templateWindowSize, templateWindowSize, ArgInfo("templateWindowSize", 0)) &&
        jsopencv_to_safe(jsobj_searchWindowSize, searchWindowSize, ArgInfo("searchWindowSize", 0)) &&
        jsopencv_to_safe(jsobj_normType, normType, ArgInfo("normType", 0)))
    {
        ERRWRAP2_NAPI(info, cv::fastNlMeansDenoisingMulti(srcImgs, dst, imgToDenoiseIndex, temporalWindowSize, h, templateWindowSize, searchWindowSize, normType));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_srcImgs = NULL;
    vector_UMat srcImgs;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_imgToDenoiseIndex = NULL;
    int imgToDenoiseIndex=0;
    Napi::Value* jsobj_temporalWindowSize = NULL;
    int temporalWindowSize=0;
    Napi::Value* jsobj_h = NULL;
    vector_float h;
    Napi::Value* jsobj_templateWindowSize = NULL;
    int templateWindowSize=7;
    Napi::Value* jsobj_searchWindowSize = NULL;
    int searchWindowSize=21;
    Napi::Value* jsobj_normType = NULL;
    int normType=NORM_L2;

    const char* keywords[] = { "srcImgs", "imgToDenoiseIndex", "temporalWindowSize", "h", "dst", "templateWindowSize", "searchWindowSize", "normType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOOO:fastNlMeansDenoisingMulti", (char**)keywords, &jsobj_srcImgs, &jsobj_imgToDenoiseIndex, &jsobj_temporalWindowSize, &jsobj_h, &jsobj_dst, &jsobj_templateWindowSize, &jsobj_searchWindowSize, &jsobj_normType) &&
        jsopencv_to_safe(jsobj_srcImgs, srcImgs, ArgInfo("srcImgs", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_imgToDenoiseIndex, imgToDenoiseIndex, ArgInfo("imgToDenoiseIndex", 0)) &&
        jsopencv_to_safe(jsobj_temporalWindowSize, temporalWindowSize, ArgInfo("temporalWindowSize", 0)) &&
        jsopencv_to_safe(jsobj_h, h, ArgInfo("h", 0)) &&
        jsopencv_to_safe(jsobj_templateWindowSize, templateWindowSize, ArgInfo("templateWindowSize", 0)) &&
        jsopencv_to_safe(jsobj_searchWindowSize, searchWindowSize, ArgInfo("searchWindowSize", 0)) &&
        jsopencv_to_safe(jsobj_normType, normType, ArgInfo("normType", 0)))
    {
        ERRWRAP2_NAPI(info, cv::fastNlMeansDenoisingMulti(srcImgs, dst, imgToDenoiseIndex, temporalWindowSize, h, templateWindowSize, searchWindowSize, normType));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "fastNlMeansDenoisingMulti");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_fillConvexPoly(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_img = NULL;
    Mat img;
    Napi::Value* jsobj_points = NULL;
    Mat points;
    Napi::Value* jsobj_color = NULL;
    Scalar color;
    Napi::Value* jsobj_lineType = NULL;
    int lineType=LINE_8;
    Napi::Value* jsobj_shift = NULL;
    int shift=0;

    const char* keywords[] = { "img", "points", "color", "lineType", "shift", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OO:fillConvexPoly", (char**)keywords, &jsobj_img, &jsobj_points, &jsobj_color, &jsobj_lineType, &jsobj_shift) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 1)) &&
        jsopencv_to_safe(jsobj_points, points, ArgInfo("points", 0)) &&
        jsopencv_to_safe(jsobj_color, color, ArgInfo("color", 0)) &&
        jsopencv_to_safe(jsobj_lineType, lineType, ArgInfo("lineType", 0)) &&
        jsopencv_to_safe(jsobj_shift, shift, ArgInfo("shift", 0)))
    {
        ERRWRAP2_NAPI(info, cv::fillConvexPoly(img, points, color, lineType, shift));
        return jsopencv_from(info, img);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_img = NULL;
    UMat img;
    Napi::Value* jsobj_points = NULL;
    UMat points;
    Napi::Value* jsobj_color = NULL;
    Scalar color;
    Napi::Value* jsobj_lineType = NULL;
    int lineType=LINE_8;
    Napi::Value* jsobj_shift = NULL;
    int shift=0;

    const char* keywords[] = { "img", "points", "color", "lineType", "shift", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OO:fillConvexPoly", (char**)keywords, &jsobj_img, &jsobj_points, &jsobj_color, &jsobj_lineType, &jsobj_shift) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 1)) &&
        jsopencv_to_safe(jsobj_points, points, ArgInfo("points", 0)) &&
        jsopencv_to_safe(jsobj_color, color, ArgInfo("color", 0)) &&
        jsopencv_to_safe(jsobj_lineType, lineType, ArgInfo("lineType", 0)) &&
        jsopencv_to_safe(jsobj_shift, shift, ArgInfo("shift", 0)))
    {
        ERRWRAP2_NAPI(info, cv::fillConvexPoly(img, points, color, lineType, shift));
        return jsopencv_from(info, img);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "fillConvexPoly");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_fillPoly(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_img = NULL;
    Mat img;
    Napi::Value* jsobj_pts = NULL;
    vector_Mat pts;
    Napi::Value* jsobj_color = NULL;
    Scalar color;
    Napi::Value* jsobj_lineType = NULL;
    int lineType=LINE_8;
    Napi::Value* jsobj_shift = NULL;
    int shift=0;
    Napi::Value* jsobj_offset = NULL;
    Point offset;

    const char* keywords[] = { "img", "pts", "color", "lineType", "shift", "offset", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOO:fillPoly", (char**)keywords, &jsobj_img, &jsobj_pts, &jsobj_color, &jsobj_lineType, &jsobj_shift, &jsobj_offset) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 1)) &&
        jsopencv_to_safe(jsobj_pts, pts, ArgInfo("pts", 0)) &&
        jsopencv_to_safe(jsobj_color, color, ArgInfo("color", 0)) &&
        jsopencv_to_safe(jsobj_lineType, lineType, ArgInfo("lineType", 0)) &&
        jsopencv_to_safe(jsobj_shift, shift, ArgInfo("shift", 0)) &&
        jsopencv_to_safe(jsobj_offset, offset, ArgInfo("offset", 0)))
    {
        ERRWRAP2_NAPI(info, cv::fillPoly(img, pts, color, lineType, shift, offset));
        return jsopencv_from(info, img);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_img = NULL;
    UMat img;
    Napi::Value* jsobj_pts = NULL;
    vector_UMat pts;
    Napi::Value* jsobj_color = NULL;
    Scalar color;
    Napi::Value* jsobj_lineType = NULL;
    int lineType=LINE_8;
    Napi::Value* jsobj_shift = NULL;
    int shift=0;
    Napi::Value* jsobj_offset = NULL;
    Point offset;

    const char* keywords[] = { "img", "pts", "color", "lineType", "shift", "offset", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOO:fillPoly", (char**)keywords, &jsobj_img, &jsobj_pts, &jsobj_color, &jsobj_lineType, &jsobj_shift, &jsobj_offset) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 1)) &&
        jsopencv_to_safe(jsobj_pts, pts, ArgInfo("pts", 0)) &&
        jsopencv_to_safe(jsobj_color, color, ArgInfo("color", 0)) &&
        jsopencv_to_safe(jsobj_lineType, lineType, ArgInfo("lineType", 0)) &&
        jsopencv_to_safe(jsobj_shift, shift, ArgInfo("shift", 0)) &&
        jsopencv_to_safe(jsobj_offset, offset, ArgInfo("offset", 0)))
    {
        ERRWRAP2_NAPI(info, cv::fillPoly(img, pts, color, lineType, shift, offset));
        return jsopencv_from(info, img);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "fillPoly");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_filter2D(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_ddepth = NULL;
    int ddepth=0;
    Napi::Value* jsobj_kernel = NULL;
    Mat kernel;
    Napi::Value* jsobj_anchor = NULL;
    Point anchor=Point(-1,-1);
    Napi::Value* jsobj_delta = NULL;
    double delta=0;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_DEFAULT;

    const char* keywords[] = { "src", "ddepth", "kernel", "dst", "anchor", "delta", "borderType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOOO:filter2D", (char**)keywords, &jsobj_src, &jsobj_ddepth, &jsobj_kernel, &jsobj_dst, &jsobj_anchor, &jsobj_delta, &jsobj_borderType) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_ddepth, ddepth, ArgInfo("ddepth", 0)) &&
        jsopencv_to_safe(jsobj_kernel, kernel, ArgInfo("kernel", 0)) &&
        jsopencv_to_safe(jsobj_anchor, anchor, ArgInfo("anchor", 0)) &&
        jsopencv_to_safe(jsobj_delta, delta, ArgInfo("delta", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)))
    {
        ERRWRAP2_NAPI(info, cv::filter2D(src, dst, ddepth, kernel, anchor, delta, borderType));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_ddepth = NULL;
    int ddepth=0;
    Napi::Value* jsobj_kernel = NULL;
    UMat kernel;
    Napi::Value* jsobj_anchor = NULL;
    Point anchor=Point(-1,-1);
    Napi::Value* jsobj_delta = NULL;
    double delta=0;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_DEFAULT;

    const char* keywords[] = { "src", "ddepth", "kernel", "dst", "anchor", "delta", "borderType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOOO:filter2D", (char**)keywords, &jsobj_src, &jsobj_ddepth, &jsobj_kernel, &jsobj_dst, &jsobj_anchor, &jsobj_delta, &jsobj_borderType) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_ddepth, ddepth, ArgInfo("ddepth", 0)) &&
        jsopencv_to_safe(jsobj_kernel, kernel, ArgInfo("kernel", 0)) &&
        jsopencv_to_safe(jsobj_anchor, anchor, ArgInfo("anchor", 0)) &&
        jsopencv_to_safe(jsobj_delta, delta, ArgInfo("delta", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)))
    {
        ERRWRAP2_NAPI(info, cv::filter2D(src, dst, ddepth, kernel, anchor, delta, borderType));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "filter2D");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_filterHomographyDecompByVisibleRefpoints(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_rotations = NULL;
    vector_Mat rotations;
    Napi::Value* jsobj_normals = NULL;
    vector_Mat normals;
    Napi::Value* jsobj_beforePoints = NULL;
    Mat beforePoints;
    Napi::Value* jsobj_afterPoints = NULL;
    Mat afterPoints;
    Napi::Value* jsobj_possibleSolutions = NULL;
    Mat possibleSolutions;
    Napi::Value* jsobj_pointsMask = NULL;
    Mat pointsMask;

    const char* keywords[] = { "rotations", "normals", "beforePoints", "afterPoints", "possibleSolutions", "pointsMask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OO:filterHomographyDecompByVisibleRefpoints", (char**)keywords, &jsobj_rotations, &jsobj_normals, &jsobj_beforePoints, &jsobj_afterPoints, &jsobj_possibleSolutions, &jsobj_pointsMask) &&
        jsopencv_to_safe(jsobj_rotations, rotations, ArgInfo("rotations", 0)) &&
        jsopencv_to_safe(jsobj_normals, normals, ArgInfo("normals", 0)) &&
        jsopencv_to_safe(jsobj_beforePoints, beforePoints, ArgInfo("beforePoints", 0)) &&
        jsopencv_to_safe(jsobj_afterPoints, afterPoints, ArgInfo("afterPoints", 0)) &&
        jsopencv_to_safe(jsobj_possibleSolutions, possibleSolutions, ArgInfo("possibleSolutions", 1)) &&
        jsopencv_to_safe(jsobj_pointsMask, pointsMask, ArgInfo("pointsMask", 0)))
    {
        ERRWRAP2_NAPI(info, cv::filterHomographyDecompByVisibleRefpoints(rotations, normals, beforePoints, afterPoints, possibleSolutions, pointsMask));
        return jsopencv_from(info, possibleSolutions);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_rotations = NULL;
    vector_UMat rotations;
    Napi::Value* jsobj_normals = NULL;
    vector_UMat normals;
    Napi::Value* jsobj_beforePoints = NULL;
    UMat beforePoints;
    Napi::Value* jsobj_afterPoints = NULL;
    UMat afterPoints;
    Napi::Value* jsobj_possibleSolutions = NULL;
    UMat possibleSolutions;
    Napi::Value* jsobj_pointsMask = NULL;
    UMat pointsMask;

    const char* keywords[] = { "rotations", "normals", "beforePoints", "afterPoints", "possibleSolutions", "pointsMask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OO:filterHomographyDecompByVisibleRefpoints", (char**)keywords, &jsobj_rotations, &jsobj_normals, &jsobj_beforePoints, &jsobj_afterPoints, &jsobj_possibleSolutions, &jsobj_pointsMask) &&
        jsopencv_to_safe(jsobj_rotations, rotations, ArgInfo("rotations", 0)) &&
        jsopencv_to_safe(jsobj_normals, normals, ArgInfo("normals", 0)) &&
        jsopencv_to_safe(jsobj_beforePoints, beforePoints, ArgInfo("beforePoints", 0)) &&
        jsopencv_to_safe(jsobj_afterPoints, afterPoints, ArgInfo("afterPoints", 0)) &&
        jsopencv_to_safe(jsobj_possibleSolutions, possibleSolutions, ArgInfo("possibleSolutions", 1)) &&
        jsopencv_to_safe(jsobj_pointsMask, pointsMask, ArgInfo("pointsMask", 0)))
    {
        ERRWRAP2_NAPI(info, cv::filterHomographyDecompByVisibleRefpoints(rotations, normals, beforePoints, afterPoints, possibleSolutions, pointsMask));
        return jsopencv_from(info, possibleSolutions);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "filterHomographyDecompByVisibleRefpoints");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_filterSpeckles(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_img = NULL;
    Mat img;
    Napi::Value* jsobj_newVal = NULL;
    double newVal=0;
    Napi::Value* jsobj_maxSpeckleSize = NULL;
    int maxSpeckleSize=0;
    Napi::Value* jsobj_maxDiff = NULL;
    double maxDiff=0;
    Napi::Value* jsobj_buf = NULL;
    Mat buf;

    const char* keywords[] = { "img", "newVal", "maxSpeckleSize", "maxDiff", "buf", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|O:filterSpeckles", (char**)keywords, &jsobj_img, &jsobj_newVal, &jsobj_maxSpeckleSize, &jsobj_maxDiff, &jsobj_buf) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 1)) &&
        jsopencv_to_safe(jsobj_newVal, newVal, ArgInfo("newVal", 0)) &&
        jsopencv_to_safe(jsobj_maxSpeckleSize, maxSpeckleSize, ArgInfo("maxSpeckleSize", 0)) &&
        jsopencv_to_safe(jsobj_maxDiff, maxDiff, ArgInfo("maxDiff", 0)) &&
        jsopencv_to_safe(jsobj_buf, buf, ArgInfo("buf", 1)))
    {
        ERRWRAP2_NAPI(info, cv::filterSpeckles(img, newVal, maxSpeckleSize, maxDiff, buf));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, img), jsopencv_from(info, buf));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_img = NULL;
    UMat img;
    Napi::Value* jsobj_newVal = NULL;
    double newVal=0;
    Napi::Value* jsobj_maxSpeckleSize = NULL;
    int maxSpeckleSize=0;
    Napi::Value* jsobj_maxDiff = NULL;
    double maxDiff=0;
    Napi::Value* jsobj_buf = NULL;
    UMat buf;

    const char* keywords[] = { "img", "newVal", "maxSpeckleSize", "maxDiff", "buf", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|O:filterSpeckles", (char**)keywords, &jsobj_img, &jsobj_newVal, &jsobj_maxSpeckleSize, &jsobj_maxDiff, &jsobj_buf) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 1)) &&
        jsopencv_to_safe(jsobj_newVal, newVal, ArgInfo("newVal", 0)) &&
        jsopencv_to_safe(jsobj_maxSpeckleSize, maxSpeckleSize, ArgInfo("maxSpeckleSize", 0)) &&
        jsopencv_to_safe(jsobj_maxDiff, maxDiff, ArgInfo("maxDiff", 0)) &&
        jsopencv_to_safe(jsobj_buf, buf, ArgInfo("buf", 1)))
    {
        ERRWRAP2_NAPI(info, cv::filterSpeckles(img, newVal, maxSpeckleSize, maxDiff, buf));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, img), jsopencv_from(info, buf));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "filterSpeckles");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_find4QuadCornerSubpix(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_img = NULL;
    Mat img;
    Napi::Value* jsobj_corners = NULL;
    Mat corners;
    Napi::Value* jsobj_region_size = NULL;
    Size region_size;
    bool retval;

    const char* keywords[] = { "img", "corners", "region_size", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:find4QuadCornerSubpix", (char**)keywords, &jsobj_img, &jsobj_corners, &jsobj_region_size) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 0)) &&
        jsopencv_to_safe(jsobj_corners, corners, ArgInfo("corners", 1)) &&
        jsopencv_to_safe(jsobj_region_size, region_size, ArgInfo("region_size", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::find4QuadCornerSubpix(img, corners, region_size));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, corners));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_img = NULL;
    UMat img;
    Napi::Value* jsobj_corners = NULL;
    UMat corners;
    Napi::Value* jsobj_region_size = NULL;
    Size region_size;
    bool retval;

    const char* keywords[] = { "img", "corners", "region_size", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:find4QuadCornerSubpix", (char**)keywords, &jsobj_img, &jsobj_corners, &jsobj_region_size) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 0)) &&
        jsopencv_to_safe(jsobj_corners, corners, ArgInfo("corners", 1)) &&
        jsopencv_to_safe(jsobj_region_size, region_size, ArgInfo("region_size", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::find4QuadCornerSubpix(img, corners, region_size));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, corners));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "find4QuadCornerSubpix");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_findChessboardCorners(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_image = NULL;
    Mat image;
    Napi::Value* jsobj_patternSize = NULL;
    Size patternSize;
    Napi::Value* jsobj_corners = NULL;
    Mat corners;
    Napi::Value* jsobj_flags = NULL;
    int flags=CALIB_CB_ADAPTIVE_THRESH + CALIB_CB_NORMALIZE_IMAGE;
    bool retval;

    const char* keywords[] = { "image", "patternSize", "corners", "flags", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:findChessboardCorners", (char**)keywords, &jsobj_image, &jsobj_patternSize, &jsobj_corners, &jsobj_flags) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_patternSize, patternSize, ArgInfo("patternSize", 0)) &&
        jsopencv_to_safe(jsobj_corners, corners, ArgInfo("corners", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::findChessboardCorners(image, patternSize, corners, flags));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, corners));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_image = NULL;
    UMat image;
    Napi::Value* jsobj_patternSize = NULL;
    Size patternSize;
    Napi::Value* jsobj_corners = NULL;
    UMat corners;
    Napi::Value* jsobj_flags = NULL;
    int flags=CALIB_CB_ADAPTIVE_THRESH + CALIB_CB_NORMALIZE_IMAGE;
    bool retval;

    const char* keywords[] = { "image", "patternSize", "corners", "flags", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:findChessboardCorners", (char**)keywords, &jsobj_image, &jsobj_patternSize, &jsobj_corners, &jsobj_flags) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_patternSize, patternSize, ArgInfo("patternSize", 0)) &&
        jsopencv_to_safe(jsobj_corners, corners, ArgInfo("corners", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::findChessboardCorners(image, patternSize, corners, flags));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, corners));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "findChessboardCorners");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_findChessboardCornersSB(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_image = NULL;
    Mat image;
    Napi::Value* jsobj_patternSize = NULL;
    Size patternSize;
    Napi::Value* jsobj_corners = NULL;
    Mat corners;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;
    bool retval;

    const char* keywords[] = { "image", "patternSize", "corners", "flags", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:findChessboardCornersSB", (char**)keywords, &jsobj_image, &jsobj_patternSize, &jsobj_corners, &jsobj_flags) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_patternSize, patternSize, ArgInfo("patternSize", 0)) &&
        jsopencv_to_safe(jsobj_corners, corners, ArgInfo("corners", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::findChessboardCornersSB(image, patternSize, corners, flags));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, corners));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_image = NULL;
    UMat image;
    Napi::Value* jsobj_patternSize = NULL;
    Size patternSize;
    Napi::Value* jsobj_corners = NULL;
    UMat corners;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;
    bool retval;

    const char* keywords[] = { "image", "patternSize", "corners", "flags", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:findChessboardCornersSB", (char**)keywords, &jsobj_image, &jsobj_patternSize, &jsobj_corners, &jsobj_flags) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_patternSize, patternSize, ArgInfo("patternSize", 0)) &&
        jsopencv_to_safe(jsobj_corners, corners, ArgInfo("corners", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::findChessboardCornersSB(image, patternSize, corners, flags));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, corners));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "findChessboardCornersSB");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_findChessboardCornersSBWithMeta(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_image = NULL;
    Mat image;
    Napi::Value* jsobj_patternSize = NULL;
    Size patternSize;
    Napi::Value* jsobj_corners = NULL;
    Mat corners;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;
    Napi::Value* jsobj_meta = NULL;
    Mat meta;
    bool retval;

    const char* keywords[] = { "image", "patternSize", "flags", "corners", "meta", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OO:findChessboardCornersSBWithMeta", (char**)keywords, &jsobj_image, &jsobj_patternSize, &jsobj_flags, &jsobj_corners, &jsobj_meta) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_patternSize, patternSize, ArgInfo("patternSize", 0)) &&
        jsopencv_to_safe(jsobj_corners, corners, ArgInfo("corners", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_meta, meta, ArgInfo("meta", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::findChessboardCornersSB(image, patternSize, corners, flags, meta));
        return Js_BuildValue(info, "(NNN)", jsopencv_from(info, retval), jsopencv_from(info, corners), jsopencv_from(info, meta));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_image = NULL;
    UMat image;
    Napi::Value* jsobj_patternSize = NULL;
    Size patternSize;
    Napi::Value* jsobj_corners = NULL;
    UMat corners;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;
    Napi::Value* jsobj_meta = NULL;
    UMat meta;
    bool retval;

    const char* keywords[] = { "image", "patternSize", "flags", "corners", "meta", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OO:findChessboardCornersSBWithMeta", (char**)keywords, &jsobj_image, &jsobj_patternSize, &jsobj_flags, &jsobj_corners, &jsobj_meta) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_patternSize, patternSize, ArgInfo("patternSize", 0)) &&
        jsopencv_to_safe(jsobj_corners, corners, ArgInfo("corners", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_meta, meta, ArgInfo("meta", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::findChessboardCornersSB(image, patternSize, corners, flags, meta));
        return Js_BuildValue(info, "(NNN)", jsopencv_from(info, retval), jsopencv_from(info, corners), jsopencv_from(info, meta));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "findChessboardCornersSBWithMeta");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_findCirclesGrid(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(4);

    {
    Napi::Value* jsobj_image = NULL;
    Mat image;
    Napi::Value* jsobj_patternSize = NULL;
    Size patternSize;
    Napi::Value* jsobj_centers = NULL;
    Mat centers;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;
    Napi::Value* jsobj_blobDetector = NULL;
    Ptr<FeatureDetector> blobDetector;
    Napi::Value* jsobj_parameters = NULL;
    cv::CirclesGridFinderParameters parameters;
    bool retval;

    const char* keywords[] = { "image", "patternSize", "flags", "blobDetector", "parameters", "centers", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOO|O:findCirclesGrid", (char**)keywords, &jsobj_image, &jsobj_patternSize, &jsobj_flags, &jsobj_blobDetector, &jsobj_parameters, &jsobj_centers) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_patternSize, patternSize, ArgInfo("patternSize", 0)) &&
        jsopencv_to_safe(jsobj_centers, centers, ArgInfo("centers", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_blobDetector, blobDetector, ArgInfo("blobDetector", 0)) &&
        jsopencv_to_safe(jsobj_parameters, parameters, ArgInfo("parameters", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::findCirclesGrid(image, patternSize, centers, flags, blobDetector, parameters));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, centers));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_image = NULL;
    UMat image;
    Napi::Value* jsobj_patternSize = NULL;
    Size patternSize;
    Napi::Value* jsobj_centers = NULL;
    UMat centers;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;
    Napi::Value* jsobj_blobDetector = NULL;
    Ptr<FeatureDetector> blobDetector;
    Napi::Value* jsobj_parameters = NULL;
    cv::CirclesGridFinderParameters parameters;
    bool retval;

    const char* keywords[] = { "image", "patternSize", "flags", "blobDetector", "parameters", "centers", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOO|O:findCirclesGrid", (char**)keywords, &jsobj_image, &jsobj_patternSize, &jsobj_flags, &jsobj_blobDetector, &jsobj_parameters, &jsobj_centers) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_patternSize, patternSize, ArgInfo("patternSize", 0)) &&
        jsopencv_to_safe(jsobj_centers, centers, ArgInfo("centers", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_blobDetector, blobDetector, ArgInfo("blobDetector", 0)) &&
        jsopencv_to_safe(jsobj_parameters, parameters, ArgInfo("parameters", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::findCirclesGrid(image, patternSize, centers, flags, blobDetector, parameters));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, centers));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_image = NULL;
    Mat image;
    Napi::Value* jsobj_patternSize = NULL;
    Size patternSize;
    Napi::Value* jsobj_centers = NULL;
    Mat centers;
    Napi::Value* jsobj_flags = NULL;
    int flags=CALIB_CB_SYMMETRIC_GRID;
    Napi::Value* jsobj_blobDetector = NULL;
    Ptr<FeatureDetector> blobDetector=SimpleBlobDetector::create();
    bool retval;

    const char* keywords[] = { "image", "patternSize", "centers", "flags", "blobDetector", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOO:findCirclesGrid", (char**)keywords, &jsobj_image, &jsobj_patternSize, &jsobj_centers, &jsobj_flags, &jsobj_blobDetector) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_patternSize, patternSize, ArgInfo("patternSize", 0)) &&
        jsopencv_to_safe(jsobj_centers, centers, ArgInfo("centers", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_blobDetector, blobDetector, ArgInfo("blobDetector", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::findCirclesGrid(image, patternSize, centers, flags, blobDetector));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, centers));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_image = NULL;
    UMat image;
    Napi::Value* jsobj_patternSize = NULL;
    Size patternSize;
    Napi::Value* jsobj_centers = NULL;
    UMat centers;
    Napi::Value* jsobj_flags = NULL;
    int flags=CALIB_CB_SYMMETRIC_GRID;
    Napi::Value* jsobj_blobDetector = NULL;
    Ptr<FeatureDetector> blobDetector=SimpleBlobDetector::create();
    bool retval;

    const char* keywords[] = { "image", "patternSize", "centers", "flags", "blobDetector", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOO:findCirclesGrid", (char**)keywords, &jsobj_image, &jsobj_patternSize, &jsobj_centers, &jsobj_flags, &jsobj_blobDetector) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_patternSize, patternSize, ArgInfo("patternSize", 0)) &&
        jsopencv_to_safe(jsobj_centers, centers, ArgInfo("centers", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_blobDetector, blobDetector, ArgInfo("blobDetector", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::findCirclesGrid(image, patternSize, centers, flags, blobDetector));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, centers));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "findCirclesGrid");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_findContours(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_image = NULL;
    Mat image;
    Napi::Value* jsobj_contours = NULL;
    vector_Mat contours;
    Napi::Value* jsobj_hierarchy = NULL;
    Mat hierarchy;
    Napi::Value* jsobj_mode = NULL;
    int mode=0;
    Napi::Value* jsobj_method = NULL;
    int method=0;
    Napi::Value* jsobj_offset = NULL;
    Point offset;

    const char* keywords[] = { "image", "mode", "method", "contours", "hierarchy", "offset", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOO:findContours", (char**)keywords, &jsobj_image, &jsobj_mode, &jsobj_method, &jsobj_contours, &jsobj_hierarchy, &jsobj_offset) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_contours, contours, ArgInfo("contours", 1)) &&
        jsopencv_to_safe(jsobj_hierarchy, hierarchy, ArgInfo("hierarchy", 1)) &&
        jsopencv_to_safe(jsobj_mode, mode, ArgInfo("mode", 0)) &&
        jsopencv_to_safe(jsobj_method, method, ArgInfo("method", 0)) &&
        jsopencv_to_safe(jsobj_offset, offset, ArgInfo("offset", 0)))
    {
        ERRWRAP2_NAPI(info, cv::findContours(image, contours, hierarchy, mode, method, offset));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, contours), jsopencv_from(info, hierarchy));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_image = NULL;
    UMat image;
    Napi::Value* jsobj_contours = NULL;
    vector_UMat contours;
    Napi::Value* jsobj_hierarchy = NULL;
    UMat hierarchy;
    Napi::Value* jsobj_mode = NULL;
    int mode=0;
    Napi::Value* jsobj_method = NULL;
    int method=0;
    Napi::Value* jsobj_offset = NULL;
    Point offset;

    const char* keywords[] = { "image", "mode", "method", "contours", "hierarchy", "offset", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOO:findContours", (char**)keywords, &jsobj_image, &jsobj_mode, &jsobj_method, &jsobj_contours, &jsobj_hierarchy, &jsobj_offset) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_contours, contours, ArgInfo("contours", 1)) &&
        jsopencv_to_safe(jsobj_hierarchy, hierarchy, ArgInfo("hierarchy", 1)) &&
        jsopencv_to_safe(jsobj_mode, mode, ArgInfo("mode", 0)) &&
        jsopencv_to_safe(jsobj_method, method, ArgInfo("method", 0)) &&
        jsopencv_to_safe(jsobj_offset, offset, ArgInfo("offset", 0)))
    {
        ERRWRAP2_NAPI(info, cv::findContours(image, contours, hierarchy, mode, method, offset));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, contours), jsopencv_from(info, hierarchy));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "findContours");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_findEssentialMat(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(8);

    {
    Napi::Value* jsobj_points1 = NULL;
    Mat points1;
    Napi::Value* jsobj_points2 = NULL;
    Mat points2;
    Napi::Value* jsobj_cameraMatrix = NULL;
    Mat cameraMatrix;
    Napi::Value* jsobj_method = NULL;
    int method=RANSAC;
    Napi::Value* jsobj_prob = NULL;
    double prob=0.999;
    Napi::Value* jsobj_threshold = NULL;
    double threshold=1.0;
    Napi::Value* jsobj_maxIters = NULL;
    int maxIters=1000;
    Napi::Value* jsobj_mask = NULL;
    Mat mask;
    Mat retval;

    const char* keywords[] = { "points1", "points2", "cameraMatrix", "method", "prob", "threshold", "maxIters", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOOOO:findEssentialMat", (char**)keywords, &jsobj_points1, &jsobj_points2, &jsobj_cameraMatrix, &jsobj_method, &jsobj_prob, &jsobj_threshold, &jsobj_maxIters, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_points1, points1, ArgInfo("points1", 0)) &&
        jsopencv_to_safe(jsobj_points2, points2, ArgInfo("points2", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 0)) &&
        jsopencv_to_safe(jsobj_method, method, ArgInfo("method", 0)) &&
        jsopencv_to_safe(jsobj_prob, prob, ArgInfo("prob", 0)) &&
        jsopencv_to_safe(jsobj_threshold, threshold, ArgInfo("threshold", 0)) &&
        jsopencv_to_safe(jsobj_maxIters, maxIters, ArgInfo("maxIters", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::findEssentialMat(points1, points2, cameraMatrix, method, prob, threshold, maxIters, mask));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, mask));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_points1 = NULL;
    UMat points1;
    Napi::Value* jsobj_points2 = NULL;
    UMat points2;
    Napi::Value* jsobj_cameraMatrix = NULL;
    UMat cameraMatrix;
    Napi::Value* jsobj_method = NULL;
    int method=RANSAC;
    Napi::Value* jsobj_prob = NULL;
    double prob=0.999;
    Napi::Value* jsobj_threshold = NULL;
    double threshold=1.0;
    Napi::Value* jsobj_maxIters = NULL;
    int maxIters=1000;
    Napi::Value* jsobj_mask = NULL;
    UMat mask;
    Mat retval;

    const char* keywords[] = { "points1", "points2", "cameraMatrix", "method", "prob", "threshold", "maxIters", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOOOO:findEssentialMat", (char**)keywords, &jsobj_points1, &jsobj_points2, &jsobj_cameraMatrix, &jsobj_method, &jsobj_prob, &jsobj_threshold, &jsobj_maxIters, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_points1, points1, ArgInfo("points1", 0)) &&
        jsopencv_to_safe(jsobj_points2, points2, ArgInfo("points2", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 0)) &&
        jsopencv_to_safe(jsobj_method, method, ArgInfo("method", 0)) &&
        jsopencv_to_safe(jsobj_prob, prob, ArgInfo("prob", 0)) &&
        jsopencv_to_safe(jsobj_threshold, threshold, ArgInfo("threshold", 0)) &&
        jsopencv_to_safe(jsobj_maxIters, maxIters, ArgInfo("maxIters", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::findEssentialMat(points1, points2, cameraMatrix, method, prob, threshold, maxIters, mask));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, mask));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_points1 = NULL;
    Mat points1;
    Napi::Value* jsobj_points2 = NULL;
    Mat points2;
    Napi::Value* jsobj_focal = NULL;
    double focal=1.0;
    Napi::Value* jsobj_pp = NULL;
    Point2d pp=Point2d(0, 0);
    Napi::Value* jsobj_method = NULL;
    int method=RANSAC;
    Napi::Value* jsobj_prob = NULL;
    double prob=0.999;
    Napi::Value* jsobj_threshold = NULL;
    double threshold=1.0;
    Napi::Value* jsobj_maxIters = NULL;
    int maxIters=1000;
    Napi::Value* jsobj_mask = NULL;
    Mat mask;
    Mat retval;

    const char* keywords[] = { "points1", "points2", "focal", "pp", "method", "prob", "threshold", "maxIters", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOOOOOO:findEssentialMat", (char**)keywords, &jsobj_points1, &jsobj_points2, &jsobj_focal, &jsobj_pp, &jsobj_method, &jsobj_prob, &jsobj_threshold, &jsobj_maxIters, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_points1, points1, ArgInfo("points1", 0)) &&
        jsopencv_to_safe(jsobj_points2, points2, ArgInfo("points2", 0)) &&
        jsopencv_to_safe(jsobj_focal, focal, ArgInfo("focal", 0)) &&
        jsopencv_to_safe(jsobj_pp, pp, ArgInfo("pp", 0)) &&
        jsopencv_to_safe(jsobj_method, method, ArgInfo("method", 0)) &&
        jsopencv_to_safe(jsobj_prob, prob, ArgInfo("prob", 0)) &&
        jsopencv_to_safe(jsobj_threshold, threshold, ArgInfo("threshold", 0)) &&
        jsopencv_to_safe(jsobj_maxIters, maxIters, ArgInfo("maxIters", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::findEssentialMat(points1, points2, focal, pp, method, prob, threshold, maxIters, mask));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, mask));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_points1 = NULL;
    UMat points1;
    Napi::Value* jsobj_points2 = NULL;
    UMat points2;
    Napi::Value* jsobj_focal = NULL;
    double focal=1.0;
    Napi::Value* jsobj_pp = NULL;
    Point2d pp=Point2d(0, 0);
    Napi::Value* jsobj_method = NULL;
    int method=RANSAC;
    Napi::Value* jsobj_prob = NULL;
    double prob=0.999;
    Napi::Value* jsobj_threshold = NULL;
    double threshold=1.0;
    Napi::Value* jsobj_maxIters = NULL;
    int maxIters=1000;
    Napi::Value* jsobj_mask = NULL;
    UMat mask;
    Mat retval;

    const char* keywords[] = { "points1", "points2", "focal", "pp", "method", "prob", "threshold", "maxIters", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOOOOOO:findEssentialMat", (char**)keywords, &jsobj_points1, &jsobj_points2, &jsobj_focal, &jsobj_pp, &jsobj_method, &jsobj_prob, &jsobj_threshold, &jsobj_maxIters, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_points1, points1, ArgInfo("points1", 0)) &&
        jsopencv_to_safe(jsobj_points2, points2, ArgInfo("points2", 0)) &&
        jsopencv_to_safe(jsobj_focal, focal, ArgInfo("focal", 0)) &&
        jsopencv_to_safe(jsobj_pp, pp, ArgInfo("pp", 0)) &&
        jsopencv_to_safe(jsobj_method, method, ArgInfo("method", 0)) &&
        jsopencv_to_safe(jsobj_prob, prob, ArgInfo("prob", 0)) &&
        jsopencv_to_safe(jsobj_threshold, threshold, ArgInfo("threshold", 0)) &&
        jsopencv_to_safe(jsobj_maxIters, maxIters, ArgInfo("maxIters", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::findEssentialMat(points1, points2, focal, pp, method, prob, threshold, maxIters, mask));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, mask));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_points1 = NULL;
    Mat points1;
    Napi::Value* jsobj_points2 = NULL;
    Mat points2;
    Napi::Value* jsobj_cameraMatrix1 = NULL;
    Mat cameraMatrix1;
    Napi::Value* jsobj_distCoeffs1 = NULL;
    Mat distCoeffs1;
    Napi::Value* jsobj_cameraMatrix2 = NULL;
    Mat cameraMatrix2;
    Napi::Value* jsobj_distCoeffs2 = NULL;
    Mat distCoeffs2;
    Napi::Value* jsobj_method = NULL;
    int method=RANSAC;
    Napi::Value* jsobj_prob = NULL;
    double prob=0.999;
    Napi::Value* jsobj_threshold = NULL;
    double threshold=1.0;
    Napi::Value* jsobj_mask = NULL;
    Mat mask;
    Mat retval;

    const char* keywords[] = { "points1", "points2", "cameraMatrix1", "distCoeffs1", "cameraMatrix2", "distCoeffs2", "method", "prob", "threshold", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOO|OOOO:findEssentialMat", (char**)keywords, &jsobj_points1, &jsobj_points2, &jsobj_cameraMatrix1, &jsobj_distCoeffs1, &jsobj_cameraMatrix2, &jsobj_distCoeffs2, &jsobj_method, &jsobj_prob, &jsobj_threshold, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_points1, points1, ArgInfo("points1", 0)) &&
        jsopencv_to_safe(jsobj_points2, points2, ArgInfo("points2", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix1, cameraMatrix1, ArgInfo("cameraMatrix1", 0)) &&
        jsopencv_to_safe(jsobj_distCoeffs1, distCoeffs1, ArgInfo("distCoeffs1", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix2, cameraMatrix2, ArgInfo("cameraMatrix2", 0)) &&
        jsopencv_to_safe(jsobj_distCoeffs2, distCoeffs2, ArgInfo("distCoeffs2", 0)) &&
        jsopencv_to_safe(jsobj_method, method, ArgInfo("method", 0)) &&
        jsopencv_to_safe(jsobj_prob, prob, ArgInfo("prob", 0)) &&
        jsopencv_to_safe(jsobj_threshold, threshold, ArgInfo("threshold", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::findEssentialMat(points1, points2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, method, prob, threshold, mask));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, mask));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_points1 = NULL;
    UMat points1;
    Napi::Value* jsobj_points2 = NULL;
    UMat points2;
    Napi::Value* jsobj_cameraMatrix1 = NULL;
    UMat cameraMatrix1;
    Napi::Value* jsobj_distCoeffs1 = NULL;
    UMat distCoeffs1;
    Napi::Value* jsobj_cameraMatrix2 = NULL;
    UMat cameraMatrix2;
    Napi::Value* jsobj_distCoeffs2 = NULL;
    UMat distCoeffs2;
    Napi::Value* jsobj_method = NULL;
    int method=RANSAC;
    Napi::Value* jsobj_prob = NULL;
    double prob=0.999;
    Napi::Value* jsobj_threshold = NULL;
    double threshold=1.0;
    Napi::Value* jsobj_mask = NULL;
    UMat mask;
    Mat retval;

    const char* keywords[] = { "points1", "points2", "cameraMatrix1", "distCoeffs1", "cameraMatrix2", "distCoeffs2", "method", "prob", "threshold", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOO|OOOO:findEssentialMat", (char**)keywords, &jsobj_points1, &jsobj_points2, &jsobj_cameraMatrix1, &jsobj_distCoeffs1, &jsobj_cameraMatrix2, &jsobj_distCoeffs2, &jsobj_method, &jsobj_prob, &jsobj_threshold, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_points1, points1, ArgInfo("points1", 0)) &&
        jsopencv_to_safe(jsobj_points2, points2, ArgInfo("points2", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix1, cameraMatrix1, ArgInfo("cameraMatrix1", 0)) &&
        jsopencv_to_safe(jsobj_distCoeffs1, distCoeffs1, ArgInfo("distCoeffs1", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix2, cameraMatrix2, ArgInfo("cameraMatrix2", 0)) &&
        jsopencv_to_safe(jsobj_distCoeffs2, distCoeffs2, ArgInfo("distCoeffs2", 0)) &&
        jsopencv_to_safe(jsobj_method, method, ArgInfo("method", 0)) &&
        jsopencv_to_safe(jsobj_prob, prob, ArgInfo("prob", 0)) &&
        jsopencv_to_safe(jsobj_threshold, threshold, ArgInfo("threshold", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::findEssentialMat(points1, points2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, method, prob, threshold, mask));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, mask));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_points1 = NULL;
    Mat points1;
    Napi::Value* jsobj_points2 = NULL;
    Mat points2;
    Napi::Value* jsobj_cameraMatrix1 = NULL;
    Mat cameraMatrix1;
    Napi::Value* jsobj_cameraMatrix2 = NULL;
    Mat cameraMatrix2;
    Napi::Value* jsobj_dist_coeff1 = NULL;
    Mat dist_coeff1;
    Napi::Value* jsobj_dist_coeff2 = NULL;
    Mat dist_coeff2;
    Napi::Value* jsobj_mask = NULL;
    Mat mask;
    Napi::Value* jsobj_params = NULL;
    cv::UsacParams params;
    Mat retval;

    const char* keywords[] = { "points1", "points2", "cameraMatrix1", "cameraMatrix2", "dist_coeff1", "dist_coeff2", "params", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOOO|O:findEssentialMat", (char**)keywords, &jsobj_points1, &jsobj_points2, &jsobj_cameraMatrix1, &jsobj_cameraMatrix2, &jsobj_dist_coeff1, &jsobj_dist_coeff2, &jsobj_params, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_points1, points1, ArgInfo("points1", 0)) &&
        jsopencv_to_safe(jsobj_points2, points2, ArgInfo("points2", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix1, cameraMatrix1, ArgInfo("cameraMatrix1", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix2, cameraMatrix2, ArgInfo("cameraMatrix2", 0)) &&
        jsopencv_to_safe(jsobj_dist_coeff1, dist_coeff1, ArgInfo("dist_coeff1", 0)) &&
        jsopencv_to_safe(jsobj_dist_coeff2, dist_coeff2, ArgInfo("dist_coeff2", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 1)) &&
        jsopencv_to_safe(jsobj_params, params, ArgInfo("params", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::findEssentialMat(points1, points2, cameraMatrix1, cameraMatrix2, dist_coeff1, dist_coeff2, mask, params));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, mask));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_points1 = NULL;
    UMat points1;
    Napi::Value* jsobj_points2 = NULL;
    UMat points2;
    Napi::Value* jsobj_cameraMatrix1 = NULL;
    UMat cameraMatrix1;
    Napi::Value* jsobj_cameraMatrix2 = NULL;
    UMat cameraMatrix2;
    Napi::Value* jsobj_dist_coeff1 = NULL;
    UMat dist_coeff1;
    Napi::Value* jsobj_dist_coeff2 = NULL;
    UMat dist_coeff2;
    Napi::Value* jsobj_mask = NULL;
    UMat mask;
    Napi::Value* jsobj_params = NULL;
    cv::UsacParams params;
    Mat retval;

    const char* keywords[] = { "points1", "points2", "cameraMatrix1", "cameraMatrix2", "dist_coeff1", "dist_coeff2", "params", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOOO|O:findEssentialMat", (char**)keywords, &jsobj_points1, &jsobj_points2, &jsobj_cameraMatrix1, &jsobj_cameraMatrix2, &jsobj_dist_coeff1, &jsobj_dist_coeff2, &jsobj_params, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_points1, points1, ArgInfo("points1", 0)) &&
        jsopencv_to_safe(jsobj_points2, points2, ArgInfo("points2", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix1, cameraMatrix1, ArgInfo("cameraMatrix1", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix2, cameraMatrix2, ArgInfo("cameraMatrix2", 0)) &&
        jsopencv_to_safe(jsobj_dist_coeff1, dist_coeff1, ArgInfo("dist_coeff1", 0)) &&
        jsopencv_to_safe(jsobj_dist_coeff2, dist_coeff2, ArgInfo("dist_coeff2", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 1)) &&
        jsopencv_to_safe(jsobj_params, params, ArgInfo("params", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::findEssentialMat(points1, points2, cameraMatrix1, cameraMatrix2, dist_coeff1, dist_coeff2, mask, params));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, mask));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "findEssentialMat");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_findFundamentalMat(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(6);

    {
    Napi::Value* jsobj_points1 = NULL;
    Mat points1;
    Napi::Value* jsobj_points2 = NULL;
    Mat points2;
    Napi::Value* jsobj_method = NULL;
    int method=0;
    Napi::Value* jsobj_ransacReprojThreshold = NULL;
    double ransacReprojThreshold=0;
    Napi::Value* jsobj_confidence = NULL;
    double confidence=0;
    Napi::Value* jsobj_maxIters = NULL;
    int maxIters=0;
    Napi::Value* jsobj_mask = NULL;
    Mat mask;
    Mat retval;

    const char* keywords[] = { "points1", "points2", "method", "ransacReprojThreshold", "confidence", "maxIters", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOO|O:findFundamentalMat", (char**)keywords, &jsobj_points1, &jsobj_points2, &jsobj_method, &jsobj_ransacReprojThreshold, &jsobj_confidence, &jsobj_maxIters, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_points1, points1, ArgInfo("points1", 0)) &&
        jsopencv_to_safe(jsobj_points2, points2, ArgInfo("points2", 0)) &&
        jsopencv_to_safe(jsobj_method, method, ArgInfo("method", 0)) &&
        jsopencv_to_safe(jsobj_ransacReprojThreshold, ransacReprojThreshold, ArgInfo("ransacReprojThreshold", 0)) &&
        jsopencv_to_safe(jsobj_confidence, confidence, ArgInfo("confidence", 0)) &&
        jsopencv_to_safe(jsobj_maxIters, maxIters, ArgInfo("maxIters", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::findFundamentalMat(points1, points2, method, ransacReprojThreshold, confidence, maxIters, mask));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, mask));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_points1 = NULL;
    UMat points1;
    Napi::Value* jsobj_points2 = NULL;
    UMat points2;
    Napi::Value* jsobj_method = NULL;
    int method=0;
    Napi::Value* jsobj_ransacReprojThreshold = NULL;
    double ransacReprojThreshold=0;
    Napi::Value* jsobj_confidence = NULL;
    double confidence=0;
    Napi::Value* jsobj_maxIters = NULL;
    int maxIters=0;
    Napi::Value* jsobj_mask = NULL;
    UMat mask;
    Mat retval;

    const char* keywords[] = { "points1", "points2", "method", "ransacReprojThreshold", "confidence", "maxIters", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOO|O:findFundamentalMat", (char**)keywords, &jsobj_points1, &jsobj_points2, &jsobj_method, &jsobj_ransacReprojThreshold, &jsobj_confidence, &jsobj_maxIters, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_points1, points1, ArgInfo("points1", 0)) &&
        jsopencv_to_safe(jsobj_points2, points2, ArgInfo("points2", 0)) &&
        jsopencv_to_safe(jsobj_method, method, ArgInfo("method", 0)) &&
        jsopencv_to_safe(jsobj_ransacReprojThreshold, ransacReprojThreshold, ArgInfo("ransacReprojThreshold", 0)) &&
        jsopencv_to_safe(jsobj_confidence, confidence, ArgInfo("confidence", 0)) &&
        jsopencv_to_safe(jsobj_maxIters, maxIters, ArgInfo("maxIters", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::findFundamentalMat(points1, points2, method, ransacReprojThreshold, confidence, maxIters, mask));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, mask));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_points1 = NULL;
    Mat points1;
    Napi::Value* jsobj_points2 = NULL;
    Mat points2;
    Napi::Value* jsobj_method = NULL;
    int method=FM_RANSAC;
    Napi::Value* jsobj_ransacReprojThreshold = NULL;
    double ransacReprojThreshold=3.;
    Napi::Value* jsobj_confidence = NULL;
    double confidence=0.99;
    Napi::Value* jsobj_mask = NULL;
    Mat mask;
    Mat retval;

    const char* keywords[] = { "points1", "points2", "method", "ransacReprojThreshold", "confidence", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOOO:findFundamentalMat", (char**)keywords, &jsobj_points1, &jsobj_points2, &jsobj_method, &jsobj_ransacReprojThreshold, &jsobj_confidence, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_points1, points1, ArgInfo("points1", 0)) &&
        jsopencv_to_safe(jsobj_points2, points2, ArgInfo("points2", 0)) &&
        jsopencv_to_safe(jsobj_method, method, ArgInfo("method", 0)) &&
        jsopencv_to_safe(jsobj_ransacReprojThreshold, ransacReprojThreshold, ArgInfo("ransacReprojThreshold", 0)) &&
        jsopencv_to_safe(jsobj_confidence, confidence, ArgInfo("confidence", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::findFundamentalMat(points1, points2, method, ransacReprojThreshold, confidence, mask));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, mask));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_points1 = NULL;
    UMat points1;
    Napi::Value* jsobj_points2 = NULL;
    UMat points2;
    Napi::Value* jsobj_method = NULL;
    int method=FM_RANSAC;
    Napi::Value* jsobj_ransacReprojThreshold = NULL;
    double ransacReprojThreshold=3.;
    Napi::Value* jsobj_confidence = NULL;
    double confidence=0.99;
    Napi::Value* jsobj_mask = NULL;
    UMat mask;
    Mat retval;

    const char* keywords[] = { "points1", "points2", "method", "ransacReprojThreshold", "confidence", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOOO:findFundamentalMat", (char**)keywords, &jsobj_points1, &jsobj_points2, &jsobj_method, &jsobj_ransacReprojThreshold, &jsobj_confidence, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_points1, points1, ArgInfo("points1", 0)) &&
        jsopencv_to_safe(jsobj_points2, points2, ArgInfo("points2", 0)) &&
        jsopencv_to_safe(jsobj_method, method, ArgInfo("method", 0)) &&
        jsopencv_to_safe(jsobj_ransacReprojThreshold, ransacReprojThreshold, ArgInfo("ransacReprojThreshold", 0)) &&
        jsopencv_to_safe(jsobj_confidence, confidence, ArgInfo("confidence", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::findFundamentalMat(points1, points2, method, ransacReprojThreshold, confidence, mask));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, mask));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_points1 = NULL;
    Mat points1;
    Napi::Value* jsobj_points2 = NULL;
    Mat points2;
    Napi::Value* jsobj_mask = NULL;
    Mat mask;
    Napi::Value* jsobj_params = NULL;
    cv::UsacParams params;
    Mat retval;

    const char* keywords[] = { "points1", "points2", "params", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:findFundamentalMat", (char**)keywords, &jsobj_points1, &jsobj_points2, &jsobj_params, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_points1, points1, ArgInfo("points1", 0)) &&
        jsopencv_to_safe(jsobj_points2, points2, ArgInfo("points2", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 1)) &&
        jsopencv_to_safe(jsobj_params, params, ArgInfo("params", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::findFundamentalMat(points1, points2, mask, params));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, mask));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_points1 = NULL;
    UMat points1;
    Napi::Value* jsobj_points2 = NULL;
    UMat points2;
    Napi::Value* jsobj_mask = NULL;
    UMat mask;
    Napi::Value* jsobj_params = NULL;
    cv::UsacParams params;
    Mat retval;

    const char* keywords[] = { "points1", "points2", "params", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:findFundamentalMat", (char**)keywords, &jsobj_points1, &jsobj_points2, &jsobj_params, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_points1, points1, ArgInfo("points1", 0)) &&
        jsopencv_to_safe(jsobj_points2, points2, ArgInfo("points2", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 1)) &&
        jsopencv_to_safe(jsobj_params, params, ArgInfo("params", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::findFundamentalMat(points1, points2, mask, params));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, mask));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "findFundamentalMat");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_findHomography(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(4);

    {
    Napi::Value* jsobj_srcPoints = NULL;
    Mat srcPoints;
    Napi::Value* jsobj_dstPoints = NULL;
    Mat dstPoints;
    Napi::Value* jsobj_method = NULL;
    int method=0;
    Napi::Value* jsobj_ransacReprojThreshold = NULL;
    double ransacReprojThreshold=3;
    Napi::Value* jsobj_mask = NULL;
    Mat mask;
    Napi::Value* jsobj_maxIters = NULL;
    int maxIters=2000;
    Napi::Value* jsobj_confidence = NULL;
    double confidence=0.995;
    Mat retval;

    const char* keywords[] = { "srcPoints", "dstPoints", "method", "ransacReprojThreshold", "mask", "maxIters", "confidence", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOOOO:findHomography", (char**)keywords, &jsobj_srcPoints, &jsobj_dstPoints, &jsobj_method, &jsobj_ransacReprojThreshold, &jsobj_mask, &jsobj_maxIters, &jsobj_confidence) &&
        jsopencv_to_safe(jsobj_srcPoints, srcPoints, ArgInfo("srcPoints", 0)) &&
        jsopencv_to_safe(jsobj_dstPoints, dstPoints, ArgInfo("dstPoints", 0)) &&
        jsopencv_to_safe(jsobj_method, method, ArgInfo("method", 0)) &&
        jsopencv_to_safe(jsobj_ransacReprojThreshold, ransacReprojThreshold, ArgInfo("ransacReprojThreshold", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 1)) &&
        jsopencv_to_safe(jsobj_maxIters, maxIters, ArgInfo("maxIters", 0)) &&
        jsopencv_to_safe(jsobj_confidence, confidence, ArgInfo("confidence", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::findHomography(srcPoints, dstPoints, method, ransacReprojThreshold, mask, maxIters, confidence));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, mask));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_srcPoints = NULL;
    UMat srcPoints;
    Napi::Value* jsobj_dstPoints = NULL;
    UMat dstPoints;
    Napi::Value* jsobj_method = NULL;
    int method=0;
    Napi::Value* jsobj_ransacReprojThreshold = NULL;
    double ransacReprojThreshold=3;
    Napi::Value* jsobj_mask = NULL;
    UMat mask;
    Napi::Value* jsobj_maxIters = NULL;
    int maxIters=2000;
    Napi::Value* jsobj_confidence = NULL;
    double confidence=0.995;
    Mat retval;

    const char* keywords[] = { "srcPoints", "dstPoints", "method", "ransacReprojThreshold", "mask", "maxIters", "confidence", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOOOO:findHomography", (char**)keywords, &jsobj_srcPoints, &jsobj_dstPoints, &jsobj_method, &jsobj_ransacReprojThreshold, &jsobj_mask, &jsobj_maxIters, &jsobj_confidence) &&
        jsopencv_to_safe(jsobj_srcPoints, srcPoints, ArgInfo("srcPoints", 0)) &&
        jsopencv_to_safe(jsobj_dstPoints, dstPoints, ArgInfo("dstPoints", 0)) &&
        jsopencv_to_safe(jsobj_method, method, ArgInfo("method", 0)) &&
        jsopencv_to_safe(jsobj_ransacReprojThreshold, ransacReprojThreshold, ArgInfo("ransacReprojThreshold", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 1)) &&
        jsopencv_to_safe(jsobj_maxIters, maxIters, ArgInfo("maxIters", 0)) &&
        jsopencv_to_safe(jsobj_confidence, confidence, ArgInfo("confidence", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::findHomography(srcPoints, dstPoints, method, ransacReprojThreshold, mask, maxIters, confidence));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, mask));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_srcPoints = NULL;
    Mat srcPoints;
    Napi::Value* jsobj_dstPoints = NULL;
    Mat dstPoints;
    Napi::Value* jsobj_mask = NULL;
    Mat mask;
    Napi::Value* jsobj_params = NULL;
    cv::UsacParams params;
    Mat retval;

    const char* keywords[] = { "srcPoints", "dstPoints", "params", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:findHomography", (char**)keywords, &jsobj_srcPoints, &jsobj_dstPoints, &jsobj_params, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_srcPoints, srcPoints, ArgInfo("srcPoints", 0)) &&
        jsopencv_to_safe(jsobj_dstPoints, dstPoints, ArgInfo("dstPoints", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 1)) &&
        jsopencv_to_safe(jsobj_params, params, ArgInfo("params", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::findHomography(srcPoints, dstPoints, mask, params));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, mask));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_srcPoints = NULL;
    UMat srcPoints;
    Napi::Value* jsobj_dstPoints = NULL;
    UMat dstPoints;
    Napi::Value* jsobj_mask = NULL;
    UMat mask;
    Napi::Value* jsobj_params = NULL;
    cv::UsacParams params;
    Mat retval;

    const char* keywords[] = { "srcPoints", "dstPoints", "params", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:findHomography", (char**)keywords, &jsobj_srcPoints, &jsobj_dstPoints, &jsobj_params, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_srcPoints, srcPoints, ArgInfo("srcPoints", 0)) &&
        jsopencv_to_safe(jsobj_dstPoints, dstPoints, ArgInfo("dstPoints", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 1)) &&
        jsopencv_to_safe(jsobj_params, params, ArgInfo("params", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::findHomography(srcPoints, dstPoints, mask, params));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, mask));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "findHomography");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_findNonZero(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_idx = NULL;
    Mat idx;

    const char* keywords[] = { "src", "idx", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:findNonZero", (char**)keywords, &jsobj_src, &jsobj_idx) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_idx, idx, ArgInfo("idx", 1)))
    {
        ERRWRAP2_NAPI(info, cv::findNonZero(src, idx));
        return jsopencv_from(info, idx);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_idx = NULL;
    UMat idx;

    const char* keywords[] = { "src", "idx", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:findNonZero", (char**)keywords, &jsobj_src, &jsobj_idx) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_idx, idx, ArgInfo("idx", 1)))
    {
        ERRWRAP2_NAPI(info, cv::findNonZero(src, idx));
        return jsopencv_from(info, idx);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "findNonZero");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_findTransformECC(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(4);

    {
    Napi::Value* jsobj_templateImage = NULL;
    Mat templateImage;
    Napi::Value* jsobj_inputImage = NULL;
    Mat inputImage;
    Napi::Value* jsobj_warpMatrix = NULL;
    Mat warpMatrix;
    Napi::Value* jsobj_motionType = NULL;
    int motionType=0;
    Napi::Value* jsobj_criteria = NULL;
    TermCriteria criteria;
    Napi::Value* jsobj_inputMask = NULL;
    Mat inputMask;
    Napi::Value* jsobj_gaussFiltSize = NULL;
    int gaussFiltSize=0;
    double retval;

    const char* keywords[] = { "templateImage", "inputImage", "warpMatrix", "motionType", "criteria", "inputMask", "gaussFiltSize", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOOO:findTransformECC", (char**)keywords, &jsobj_templateImage, &jsobj_inputImage, &jsobj_warpMatrix, &jsobj_motionType, &jsobj_criteria, &jsobj_inputMask, &jsobj_gaussFiltSize) &&
        jsopencv_to_safe(jsobj_templateImage, templateImage, ArgInfo("templateImage", 0)) &&
        jsopencv_to_safe(jsobj_inputImage, inputImage, ArgInfo("inputImage", 0)) &&
        jsopencv_to_safe(jsobj_warpMatrix, warpMatrix, ArgInfo("warpMatrix", 1)) &&
        jsopencv_to_safe(jsobj_motionType, motionType, ArgInfo("motionType", 0)) &&
        jsopencv_to_safe(jsobj_criteria, criteria, ArgInfo("criteria", 0)) &&
        jsopencv_to_safe(jsobj_inputMask, inputMask, ArgInfo("inputMask", 0)) &&
        jsopencv_to_safe(jsobj_gaussFiltSize, gaussFiltSize, ArgInfo("gaussFiltSize", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::findTransformECC(templateImage, inputImage, warpMatrix, motionType, criteria, inputMask, gaussFiltSize));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, warpMatrix));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_templateImage = NULL;
    UMat templateImage;
    Napi::Value* jsobj_inputImage = NULL;
    UMat inputImage;
    Napi::Value* jsobj_warpMatrix = NULL;
    UMat warpMatrix;
    Napi::Value* jsobj_motionType = NULL;
    int motionType=0;
    Napi::Value* jsobj_criteria = NULL;
    TermCriteria criteria;
    Napi::Value* jsobj_inputMask = NULL;
    UMat inputMask;
    Napi::Value* jsobj_gaussFiltSize = NULL;
    int gaussFiltSize=0;
    double retval;

    const char* keywords[] = { "templateImage", "inputImage", "warpMatrix", "motionType", "criteria", "inputMask", "gaussFiltSize", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOOO:findTransformECC", (char**)keywords, &jsobj_templateImage, &jsobj_inputImage, &jsobj_warpMatrix, &jsobj_motionType, &jsobj_criteria, &jsobj_inputMask, &jsobj_gaussFiltSize) &&
        jsopencv_to_safe(jsobj_templateImage, templateImage, ArgInfo("templateImage", 0)) &&
        jsopencv_to_safe(jsobj_inputImage, inputImage, ArgInfo("inputImage", 0)) &&
        jsopencv_to_safe(jsobj_warpMatrix, warpMatrix, ArgInfo("warpMatrix", 1)) &&
        jsopencv_to_safe(jsobj_motionType, motionType, ArgInfo("motionType", 0)) &&
        jsopencv_to_safe(jsobj_criteria, criteria, ArgInfo("criteria", 0)) &&
        jsopencv_to_safe(jsobj_inputMask, inputMask, ArgInfo("inputMask", 0)) &&
        jsopencv_to_safe(jsobj_gaussFiltSize, gaussFiltSize, ArgInfo("gaussFiltSize", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::findTransformECC(templateImage, inputImage, warpMatrix, motionType, criteria, inputMask, gaussFiltSize));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, warpMatrix));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_templateImage = NULL;
    Mat templateImage;
    Napi::Value* jsobj_inputImage = NULL;
    Mat inputImage;
    Napi::Value* jsobj_warpMatrix = NULL;
    Mat warpMatrix;
    Napi::Value* jsobj_motionType = NULL;
    int motionType=MOTION_AFFINE;
    Napi::Value* jsobj_criteria = NULL;
    TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 50, 0.001);
    Napi::Value* jsobj_inputMask = NULL;
    Mat inputMask;
    double retval;

    const char* keywords[] = { "templateImage", "inputImage", "warpMatrix", "motionType", "criteria", "inputMask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOO:findTransformECC", (char**)keywords, &jsobj_templateImage, &jsobj_inputImage, &jsobj_warpMatrix, &jsobj_motionType, &jsobj_criteria, &jsobj_inputMask) &&
        jsopencv_to_safe(jsobj_templateImage, templateImage, ArgInfo("templateImage", 0)) &&
        jsopencv_to_safe(jsobj_inputImage, inputImage, ArgInfo("inputImage", 0)) &&
        jsopencv_to_safe(jsobj_warpMatrix, warpMatrix, ArgInfo("warpMatrix", 1)) &&
        jsopencv_to_safe(jsobj_motionType, motionType, ArgInfo("motionType", 0)) &&
        jsopencv_to_safe(jsobj_criteria, criteria, ArgInfo("criteria", 0)) &&
        jsopencv_to_safe(jsobj_inputMask, inputMask, ArgInfo("inputMask", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::findTransformECC(templateImage, inputImage, warpMatrix, motionType, criteria, inputMask));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, warpMatrix));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_templateImage = NULL;
    UMat templateImage;
    Napi::Value* jsobj_inputImage = NULL;
    UMat inputImage;
    Napi::Value* jsobj_warpMatrix = NULL;
    UMat warpMatrix;
    Napi::Value* jsobj_motionType = NULL;
    int motionType=MOTION_AFFINE;
    Napi::Value* jsobj_criteria = NULL;
    TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 50, 0.001);
    Napi::Value* jsobj_inputMask = NULL;
    UMat inputMask;
    double retval;

    const char* keywords[] = { "templateImage", "inputImage", "warpMatrix", "motionType", "criteria", "inputMask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOO:findTransformECC", (char**)keywords, &jsobj_templateImage, &jsobj_inputImage, &jsobj_warpMatrix, &jsobj_motionType, &jsobj_criteria, &jsobj_inputMask) &&
        jsopencv_to_safe(jsobj_templateImage, templateImage, ArgInfo("templateImage", 0)) &&
        jsopencv_to_safe(jsobj_inputImage, inputImage, ArgInfo("inputImage", 0)) &&
        jsopencv_to_safe(jsobj_warpMatrix, warpMatrix, ArgInfo("warpMatrix", 1)) &&
        jsopencv_to_safe(jsobj_motionType, motionType, ArgInfo("motionType", 0)) &&
        jsopencv_to_safe(jsobj_criteria, criteria, ArgInfo("criteria", 0)) &&
        jsopencv_to_safe(jsobj_inputMask, inputMask, ArgInfo("inputMask", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::findTransformECC(templateImage, inputImage, warpMatrix, motionType, criteria, inputMask));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, warpMatrix));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "findTransformECC");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_fitEllipse(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_points = NULL;
    Mat points;
    RotatedRect retval;

    const char* keywords[] = { "points", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:fitEllipse", (char**)keywords, &jsobj_points) &&
        jsopencv_to_safe(jsobj_points, points, ArgInfo("points", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::fitEllipse(points));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_points = NULL;
    UMat points;
    RotatedRect retval;

    const char* keywords[] = { "points", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:fitEllipse", (char**)keywords, &jsobj_points) &&
        jsopencv_to_safe(jsobj_points, points, ArgInfo("points", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::fitEllipse(points));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "fitEllipse");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_fitEllipseAMS(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_points = NULL;
    Mat points;
    RotatedRect retval;

    const char* keywords[] = { "points", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:fitEllipseAMS", (char**)keywords, &jsobj_points) &&
        jsopencv_to_safe(jsobj_points, points, ArgInfo("points", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::fitEllipseAMS(points));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_points = NULL;
    UMat points;
    RotatedRect retval;

    const char* keywords[] = { "points", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:fitEllipseAMS", (char**)keywords, &jsobj_points) &&
        jsopencv_to_safe(jsobj_points, points, ArgInfo("points", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::fitEllipseAMS(points));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "fitEllipseAMS");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_fitEllipseDirect(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_points = NULL;
    Mat points;
    RotatedRect retval;

    const char* keywords[] = { "points", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:fitEllipseDirect", (char**)keywords, &jsobj_points) &&
        jsopencv_to_safe(jsobj_points, points, ArgInfo("points", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::fitEllipseDirect(points));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_points = NULL;
    UMat points;
    RotatedRect retval;

    const char* keywords[] = { "points", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:fitEllipseDirect", (char**)keywords, &jsobj_points) &&
        jsopencv_to_safe(jsobj_points, points, ArgInfo("points", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::fitEllipseDirect(points));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "fitEllipseDirect");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_fitLine(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_points = NULL;
    Mat points;
    Napi::Value* jsobj_line = NULL;
    Mat line;
    Napi::Value* jsobj_distType = NULL;
    int distType=0;
    Napi::Value* jsobj_param = NULL;
    double param=0;
    Napi::Value* jsobj_reps = NULL;
    double reps=0;
    Napi::Value* jsobj_aeps = NULL;
    double aeps=0;

    const char* keywords[] = { "points", "distType", "param", "reps", "aeps", "line", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOO|O:fitLine", (char**)keywords, &jsobj_points, &jsobj_distType, &jsobj_param, &jsobj_reps, &jsobj_aeps, &jsobj_line) &&
        jsopencv_to_safe(jsobj_points, points, ArgInfo("points", 0)) &&
        jsopencv_to_safe(jsobj_line, line, ArgInfo("line", 1)) &&
        jsopencv_to_safe(jsobj_distType, distType, ArgInfo("distType", 0)) &&
        jsopencv_to_safe(jsobj_param, param, ArgInfo("param", 0)) &&
        jsopencv_to_safe(jsobj_reps, reps, ArgInfo("reps", 0)) &&
        jsopencv_to_safe(jsobj_aeps, aeps, ArgInfo("aeps", 0)))
    {
        ERRWRAP2_NAPI(info, cv::fitLine(points, line, distType, param, reps, aeps));
        return jsopencv_from(info, line);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_points = NULL;
    UMat points;
    Napi::Value* jsobj_line = NULL;
    UMat line;
    Napi::Value* jsobj_distType = NULL;
    int distType=0;
    Napi::Value* jsobj_param = NULL;
    double param=0;
    Napi::Value* jsobj_reps = NULL;
    double reps=0;
    Napi::Value* jsobj_aeps = NULL;
    double aeps=0;

    const char* keywords[] = { "points", "distType", "param", "reps", "aeps", "line", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOO|O:fitLine", (char**)keywords, &jsobj_points, &jsobj_distType, &jsobj_param, &jsobj_reps, &jsobj_aeps, &jsobj_line) &&
        jsopencv_to_safe(jsobj_points, points, ArgInfo("points", 0)) &&
        jsopencv_to_safe(jsobj_line, line, ArgInfo("line", 1)) &&
        jsopencv_to_safe(jsobj_distType, distType, ArgInfo("distType", 0)) &&
        jsopencv_to_safe(jsobj_param, param, ArgInfo("param", 0)) &&
        jsopencv_to_safe(jsobj_reps, reps, ArgInfo("reps", 0)) &&
        jsopencv_to_safe(jsobj_aeps, aeps, ArgInfo("aeps", 0)))
    {
        ERRWRAP2_NAPI(info, cv::fitLine(points, line, distType, param, reps, aeps));
        return jsopencv_from(info, line);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "fitLine");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_flip(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_flipCode = NULL;
    int flipCode=0;

    const char* keywords[] = { "src", "flipCode", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:flip", (char**)keywords, &jsobj_src, &jsobj_flipCode, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_flipCode, flipCode, ArgInfo("flipCode", 0)))
    {
        ERRWRAP2_NAPI(info, cv::flip(src, dst, flipCode));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_flipCode = NULL;
    int flipCode=0;

    const char* keywords[] = { "src", "flipCode", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:flip", (char**)keywords, &jsobj_src, &jsobj_flipCode, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_flipCode, flipCode, ArgInfo("flipCode", 0)))
    {
        ERRWRAP2_NAPI(info, cv::flip(src, dst, flipCode));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "flip");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_flipND(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_axis = NULL;
    int axis=0;

    const char* keywords[] = { "src", "axis", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:flipND", (char**)keywords, &jsobj_src, &jsobj_axis, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_axis, axis, ArgInfo("axis", 0)))
    {
        ERRWRAP2_NAPI(info, cv::flipND(src, dst, axis));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_axis = NULL;
    int axis=0;

    const char* keywords[] = { "src", "axis", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:flipND", (char**)keywords, &jsobj_src, &jsobj_axis, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_axis, axis, ArgInfo("axis", 0)))
    {
        ERRWRAP2_NAPI(info, cv::flipND(src, dst, axis));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "flipND");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_floodFill(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_image = NULL;
    Mat image;
    Napi::Value* jsobj_mask = NULL;
    Mat mask;
    Napi::Value* jsobj_seedPoint = NULL;
    Point seedPoint;
    Napi::Value* jsobj_newVal = NULL;
    Scalar newVal;
    Rect rect;
    Napi::Value* jsobj_loDiff = NULL;
    Scalar loDiff;
    Napi::Value* jsobj_upDiff = NULL;
    Scalar upDiff;
    Napi::Value* jsobj_flags = NULL;
    int flags=4;
    int retval;

    const char* keywords[] = { "image", "mask", "seedPoint", "newVal", "loDiff", "upDiff", "flags", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOO:floodFill", (char**)keywords, &jsobj_image, &jsobj_mask, &jsobj_seedPoint, &jsobj_newVal, &jsobj_loDiff, &jsobj_upDiff, &jsobj_flags) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 1)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 1)) &&
        jsopencv_to_safe(jsobj_seedPoint, seedPoint, ArgInfo("seedPoint", 0)) &&
        jsopencv_to_safe(jsobj_newVal, newVal, ArgInfo("newVal", 0)) &&
        jsopencv_to_safe(jsobj_loDiff, loDiff, ArgInfo("loDiff", 0)) &&
        jsopencv_to_safe(jsobj_upDiff, upDiff, ArgInfo("upDiff", 0)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::floodFill(image, mask, seedPoint, newVal, &rect, loDiff, upDiff, flags));
        return Js_BuildValue(info, "(NNNN)", jsopencv_from(info, retval), jsopencv_from(info, image), jsopencv_from(info, mask), jsopencv_from(info, rect));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_image = NULL;
    UMat image;
    Napi::Value* jsobj_mask = NULL;
    UMat mask;
    Napi::Value* jsobj_seedPoint = NULL;
    Point seedPoint;
    Napi::Value* jsobj_newVal = NULL;
    Scalar newVal;
    Rect rect;
    Napi::Value* jsobj_loDiff = NULL;
    Scalar loDiff;
    Napi::Value* jsobj_upDiff = NULL;
    Scalar upDiff;
    Napi::Value* jsobj_flags = NULL;
    int flags=4;
    int retval;

    const char* keywords[] = { "image", "mask", "seedPoint", "newVal", "loDiff", "upDiff", "flags", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOO:floodFill", (char**)keywords, &jsobj_image, &jsobj_mask, &jsobj_seedPoint, &jsobj_newVal, &jsobj_loDiff, &jsobj_upDiff, &jsobj_flags) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 1)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 1)) &&
        jsopencv_to_safe(jsobj_seedPoint, seedPoint, ArgInfo("seedPoint", 0)) &&
        jsopencv_to_safe(jsobj_newVal, newVal, ArgInfo("newVal", 0)) &&
        jsopencv_to_safe(jsobj_loDiff, loDiff, ArgInfo("loDiff", 0)) &&
        jsopencv_to_safe(jsobj_upDiff, upDiff, ArgInfo("upDiff", 0)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::floodFill(image, mask, seedPoint, newVal, &rect, loDiff, upDiff, flags));
        return Js_BuildValue(info, "(NNNN)", jsopencv_from(info, retval), jsopencv_from(info, image), jsopencv_from(info, mask), jsopencv_from(info, rect));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "floodFill");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gemm(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src1 = NULL;
    Mat src1;
    Napi::Value* jsobj_src2 = NULL;
    Mat src2;
    Napi::Value* jsobj_alpha = NULL;
    double alpha=0;
    Napi::Value* jsobj_src3 = NULL;
    Mat src3;
    Napi::Value* jsobj_beta = NULL;
    double beta=0;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;

    const char* keywords[] = { "src1", "src2", "alpha", "src3", "beta", "dst", "flags", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOO|OO:gemm", (char**)keywords, &jsobj_src1, &jsobj_src2, &jsobj_alpha, &jsobj_src3, &jsobj_beta, &jsobj_dst, &jsobj_flags) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_alpha, alpha, ArgInfo("alpha", 0)) &&
        jsopencv_to_safe(jsobj_src3, src3, ArgInfo("src3", 0)) &&
        jsopencv_to_safe(jsobj_beta, beta, ArgInfo("beta", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, cv::gemm(src1, src2, alpha, src3, beta, dst, flags));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src1 = NULL;
    UMat src1;
    Napi::Value* jsobj_src2 = NULL;
    UMat src2;
    Napi::Value* jsobj_alpha = NULL;
    double alpha=0;
    Napi::Value* jsobj_src3 = NULL;
    UMat src3;
    Napi::Value* jsobj_beta = NULL;
    double beta=0;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;

    const char* keywords[] = { "src1", "src2", "alpha", "src3", "beta", "dst", "flags", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOO|OO:gemm", (char**)keywords, &jsobj_src1, &jsobj_src2, &jsobj_alpha, &jsobj_src3, &jsobj_beta, &jsobj_dst, &jsobj_flags) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_alpha, alpha, ArgInfo("alpha", 0)) &&
        jsopencv_to_safe(jsobj_src3, src3, ArgInfo("src3", 0)) &&
        jsopencv_to_safe(jsobj_beta, beta, ArgInfo("beta", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, cv::gemm(src1, src2, alpha, src3, beta, dst, flags));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "gemm");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_getAffineTransform(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Mat retval;

    const char* keywords[] = { "src", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:getAffineTransform", (char**)keywords, &jsobj_src, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::getAffineTransform(src, dst));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Mat retval;

    const char* keywords[] = { "src", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:getAffineTransform", (char**)keywords, &jsobj_src, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::getAffineTransform(src, dst));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "getAffineTransform");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_getBuildInformation(const Napi::CallbackInfo &info)
{
    using namespace cv;

    String retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::getBuildInformation());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_getCPUFeaturesLine(const Napi::CallbackInfo &info)
{
    using namespace cv;

    std::string retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::getCPUFeaturesLine());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_getCPUTickCount(const Napi::CallbackInfo &info)
{
    using namespace cv;

    int64 retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::getCPUTickCount());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_getDefaultNewCameraMatrix(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_cameraMatrix = NULL;
    Mat cameraMatrix;
    Napi::Value* jsobj_imgsize = NULL;
    Size imgsize;
    Napi::Value* jsobj_centerPrincipalPoint = NULL;
    bool centerPrincipalPoint=false;
    Mat retval;

    const char* keywords[] = { "cameraMatrix", "imgsize", "centerPrincipalPoint", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OO:getDefaultNewCameraMatrix", (char**)keywords, &jsobj_cameraMatrix, &jsobj_imgsize, &jsobj_centerPrincipalPoint) &&
        jsopencv_to_safe(jsobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 0)) &&
        jsopencv_to_safe(jsobj_imgsize, imgsize, ArgInfo("imgsize", 0)) &&
        jsopencv_to_safe(jsobj_centerPrincipalPoint, centerPrincipalPoint, ArgInfo("centerPrincipalPoint", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::getDefaultNewCameraMatrix(cameraMatrix, imgsize, centerPrincipalPoint));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_cameraMatrix = NULL;
    UMat cameraMatrix;
    Napi::Value* jsobj_imgsize = NULL;
    Size imgsize;
    Napi::Value* jsobj_centerPrincipalPoint = NULL;
    bool centerPrincipalPoint=false;
    Mat retval;

    const char* keywords[] = { "cameraMatrix", "imgsize", "centerPrincipalPoint", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OO:getDefaultNewCameraMatrix", (char**)keywords, &jsobj_cameraMatrix, &jsobj_imgsize, &jsobj_centerPrincipalPoint) &&
        jsopencv_to_safe(jsobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 0)) &&
        jsopencv_to_safe(jsobj_imgsize, imgsize, ArgInfo("imgsize", 0)) &&
        jsopencv_to_safe(jsobj_centerPrincipalPoint, centerPrincipalPoint, ArgInfo("centerPrincipalPoint", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::getDefaultNewCameraMatrix(cameraMatrix, imgsize, centerPrincipalPoint));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "getDefaultNewCameraMatrix");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_getDerivKernels(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_kx = NULL;
    Mat kx;
    Napi::Value* jsobj_ky = NULL;
    Mat ky;
    Napi::Value* jsobj_dx = NULL;
    int dx=0;
    Napi::Value* jsobj_dy = NULL;
    int dy=0;
    Napi::Value* jsobj_ksize = NULL;
    int ksize=0;
    Napi::Value* jsobj_normalize = NULL;
    bool normalize=false;
    Napi::Value* jsobj_ktype = NULL;
    int ktype=CV_32F;

    const char* keywords[] = { "dx", "dy", "ksize", "kx", "ky", "normalize", "ktype", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOOO:getDerivKernels", (char**)keywords, &jsobj_dx, &jsobj_dy, &jsobj_ksize, &jsobj_kx, &jsobj_ky, &jsobj_normalize, &jsobj_ktype) &&
        jsopencv_to_safe(jsobj_kx, kx, ArgInfo("kx", 1)) &&
        jsopencv_to_safe(jsobj_ky, ky, ArgInfo("ky", 1)) &&
        jsopencv_to_safe(jsobj_dx, dx, ArgInfo("dx", 0)) &&
        jsopencv_to_safe(jsobj_dy, dy, ArgInfo("dy", 0)) &&
        jsopencv_to_safe(jsobj_ksize, ksize, ArgInfo("ksize", 0)) &&
        jsopencv_to_safe(jsobj_normalize, normalize, ArgInfo("normalize", 0)) &&
        jsopencv_to_safe(jsobj_ktype, ktype, ArgInfo("ktype", 0)))
    {
        ERRWRAP2_NAPI(info, cv::getDerivKernels(kx, ky, dx, dy, ksize, normalize, ktype));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, kx), jsopencv_from(info, ky));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_kx = NULL;
    UMat kx;
    Napi::Value* jsobj_ky = NULL;
    UMat ky;
    Napi::Value* jsobj_dx = NULL;
    int dx=0;
    Napi::Value* jsobj_dy = NULL;
    int dy=0;
    Napi::Value* jsobj_ksize = NULL;
    int ksize=0;
    Napi::Value* jsobj_normalize = NULL;
    bool normalize=false;
    Napi::Value* jsobj_ktype = NULL;
    int ktype=CV_32F;

    const char* keywords[] = { "dx", "dy", "ksize", "kx", "ky", "normalize", "ktype", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOOO:getDerivKernels", (char**)keywords, &jsobj_dx, &jsobj_dy, &jsobj_ksize, &jsobj_kx, &jsobj_ky, &jsobj_normalize, &jsobj_ktype) &&
        jsopencv_to_safe(jsobj_kx, kx, ArgInfo("kx", 1)) &&
        jsopencv_to_safe(jsobj_ky, ky, ArgInfo("ky", 1)) &&
        jsopencv_to_safe(jsobj_dx, dx, ArgInfo("dx", 0)) &&
        jsopencv_to_safe(jsobj_dy, dy, ArgInfo("dy", 0)) &&
        jsopencv_to_safe(jsobj_ksize, ksize, ArgInfo("ksize", 0)) &&
        jsopencv_to_safe(jsobj_normalize, normalize, ArgInfo("normalize", 0)) &&
        jsopencv_to_safe(jsobj_ktype, ktype, ArgInfo("ktype", 0)))
    {
        ERRWRAP2_NAPI(info, cv::getDerivKernels(kx, ky, dx, dy, ksize, normalize, ktype));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, kx), jsopencv_from(info, ky));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "getDerivKernels");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_getFontScaleFromHeight(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_fontFace = NULL;
    int fontFace=0;
    Napi::Value* jsobj_pixelHeight = NULL;
    int pixelHeight=0;
    Napi::Value* jsobj_thickness = NULL;
    int thickness=1;
    double retval;

    const char* keywords[] = { "fontFace", "pixelHeight", "thickness", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:getFontScaleFromHeight", (char**)keywords, &jsobj_fontFace, &jsobj_pixelHeight, &jsobj_thickness) &&
        jsopencv_to_safe(jsobj_fontFace, fontFace, ArgInfo("fontFace", 0)) &&
        jsopencv_to_safe(jsobj_pixelHeight, pixelHeight, ArgInfo("pixelHeight", 0)) &&
        jsopencv_to_safe(jsobj_thickness, thickness, ArgInfo("thickness", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::getFontScaleFromHeight(fontFace, pixelHeight, thickness));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_getGaborKernel(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_ksize = NULL;
    Size ksize;
    Napi::Value* jsobj_sigma = NULL;
    double sigma=0;
    Napi::Value* jsobj_theta = NULL;
    double theta=0;
    Napi::Value* jsobj_lambd = NULL;
    double lambd=0;
    Napi::Value* jsobj_gamma = NULL;
    double gamma=0;
    Napi::Value* jsobj_psi = NULL;
    double psi=CV_PI*0.5;
    Napi::Value* jsobj_ktype = NULL;
    int ktype=CV_64F;
    Mat retval;

    const char* keywords[] = { "ksize", "sigma", "theta", "lambd", "gamma", "psi", "ktype", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOO|OO:getGaborKernel", (char**)keywords, &jsobj_ksize, &jsobj_sigma, &jsobj_theta, &jsobj_lambd, &jsobj_gamma, &jsobj_psi, &jsobj_ktype) &&
        jsopencv_to_safe(jsobj_ksize, ksize, ArgInfo("ksize", 0)) &&
        jsopencv_to_safe(jsobj_sigma, sigma, ArgInfo("sigma", 0)) &&
        jsopencv_to_safe(jsobj_theta, theta, ArgInfo("theta", 0)) &&
        jsopencv_to_safe(jsobj_lambd, lambd, ArgInfo("lambd", 0)) &&
        jsopencv_to_safe(jsobj_gamma, gamma, ArgInfo("gamma", 0)) &&
        jsopencv_to_safe(jsobj_psi, psi, ArgInfo("psi", 0)) &&
        jsopencv_to_safe(jsobj_ktype, ktype, ArgInfo("ktype", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::getGaborKernel(ksize, sigma, theta, lambd, gamma, psi, ktype));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_getGaussianKernel(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_ksize = NULL;
    int ksize=0;
    Napi::Value* jsobj_sigma = NULL;
    double sigma=0;
    Napi::Value* jsobj_ktype = NULL;
    int ktype=CV_64F;
    Mat retval;

    const char* keywords[] = { "ksize", "sigma", "ktype", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:getGaussianKernel", (char**)keywords, &jsobj_ksize, &jsobj_sigma, &jsobj_ktype) &&
        jsopencv_to_safe(jsobj_ksize, ksize, ArgInfo("ksize", 0)) &&
        jsopencv_to_safe(jsobj_sigma, sigma, ArgInfo("sigma", 0)) &&
        jsopencv_to_safe(jsobj_ktype, ktype, ArgInfo("ktype", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::getGaussianKernel(ksize, sigma, ktype));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_getHardwareFeatureName(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_feature = NULL;
    int feature=0;
    String retval;

    const char* keywords[] = { "feature", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:getHardwareFeatureName", (char**)keywords, &jsobj_feature) &&
        jsopencv_to_safe(jsobj_feature, feature, ArgInfo("feature", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::getHardwareFeatureName(feature));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_getLogLevel(const Napi::CallbackInfo &info)
{
    using namespace cv;

    int retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::getLogLevel());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_getNumThreads(const Napi::CallbackInfo &info)
{
    using namespace cv;

    int retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::getNumThreads());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_getNumberOfCPUs(const Napi::CallbackInfo &info)
{
    using namespace cv;

    int retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::getNumberOfCPUs());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_getOptimalDFTSize(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_vecsize = NULL;
    int vecsize=0;
    int retval;

    const char* keywords[] = { "vecsize", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:getOptimalDFTSize", (char**)keywords, &jsobj_vecsize) &&
        jsopencv_to_safe(jsobj_vecsize, vecsize, ArgInfo("vecsize", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::getOptimalDFTSize(vecsize));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_getOptimalNewCameraMatrix(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_cameraMatrix = NULL;
    Mat cameraMatrix;
    Napi::Value* jsobj_distCoeffs = NULL;
    Mat distCoeffs;
    Napi::Value* jsobj_imageSize = NULL;
    Size imageSize;
    Napi::Value* jsobj_alpha = NULL;
    double alpha=0;
    Napi::Value* jsobj_newImgSize = NULL;
    Size newImgSize;
    Rect validPixROI;
    Napi::Value* jsobj_centerPrincipalPoint = NULL;
    bool centerPrincipalPoint=false;
    Mat retval;

    const char* keywords[] = { "cameraMatrix", "distCoeffs", "imageSize", "alpha", "newImgSize", "centerPrincipalPoint", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OO:getOptimalNewCameraMatrix", (char**)keywords, &jsobj_cameraMatrix, &jsobj_distCoeffs, &jsobj_imageSize, &jsobj_alpha, &jsobj_newImgSize, &jsobj_centerPrincipalPoint) &&
        jsopencv_to_safe(jsobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 0)) &&
        jsopencv_to_safe(jsobj_distCoeffs, distCoeffs, ArgInfo("distCoeffs", 0)) &&
        jsopencv_to_safe(jsobj_imageSize, imageSize, ArgInfo("imageSize", 0)) &&
        jsopencv_to_safe(jsobj_alpha, alpha, ArgInfo("alpha", 0)) &&
        jsopencv_to_safe(jsobj_newImgSize, newImgSize, ArgInfo("newImgSize", 0)) &&
        jsopencv_to_safe(jsobj_centerPrincipalPoint, centerPrincipalPoint, ArgInfo("centerPrincipalPoint", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::getOptimalNewCameraMatrix(cameraMatrix, distCoeffs, imageSize, alpha, newImgSize, &validPixROI, centerPrincipalPoint));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, validPixROI));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_cameraMatrix = NULL;
    UMat cameraMatrix;
    Napi::Value* jsobj_distCoeffs = NULL;
    UMat distCoeffs;
    Napi::Value* jsobj_imageSize = NULL;
    Size imageSize;
    Napi::Value* jsobj_alpha = NULL;
    double alpha=0;
    Napi::Value* jsobj_newImgSize = NULL;
    Size newImgSize;
    Rect validPixROI;
    Napi::Value* jsobj_centerPrincipalPoint = NULL;
    bool centerPrincipalPoint=false;
    Mat retval;

    const char* keywords[] = { "cameraMatrix", "distCoeffs", "imageSize", "alpha", "newImgSize", "centerPrincipalPoint", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OO:getOptimalNewCameraMatrix", (char**)keywords, &jsobj_cameraMatrix, &jsobj_distCoeffs, &jsobj_imageSize, &jsobj_alpha, &jsobj_newImgSize, &jsobj_centerPrincipalPoint) &&
        jsopencv_to_safe(jsobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 0)) &&
        jsopencv_to_safe(jsobj_distCoeffs, distCoeffs, ArgInfo("distCoeffs", 0)) &&
        jsopencv_to_safe(jsobj_imageSize, imageSize, ArgInfo("imageSize", 0)) &&
        jsopencv_to_safe(jsobj_alpha, alpha, ArgInfo("alpha", 0)) &&
        jsopencv_to_safe(jsobj_newImgSize, newImgSize, ArgInfo("newImgSize", 0)) &&
        jsopencv_to_safe(jsobj_centerPrincipalPoint, centerPrincipalPoint, ArgInfo("centerPrincipalPoint", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::getOptimalNewCameraMatrix(cameraMatrix, distCoeffs, imageSize, alpha, newImgSize, &validPixROI, centerPrincipalPoint));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, validPixROI));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "getOptimalNewCameraMatrix");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_getPerspectiveTransform(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_solveMethod = NULL;
    int solveMethod=DECOMP_LU;
    Mat retval;

    const char* keywords[] = { "src", "dst", "solveMethod", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:getPerspectiveTransform", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_solveMethod) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 0)) &&
        jsopencv_to_safe(jsobj_solveMethod, solveMethod, ArgInfo("solveMethod", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::getPerspectiveTransform(src, dst, solveMethod));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_solveMethod = NULL;
    int solveMethod=DECOMP_LU;
    Mat retval;

    const char* keywords[] = { "src", "dst", "solveMethod", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:getPerspectiveTransform", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_solveMethod) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 0)) &&
        jsopencv_to_safe(jsobj_solveMethod, solveMethod, ArgInfo("solveMethod", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::getPerspectiveTransform(src, dst, solveMethod));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "getPerspectiveTransform");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_getRectSubPix(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_image = NULL;
    Mat image;
    Napi::Value* jsobj_patchSize = NULL;
    Size patchSize;
    Napi::Value* jsobj_center = NULL;
    Point2f center;
    Napi::Value* jsobj_patch = NULL;
    Mat patch;
    Napi::Value* jsobj_patchType = NULL;
    int patchType=-1;

    const char* keywords[] = { "image", "patchSize", "center", "patch", "patchType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OO:getRectSubPix", (char**)keywords, &jsobj_image, &jsobj_patchSize, &jsobj_center, &jsobj_patch, &jsobj_patchType) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_patchSize, patchSize, ArgInfo("patchSize", 0)) &&
        jsopencv_to_safe(jsobj_center, center, ArgInfo("center", 0)) &&
        jsopencv_to_safe(jsobj_patch, patch, ArgInfo("patch", 1)) &&
        jsopencv_to_safe(jsobj_patchType, patchType, ArgInfo("patchType", 0)))
    {
        ERRWRAP2_NAPI(info, cv::getRectSubPix(image, patchSize, center, patch, patchType));
        return jsopencv_from(info, patch);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_image = NULL;
    UMat image;
    Napi::Value* jsobj_patchSize = NULL;
    Size patchSize;
    Napi::Value* jsobj_center = NULL;
    Point2f center;
    Napi::Value* jsobj_patch = NULL;
    UMat patch;
    Napi::Value* jsobj_patchType = NULL;
    int patchType=-1;

    const char* keywords[] = { "image", "patchSize", "center", "patch", "patchType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OO:getRectSubPix", (char**)keywords, &jsobj_image, &jsobj_patchSize, &jsobj_center, &jsobj_patch, &jsobj_patchType) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_patchSize, patchSize, ArgInfo("patchSize", 0)) &&
        jsopencv_to_safe(jsobj_center, center, ArgInfo("center", 0)) &&
        jsopencv_to_safe(jsobj_patch, patch, ArgInfo("patch", 1)) &&
        jsopencv_to_safe(jsobj_patchType, patchType, ArgInfo("patchType", 0)))
    {
        ERRWRAP2_NAPI(info, cv::getRectSubPix(image, patchSize, center, patch, patchType));
        return jsopencv_from(info, patch);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "getRectSubPix");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_getRotationMatrix2D(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_center = NULL;
    Point2f center;
    Napi::Value* jsobj_angle = NULL;
    double angle=0;
    Napi::Value* jsobj_scale = NULL;
    double scale=0;
    Mat retval;

    const char* keywords[] = { "center", "angle", "scale", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:getRotationMatrix2D", (char**)keywords, &jsobj_center, &jsobj_angle, &jsobj_scale) &&
        jsopencv_to_safe(jsobj_center, center, ArgInfo("center", 0)) &&
        jsopencv_to_safe(jsobj_angle, angle, ArgInfo("angle", 0)) &&
        jsopencv_to_safe(jsobj_scale, scale, ArgInfo("scale", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::getRotationMatrix2D(center, angle, scale));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_getStructuringElement(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_shape = NULL;
    int shape=0;
    Napi::Value* jsobj_ksize = NULL;
    Size ksize;
    Napi::Value* jsobj_anchor = NULL;
    Point anchor=Point(-1,-1);
    Mat retval;

    const char* keywords[] = { "shape", "ksize", "anchor", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:getStructuringElement", (char**)keywords, &jsobj_shape, &jsobj_ksize, &jsobj_anchor) &&
        jsopencv_to_safe(jsobj_shape, shape, ArgInfo("shape", 0)) &&
        jsopencv_to_safe(jsobj_ksize, ksize, ArgInfo("ksize", 0)) &&
        jsopencv_to_safe(jsobj_anchor, anchor, ArgInfo("anchor", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::getStructuringElement(shape, ksize, anchor));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_getTextSize(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_text = NULL;
    String text;
    Napi::Value* jsobj_fontFace = NULL;
    int fontFace=0;
    Napi::Value* jsobj_fontScale = NULL;
    double fontScale=0;
    Napi::Value* jsobj_thickness = NULL;
    int thickness=0;
    int baseLine;
    Size retval;

    const char* keywords[] = { "text", "fontFace", "fontScale", "thickness", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO:getTextSize", (char**)keywords, &jsobj_text, &jsobj_fontFace, &jsobj_fontScale, &jsobj_thickness) &&
        jsopencv_to_safe(jsobj_text, text, ArgInfo("text", 0)) &&
        jsopencv_to_safe(jsobj_fontFace, fontFace, ArgInfo("fontFace", 0)) &&
        jsopencv_to_safe(jsobj_fontScale, fontScale, ArgInfo("fontScale", 0)) &&
        jsopencv_to_safe(jsobj_thickness, thickness, ArgInfo("thickness", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::getTextSize(text, fontFace, fontScale, thickness, &baseLine));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, baseLine));
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_getThreadNum(const Napi::CallbackInfo &info)
{
    using namespace cv;

    int retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::getThreadNum());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_getTickCount(const Napi::CallbackInfo &info)
{
    using namespace cv;

    int64 retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::getTickCount());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_getTickFrequency(const Napi::CallbackInfo &info)
{
    using namespace cv;

    double retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::getTickFrequency());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_getTrackbarPos(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_trackbarname = NULL;
    String trackbarname;
    Napi::Value* jsobj_winname = NULL;
    String winname;
    int retval;

    const char* keywords[] = { "trackbarname", "winname", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:getTrackbarPos", (char**)keywords, &jsobj_trackbarname, &jsobj_winname) &&
        jsopencv_to_safe(jsobj_trackbarname, trackbarname, ArgInfo("trackbarname", 0)) &&
        jsopencv_to_safe(jsobj_winname, winname, ArgInfo("winname", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::getTrackbarPos(trackbarname, winname));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_getValidDisparityROI(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_roi1 = NULL;
    Rect roi1;
    Napi::Value* jsobj_roi2 = NULL;
    Rect roi2;
    Napi::Value* jsobj_minDisparity = NULL;
    int minDisparity=0;
    Napi::Value* jsobj_numberOfDisparities = NULL;
    int numberOfDisparities=0;
    Napi::Value* jsobj_blockSize = NULL;
    int blockSize=0;
    Rect retval;

    const char* keywords[] = { "roi1", "roi2", "minDisparity", "numberOfDisparities", "blockSize", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOO:getValidDisparityROI", (char**)keywords, &jsobj_roi1, &jsobj_roi2, &jsobj_minDisparity, &jsobj_numberOfDisparities, &jsobj_blockSize) &&
        jsopencv_to_safe(jsobj_roi1, roi1, ArgInfo("roi1", 0)) &&
        jsopencv_to_safe(jsobj_roi2, roi2, ArgInfo("roi2", 0)) &&
        jsopencv_to_safe(jsobj_minDisparity, minDisparity, ArgInfo("minDisparity", 0)) &&
        jsopencv_to_safe(jsobj_numberOfDisparities, numberOfDisparities, ArgInfo("numberOfDisparities", 0)) &&
        jsopencv_to_safe(jsobj_blockSize, blockSize, ArgInfo("blockSize", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::getValidDisparityROI(roi1, roi2, minDisparity, numberOfDisparities, blockSize));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_getVersionMajor(const Napi::CallbackInfo &info)
{
    using namespace cv;

    int retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::getVersionMajor());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_getVersionMinor(const Napi::CallbackInfo &info)
{
    using namespace cv;

    int retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::getVersionMinor());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_getVersionRevision(const Napi::CallbackInfo &info)
{
    using namespace cv;

    int retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::getVersionRevision());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_getVersionString(const Napi::CallbackInfo &info)
{
    using namespace cv;

    String retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::getVersionString());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_getWindowImageRect(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_winname = NULL;
    String winname;
    Rect retval;

    const char* keywords[] = { "winname", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:getWindowImageRect", (char**)keywords, &jsobj_winname) &&
        jsopencv_to_safe(jsobj_winname, winname, ArgInfo("winname", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::getWindowImageRect(winname));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_getWindowProperty(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_winname = NULL;
    String winname;
    Napi::Value* jsobj_prop_id = NULL;
    int prop_id=0;
    double retval;

    const char* keywords[] = { "winname", "prop_id", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:getWindowProperty", (char**)keywords, &jsobj_winname, &jsobj_prop_id) &&
        jsopencv_to_safe(jsobj_winname, winname, ArgInfo("winname", 0)) &&
        jsopencv_to_safe(jsobj_prop_id, prop_id, ArgInfo("prop_id", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::getWindowProperty(winname, prop_id));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_goodFeaturesToTrack(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(4);

    {
    Napi::Value* jsobj_image = NULL;
    Mat image;
    Napi::Value* jsobj_corners = NULL;
    Mat corners;
    Napi::Value* jsobj_maxCorners = NULL;
    int maxCorners=0;
    Napi::Value* jsobj_qualityLevel = NULL;
    double qualityLevel=0;
    Napi::Value* jsobj_minDistance = NULL;
    double minDistance=0;
    Napi::Value* jsobj_mask = NULL;
    Mat mask;
    Napi::Value* jsobj_blockSize = NULL;
    int blockSize=3;
    Napi::Value* jsobj_useHarrisDetector = NULL;
    bool useHarrisDetector=false;
    Napi::Value* jsobj_k = NULL;
    double k=0.04;

    const char* keywords[] = { "image", "maxCorners", "qualityLevel", "minDistance", "corners", "mask", "blockSize", "useHarrisDetector", "k", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOOOO:goodFeaturesToTrack", (char**)keywords, &jsobj_image, &jsobj_maxCorners, &jsobj_qualityLevel, &jsobj_minDistance, &jsobj_corners, &jsobj_mask, &jsobj_blockSize, &jsobj_useHarrisDetector, &jsobj_k) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_corners, corners, ArgInfo("corners", 1)) &&
        jsopencv_to_safe(jsobj_maxCorners, maxCorners, ArgInfo("maxCorners", 0)) &&
        jsopencv_to_safe(jsobj_qualityLevel, qualityLevel, ArgInfo("qualityLevel", 0)) &&
        jsopencv_to_safe(jsobj_minDistance, minDistance, ArgInfo("minDistance", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)) &&
        jsopencv_to_safe(jsobj_blockSize, blockSize, ArgInfo("blockSize", 0)) &&
        jsopencv_to_safe(jsobj_useHarrisDetector, useHarrisDetector, ArgInfo("useHarrisDetector", 0)) &&
        jsopencv_to_safe(jsobj_k, k, ArgInfo("k", 0)))
    {
        ERRWRAP2_NAPI(info, cv::goodFeaturesToTrack(image, corners, maxCorners, qualityLevel, minDistance, mask, blockSize, useHarrisDetector, k));
        return jsopencv_from(info, corners);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_image = NULL;
    UMat image;
    Napi::Value* jsobj_corners = NULL;
    UMat corners;
    Napi::Value* jsobj_maxCorners = NULL;
    int maxCorners=0;
    Napi::Value* jsobj_qualityLevel = NULL;
    double qualityLevel=0;
    Napi::Value* jsobj_minDistance = NULL;
    double minDistance=0;
    Napi::Value* jsobj_mask = NULL;
    UMat mask;
    Napi::Value* jsobj_blockSize = NULL;
    int blockSize=3;
    Napi::Value* jsobj_useHarrisDetector = NULL;
    bool useHarrisDetector=false;
    Napi::Value* jsobj_k = NULL;
    double k=0.04;

    const char* keywords[] = { "image", "maxCorners", "qualityLevel", "minDistance", "corners", "mask", "blockSize", "useHarrisDetector", "k", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOOOO:goodFeaturesToTrack", (char**)keywords, &jsobj_image, &jsobj_maxCorners, &jsobj_qualityLevel, &jsobj_minDistance, &jsobj_corners, &jsobj_mask, &jsobj_blockSize, &jsobj_useHarrisDetector, &jsobj_k) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_corners, corners, ArgInfo("corners", 1)) &&
        jsopencv_to_safe(jsobj_maxCorners, maxCorners, ArgInfo("maxCorners", 0)) &&
        jsopencv_to_safe(jsobj_qualityLevel, qualityLevel, ArgInfo("qualityLevel", 0)) &&
        jsopencv_to_safe(jsobj_minDistance, minDistance, ArgInfo("minDistance", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)) &&
        jsopencv_to_safe(jsobj_blockSize, blockSize, ArgInfo("blockSize", 0)) &&
        jsopencv_to_safe(jsobj_useHarrisDetector, useHarrisDetector, ArgInfo("useHarrisDetector", 0)) &&
        jsopencv_to_safe(jsobj_k, k, ArgInfo("k", 0)))
    {
        ERRWRAP2_NAPI(info, cv::goodFeaturesToTrack(image, corners, maxCorners, qualityLevel, minDistance, mask, blockSize, useHarrisDetector, k));
        return jsopencv_from(info, corners);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_image = NULL;
    Mat image;
    Napi::Value* jsobj_corners = NULL;
    Mat corners;
    Napi::Value* jsobj_maxCorners = NULL;
    int maxCorners=0;
    Napi::Value* jsobj_qualityLevel = NULL;
    double qualityLevel=0;
    Napi::Value* jsobj_minDistance = NULL;
    double minDistance=0;
    Napi::Value* jsobj_mask = NULL;
    Mat mask;
    Napi::Value* jsobj_blockSize = NULL;
    int blockSize=0;
    Napi::Value* jsobj_gradientSize = NULL;
    int gradientSize=0;
    Napi::Value* jsobj_useHarrisDetector = NULL;
    bool useHarrisDetector=false;
    Napi::Value* jsobj_k = NULL;
    double k=0.04;

    const char* keywords[] = { "image", "maxCorners", "qualityLevel", "minDistance", "mask", "blockSize", "gradientSize", "corners", "useHarrisDetector", "k", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOOO|OOO:goodFeaturesToTrack", (char**)keywords, &jsobj_image, &jsobj_maxCorners, &jsobj_qualityLevel, &jsobj_minDistance, &jsobj_mask, &jsobj_blockSize, &jsobj_gradientSize, &jsobj_corners, &jsobj_useHarrisDetector, &jsobj_k) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_corners, corners, ArgInfo("corners", 1)) &&
        jsopencv_to_safe(jsobj_maxCorners, maxCorners, ArgInfo("maxCorners", 0)) &&
        jsopencv_to_safe(jsobj_qualityLevel, qualityLevel, ArgInfo("qualityLevel", 0)) &&
        jsopencv_to_safe(jsobj_minDistance, minDistance, ArgInfo("minDistance", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)) &&
        jsopencv_to_safe(jsobj_blockSize, blockSize, ArgInfo("blockSize", 0)) &&
        jsopencv_to_safe(jsobj_gradientSize, gradientSize, ArgInfo("gradientSize", 0)) &&
        jsopencv_to_safe(jsobj_useHarrisDetector, useHarrisDetector, ArgInfo("useHarrisDetector", 0)) &&
        jsopencv_to_safe(jsobj_k, k, ArgInfo("k", 0)))
    {
        ERRWRAP2_NAPI(info, cv::goodFeaturesToTrack(image, corners, maxCorners, qualityLevel, minDistance, mask, blockSize, gradientSize, useHarrisDetector, k));
        return jsopencv_from(info, corners);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_image = NULL;
    UMat image;
    Napi::Value* jsobj_corners = NULL;
    UMat corners;
    Napi::Value* jsobj_maxCorners = NULL;
    int maxCorners=0;
    Napi::Value* jsobj_qualityLevel = NULL;
    double qualityLevel=0;
    Napi::Value* jsobj_minDistance = NULL;
    double minDistance=0;
    Napi::Value* jsobj_mask = NULL;
    UMat mask;
    Napi::Value* jsobj_blockSize = NULL;
    int blockSize=0;
    Napi::Value* jsobj_gradientSize = NULL;
    int gradientSize=0;
    Napi::Value* jsobj_useHarrisDetector = NULL;
    bool useHarrisDetector=false;
    Napi::Value* jsobj_k = NULL;
    double k=0.04;

    const char* keywords[] = { "image", "maxCorners", "qualityLevel", "minDistance", "mask", "blockSize", "gradientSize", "corners", "useHarrisDetector", "k", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOOO|OOO:goodFeaturesToTrack", (char**)keywords, &jsobj_image, &jsobj_maxCorners, &jsobj_qualityLevel, &jsobj_minDistance, &jsobj_mask, &jsobj_blockSize, &jsobj_gradientSize, &jsobj_corners, &jsobj_useHarrisDetector, &jsobj_k) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_corners, corners, ArgInfo("corners", 1)) &&
        jsopencv_to_safe(jsobj_maxCorners, maxCorners, ArgInfo("maxCorners", 0)) &&
        jsopencv_to_safe(jsobj_qualityLevel, qualityLevel, ArgInfo("qualityLevel", 0)) &&
        jsopencv_to_safe(jsobj_minDistance, minDistance, ArgInfo("minDistance", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)) &&
        jsopencv_to_safe(jsobj_blockSize, blockSize, ArgInfo("blockSize", 0)) &&
        jsopencv_to_safe(jsobj_gradientSize, gradientSize, ArgInfo("gradientSize", 0)) &&
        jsopencv_to_safe(jsobj_useHarrisDetector, useHarrisDetector, ArgInfo("useHarrisDetector", 0)) &&
        jsopencv_to_safe(jsobj_k, k, ArgInfo("k", 0)))
    {
        ERRWRAP2_NAPI(info, cv::goodFeaturesToTrack(image, corners, maxCorners, qualityLevel, minDistance, mask, blockSize, gradientSize, useHarrisDetector, k));
        return jsopencv_from(info, corners);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "goodFeaturesToTrack");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_goodFeaturesToTrackWithQuality(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_image = NULL;
    Mat image;
    Napi::Value* jsobj_corners = NULL;
    Mat corners;
    Napi::Value* jsobj_maxCorners = NULL;
    int maxCorners=0;
    Napi::Value* jsobj_qualityLevel = NULL;
    double qualityLevel=0;
    Napi::Value* jsobj_minDistance = NULL;
    double minDistance=0;
    Napi::Value* jsobj_mask = NULL;
    Mat mask;
    Napi::Value* jsobj_cornersQuality = NULL;
    Mat cornersQuality;
    Napi::Value* jsobj_blockSize = NULL;
    int blockSize=3;
    Napi::Value* jsobj_gradientSize = NULL;
    int gradientSize=3;
    Napi::Value* jsobj_useHarrisDetector = NULL;
    bool useHarrisDetector=false;
    Napi::Value* jsobj_k = NULL;
    double k=0.04;

    const char* keywords[] = { "image", "maxCorners", "qualityLevel", "minDistance", "mask", "corners", "cornersQuality", "blockSize", "gradientSize", "useHarrisDetector", "k", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOO|OOOOOO:goodFeaturesToTrackWithQuality", (char**)keywords, &jsobj_image, &jsobj_maxCorners, &jsobj_qualityLevel, &jsobj_minDistance, &jsobj_mask, &jsobj_corners, &jsobj_cornersQuality, &jsobj_blockSize, &jsobj_gradientSize, &jsobj_useHarrisDetector, &jsobj_k) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_corners, corners, ArgInfo("corners", 1)) &&
        jsopencv_to_safe(jsobj_maxCorners, maxCorners, ArgInfo("maxCorners", 0)) &&
        jsopencv_to_safe(jsobj_qualityLevel, qualityLevel, ArgInfo("qualityLevel", 0)) &&
        jsopencv_to_safe(jsobj_minDistance, minDistance, ArgInfo("minDistance", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)) &&
        jsopencv_to_safe(jsobj_cornersQuality, cornersQuality, ArgInfo("cornersQuality", 1)) &&
        jsopencv_to_safe(jsobj_blockSize, blockSize, ArgInfo("blockSize", 0)) &&
        jsopencv_to_safe(jsobj_gradientSize, gradientSize, ArgInfo("gradientSize", 0)) &&
        jsopencv_to_safe(jsobj_useHarrisDetector, useHarrisDetector, ArgInfo("useHarrisDetector", 0)) &&
        jsopencv_to_safe(jsobj_k, k, ArgInfo("k", 0)))
    {
        ERRWRAP2_NAPI(info, cv::goodFeaturesToTrack(image, corners, maxCorners, qualityLevel, minDistance, mask, cornersQuality, blockSize, gradientSize, useHarrisDetector, k));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, corners), jsopencv_from(info, cornersQuality));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_image = NULL;
    UMat image;
    Napi::Value* jsobj_corners = NULL;
    UMat corners;
    Napi::Value* jsobj_maxCorners = NULL;
    int maxCorners=0;
    Napi::Value* jsobj_qualityLevel = NULL;
    double qualityLevel=0;
    Napi::Value* jsobj_minDistance = NULL;
    double minDistance=0;
    Napi::Value* jsobj_mask = NULL;
    UMat mask;
    Napi::Value* jsobj_cornersQuality = NULL;
    UMat cornersQuality;
    Napi::Value* jsobj_blockSize = NULL;
    int blockSize=3;
    Napi::Value* jsobj_gradientSize = NULL;
    int gradientSize=3;
    Napi::Value* jsobj_useHarrisDetector = NULL;
    bool useHarrisDetector=false;
    Napi::Value* jsobj_k = NULL;
    double k=0.04;

    const char* keywords[] = { "image", "maxCorners", "qualityLevel", "minDistance", "mask", "corners", "cornersQuality", "blockSize", "gradientSize", "useHarrisDetector", "k", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOO|OOOOOO:goodFeaturesToTrackWithQuality", (char**)keywords, &jsobj_image, &jsobj_maxCorners, &jsobj_qualityLevel, &jsobj_minDistance, &jsobj_mask, &jsobj_corners, &jsobj_cornersQuality, &jsobj_blockSize, &jsobj_gradientSize, &jsobj_useHarrisDetector, &jsobj_k) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_corners, corners, ArgInfo("corners", 1)) &&
        jsopencv_to_safe(jsobj_maxCorners, maxCorners, ArgInfo("maxCorners", 0)) &&
        jsopencv_to_safe(jsobj_qualityLevel, qualityLevel, ArgInfo("qualityLevel", 0)) &&
        jsopencv_to_safe(jsobj_minDistance, minDistance, ArgInfo("minDistance", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)) &&
        jsopencv_to_safe(jsobj_cornersQuality, cornersQuality, ArgInfo("cornersQuality", 1)) &&
        jsopencv_to_safe(jsobj_blockSize, blockSize, ArgInfo("blockSize", 0)) &&
        jsopencv_to_safe(jsobj_gradientSize, gradientSize, ArgInfo("gradientSize", 0)) &&
        jsopencv_to_safe(jsobj_useHarrisDetector, useHarrisDetector, ArgInfo("useHarrisDetector", 0)) &&
        jsopencv_to_safe(jsobj_k, k, ArgInfo("k", 0)))
    {
        ERRWRAP2_NAPI(info, cv::goodFeaturesToTrack(image, corners, maxCorners, qualityLevel, minDistance, mask, cornersQuality, blockSize, gradientSize, useHarrisDetector, k));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, corners), jsopencv_from(info, cornersQuality));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "goodFeaturesToTrackWithQuality");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_grabCut(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_img = NULL;
    Mat img;
    Napi::Value* jsobj_mask = NULL;
    Mat mask;
    Napi::Value* jsobj_rect = NULL;
    Rect rect;
    Napi::Value* jsobj_bgdModel = NULL;
    Mat bgdModel;
    Napi::Value* jsobj_fgdModel = NULL;
    Mat fgdModel;
    Napi::Value* jsobj_iterCount = NULL;
    int iterCount=0;
    Napi::Value* jsobj_mode = NULL;
    int mode=GC_EVAL;

    const char* keywords[] = { "img", "mask", "rect", "bgdModel", "fgdModel", "iterCount", "mode", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOO|O:grabCut", (char**)keywords, &jsobj_img, &jsobj_mask, &jsobj_rect, &jsobj_bgdModel, &jsobj_fgdModel, &jsobj_iterCount, &jsobj_mode) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 1)) &&
        jsopencv_to_safe(jsobj_rect, rect, ArgInfo("rect", 0)) &&
        jsopencv_to_safe(jsobj_bgdModel, bgdModel, ArgInfo("bgdModel", 1)) &&
        jsopencv_to_safe(jsobj_fgdModel, fgdModel, ArgInfo("fgdModel", 1)) &&
        jsopencv_to_safe(jsobj_iterCount, iterCount, ArgInfo("iterCount", 0)) &&
        jsopencv_to_safe(jsobj_mode, mode, ArgInfo("mode", 0)))
    {
        ERRWRAP2_NAPI(info, cv::grabCut(img, mask, rect, bgdModel, fgdModel, iterCount, mode));
        return Js_BuildValue(info, "(NNN)", jsopencv_from(info, mask), jsopencv_from(info, bgdModel), jsopencv_from(info, fgdModel));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_img = NULL;
    UMat img;
    Napi::Value* jsobj_mask = NULL;
    UMat mask;
    Napi::Value* jsobj_rect = NULL;
    Rect rect;
    Napi::Value* jsobj_bgdModel = NULL;
    UMat bgdModel;
    Napi::Value* jsobj_fgdModel = NULL;
    UMat fgdModel;
    Napi::Value* jsobj_iterCount = NULL;
    int iterCount=0;
    Napi::Value* jsobj_mode = NULL;
    int mode=GC_EVAL;

    const char* keywords[] = { "img", "mask", "rect", "bgdModel", "fgdModel", "iterCount", "mode", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOO|O:grabCut", (char**)keywords, &jsobj_img, &jsobj_mask, &jsobj_rect, &jsobj_bgdModel, &jsobj_fgdModel, &jsobj_iterCount, &jsobj_mode) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 1)) &&
        jsopencv_to_safe(jsobj_rect, rect, ArgInfo("rect", 0)) &&
        jsopencv_to_safe(jsobj_bgdModel, bgdModel, ArgInfo("bgdModel", 1)) &&
        jsopencv_to_safe(jsobj_fgdModel, fgdModel, ArgInfo("fgdModel", 1)) &&
        jsopencv_to_safe(jsobj_iterCount, iterCount, ArgInfo("iterCount", 0)) &&
        jsopencv_to_safe(jsobj_mode, mode, ArgInfo("mode", 0)))
    {
        ERRWRAP2_NAPI(info, cv::grabCut(img, mask, rect, bgdModel, fgdModel, iterCount, mode));
        return Js_BuildValue(info, "(NNN)", jsopencv_from(info, mask), jsopencv_from(info, bgdModel), jsopencv_from(info, fgdModel));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "grabCut");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_groupRectangles(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_rectList = NULL;
    vector_Rect rectList;
    vector_int weights;
    Napi::Value* jsobj_groupThreshold = NULL;
    int groupThreshold=0;
    Napi::Value* jsobj_eps = NULL;
    double eps=0.2;

    const char* keywords[] = { "rectList", "groupThreshold", "eps", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:groupRectangles", (char**)keywords, &jsobj_rectList, &jsobj_groupThreshold, &jsobj_eps) &&
        jsopencv_to_safe(jsobj_rectList, rectList, ArgInfo("rectList", 1)) &&
        jsopencv_to_safe(jsobj_groupThreshold, groupThreshold, ArgInfo("groupThreshold", 0)) &&
        jsopencv_to_safe(jsobj_eps, eps, ArgInfo("eps", 0)))
    {
        ERRWRAP2_NAPI(info, cv::groupRectangles(rectList, weights, groupThreshold, eps));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, rectList), jsopencv_from(info, weights));
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_haveImageReader(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_filename = NULL;
    String filename;
    bool retval;

    const char* keywords[] = { "filename", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:haveImageReader", (char**)keywords, &jsobj_filename) &&
        jsopencv_to_safe(jsobj_filename, filename, ArgInfo("filename", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::haveImageReader(filename));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_haveImageWriter(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_filename = NULL;
    String filename;
    bool retval;

    const char* keywords[] = { "filename", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:haveImageWriter", (char**)keywords, &jsobj_filename) &&
        jsopencv_to_safe(jsobj_filename, filename, ArgInfo("filename", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::haveImageWriter(filename));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_haveOpenVX(const Napi::CallbackInfo &info)
{
    using namespace cv;

    bool retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::haveOpenVX());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_hconcat(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    vector_Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;

    const char* keywords[] = { "src", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:hconcat", (char**)keywords, &jsobj_src, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)))
    {
        ERRWRAP2_NAPI(info, cv::hconcat(src, dst));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    vector_UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;

    const char* keywords[] = { "src", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:hconcat", (char**)keywords, &jsobj_src, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)))
    {
        ERRWRAP2_NAPI(info, cv::hconcat(src, dst));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "hconcat");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_idct(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;

    const char* keywords[] = { "src", "dst", "flags", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OO:idct", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_flags) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, cv::idct(src, dst, flags));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;

    const char* keywords[] = { "src", "dst", "flags", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OO:idct", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_flags) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, cv::idct(src, dst, flags));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "idct");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_idft(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;
    Napi::Value* jsobj_nonzeroRows = NULL;
    int nonzeroRows=0;

    const char* keywords[] = { "src", "dst", "flags", "nonzeroRows", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOO:idft", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_flags, &jsobj_nonzeroRows) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_nonzeroRows, nonzeroRows, ArgInfo("nonzeroRows", 0)))
    {
        ERRWRAP2_NAPI(info, cv::idft(src, dst, flags, nonzeroRows));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;
    Napi::Value* jsobj_nonzeroRows = NULL;
    int nonzeroRows=0;

    const char* keywords[] = { "src", "dst", "flags", "nonzeroRows", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOO:idft", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_flags, &jsobj_nonzeroRows) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_nonzeroRows, nonzeroRows, ArgInfo("nonzeroRows", 0)))
    {
        ERRWRAP2_NAPI(info, cv::idft(src, dst, flags, nonzeroRows));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "idft");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_illuminationChange(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_mask = NULL;
    Mat mask;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_alpha = NULL;
    float alpha=0.2f;
    Napi::Value* jsobj_beta = NULL;
    float beta=0.4f;

    const char* keywords[] = { "src", "mask", "dst", "alpha", "beta", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOO:illuminationChange", (char**)keywords, &jsobj_src, &jsobj_mask, &jsobj_dst, &jsobj_alpha, &jsobj_beta) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_alpha, alpha, ArgInfo("alpha", 0)) &&
        jsopencv_to_safe(jsobj_beta, beta, ArgInfo("beta", 0)))
    {
        ERRWRAP2_NAPI(info, cv::illuminationChange(src, mask, dst, alpha, beta));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_mask = NULL;
    UMat mask;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_alpha = NULL;
    float alpha=0.2f;
    Napi::Value* jsobj_beta = NULL;
    float beta=0.4f;

    const char* keywords[] = { "src", "mask", "dst", "alpha", "beta", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOO:illuminationChange", (char**)keywords, &jsobj_src, &jsobj_mask, &jsobj_dst, &jsobj_alpha, &jsobj_beta) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_alpha, alpha, ArgInfo("alpha", 0)) &&
        jsopencv_to_safe(jsobj_beta, beta, ArgInfo("beta", 0)))
    {
        ERRWRAP2_NAPI(info, cv::illuminationChange(src, mask, dst, alpha, beta));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "illuminationChange");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_imcount(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_filename = NULL;
    String filename;
    Napi::Value* jsobj_flags = NULL;
    int flags=IMREAD_ANYCOLOR;
    size_t retval;

    const char* keywords[] = { "filename", "flags", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:imcount", (char**)keywords, &jsobj_filename, &jsobj_flags) &&
        jsopencv_to_safe(jsobj_filename, filename, ArgInfo("filename", 0)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::imcount(filename, flags));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_imdecode(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_buf = NULL;
    Mat buf;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;
    Mat retval;

    const char* keywords[] = { "buf", "flags", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:imdecode", (char**)keywords, &jsobj_buf, &jsobj_flags) &&
        jsopencv_to_safe(jsobj_buf, buf, ArgInfo("buf", 0)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::imdecode(buf, flags));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_buf = NULL;
    UMat buf;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;
    Mat retval;

    const char* keywords[] = { "buf", "flags", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:imdecode", (char**)keywords, &jsobj_buf, &jsobj_flags) &&
        jsopencv_to_safe(jsobj_buf, buf, ArgInfo("buf", 0)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::imdecode(buf, flags));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "imdecode");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_imdecodemulti(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_buf = NULL;
    Mat buf;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;
    Napi::Value* jsobj_mats = NULL;
    vector_Mat mats;
    bool retval;

    const char* keywords[] = { "buf", "flags", "mats", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:imdecodemulti", (char**)keywords, &jsobj_buf, &jsobj_flags, &jsobj_mats) &&
        jsopencv_to_safe(jsobj_buf, buf, ArgInfo("buf", 0)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_mats, mats, ArgInfo("mats", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::imdecodemulti(buf, flags, mats));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, mats));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_buf = NULL;
    UMat buf;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;
    Napi::Value* jsobj_mats = NULL;
    vector_Mat mats;
    bool retval;

    const char* keywords[] = { "buf", "flags", "mats", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:imdecodemulti", (char**)keywords, &jsobj_buf, &jsobj_flags, &jsobj_mats) &&
        jsopencv_to_safe(jsobj_buf, buf, ArgInfo("buf", 0)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_mats, mats, ArgInfo("mats", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::imdecodemulti(buf, flags, mats));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, mats));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "imdecodemulti");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_imencode(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_ext = NULL;
    String ext;
    Napi::Value* jsobj_img = NULL;
    Mat img;
    vector_uchar buf;
    Napi::Value* jsobj_params = NULL;
    vector_int params=std::vector<int>();
    bool retval;

    const char* keywords[] = { "ext", "img", "params", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:imencode", (char**)keywords, &jsobj_ext, &jsobj_img, &jsobj_params) &&
        jsopencv_to_safe(jsobj_ext, ext, ArgInfo("ext", 0)) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 0)) &&
        jsopencv_to_safe(jsobj_params, params, ArgInfo("params", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::imencode(ext, img, buf, params));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, buf));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_ext = NULL;
    String ext;
    Napi::Value* jsobj_img = NULL;
    UMat img;
    vector_uchar buf;
    Napi::Value* jsobj_params = NULL;
    vector_int params=std::vector<int>();
    bool retval;

    const char* keywords[] = { "ext", "img", "params", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:imencode", (char**)keywords, &jsobj_ext, &jsobj_img, &jsobj_params) &&
        jsopencv_to_safe(jsobj_ext, ext, ArgInfo("ext", 0)) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 0)) &&
        jsopencv_to_safe(jsobj_params, params, ArgInfo("params", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::imencode(ext, img, buf, params));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, buf));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "imencode");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_imread(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_filename = NULL;
    String filename;
    Napi::Value* jsobj_flags = NULL;
    int flags=IMREAD_COLOR;
    Mat retval;

    const char* keywords[] = { "filename", "flags", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:imread", (char**)keywords, &jsobj_filename, &jsobj_flags) &&
        jsopencv_to_safe(jsobj_filename, filename, ArgInfo("filename", 0)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::imread(filename, flags));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_imreadmulti(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_filename = NULL;
    String filename;
    Napi::Value* jsobj_mats = NULL;
    vector_Mat mats;
    Napi::Value* jsobj_flags = NULL;
    int flags=IMREAD_ANYCOLOR;
    bool retval;

    const char* keywords[] = { "filename", "mats", "flags", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OO:imreadmulti", (char**)keywords, &jsobj_filename, &jsobj_mats, &jsobj_flags) &&
        jsopencv_to_safe(jsobj_filename, filename, ArgInfo("filename", 0)) &&
        jsopencv_to_safe(jsobj_mats, mats, ArgInfo("mats", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::imreadmulti(filename, mats, flags));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, mats));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_filename = NULL;
    String filename;
    Napi::Value* jsobj_mats = NULL;
    vector_Mat mats;
    Napi::Value* jsobj_start = NULL;
    int start=0;
    Napi::Value* jsobj_count = NULL;
    int count=0;
    Napi::Value* jsobj_flags = NULL;
    int flags=IMREAD_ANYCOLOR;
    bool retval;

    const char* keywords[] = { "filename", "start", "count", "mats", "flags", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OO:imreadmulti", (char**)keywords, &jsobj_filename, &jsobj_start, &jsobj_count, &jsobj_mats, &jsobj_flags) &&
        jsopencv_to_safe(jsobj_filename, filename, ArgInfo("filename", 0)) &&
        jsopencv_to_safe(jsobj_mats, mats, ArgInfo("mats", 1)) &&
        jsopencv_to_safe(jsobj_start, start, ArgInfo("start", 0)) &&
        jsopencv_to_safe(jsobj_count, count, ArgInfo("count", 0)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::imreadmulti(filename, mats, start, count, flags));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, mats));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "imreadmulti");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_imshow(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(3);

    {
    Napi::Value* jsobj_winname = NULL;
    String winname;
    Napi::Value* jsobj_mat = NULL;
    Mat mat;

    const char* keywords[] = { "winname", "mat", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:imshow", (char**)keywords, &jsobj_winname, &jsobj_mat) &&
        jsopencv_to_safe(jsobj_winname, winname, ArgInfo("winname", 0)) &&
        jsopencv_to_safe(jsobj_mat, mat, ArgInfo("mat", 0)))
    {
        ERRWRAP2_NAPI(info, cv::imshow(winname, mat));
        return info.Env().Null();;
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_winname = NULL;
    String winname;
    Napi::Value* jsobj_mat = NULL;
    cuda::GpuMat mat;

    const char* keywords[] = { "winname", "mat", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:imshow", (char**)keywords, &jsobj_winname, &jsobj_mat) &&
        jsopencv_to_safe(jsobj_winname, winname, ArgInfo("winname", 0)) &&
        jsopencv_to_safe(jsobj_mat, mat, ArgInfo("mat", 0)))
    {
        ERRWRAP2_NAPI(info, cv::imshow(winname, mat));
        return info.Env().Null();;
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_winname = NULL;
    String winname;
    Napi::Value* jsobj_mat = NULL;
    UMat mat;

    const char* keywords[] = { "winname", "mat", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:imshow", (char**)keywords, &jsobj_winname, &jsobj_mat) &&
        jsopencv_to_safe(jsobj_winname, winname, ArgInfo("winname", 0)) &&
        jsopencv_to_safe(jsobj_mat, mat, ArgInfo("mat", 0)))
    {
        ERRWRAP2_NAPI(info, cv::imshow(winname, mat));
        return info.Env().Null();;
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "imshow");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_imwrite(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_filename = NULL;
    String filename;
    Napi::Value* jsobj_img = NULL;
    Mat img;
    Napi::Value* jsobj_params = NULL;
    vector_int params=std::vector<int>();
    bool retval;

    const char* keywords[] = { "filename", "img", "params", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:imwrite", (char**)keywords, &jsobj_filename, &jsobj_img, &jsobj_params) &&
        jsopencv_to_safe(jsobj_filename, filename, ArgInfo("filename", 0)) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 0)) &&
        jsopencv_to_safe(jsobj_params, params, ArgInfo("params", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::imwrite(filename, img, params));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_filename = NULL;
    String filename;
    Napi::Value* jsobj_img = NULL;
    UMat img;
    Napi::Value* jsobj_params = NULL;
    vector_int params=std::vector<int>();
    bool retval;

    const char* keywords[] = { "filename", "img", "params", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:imwrite", (char**)keywords, &jsobj_filename, &jsobj_img, &jsobj_params) &&
        jsopencv_to_safe(jsobj_filename, filename, ArgInfo("filename", 0)) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 0)) &&
        jsopencv_to_safe(jsobj_params, params, ArgInfo("params", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::imwrite(filename, img, params));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "imwrite");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_imwritemulti(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_filename = NULL;
    String filename;
    Napi::Value* jsobj_img = NULL;
    vector_Mat img;
    Napi::Value* jsobj_params = NULL;
    vector_int params=std::vector<int>();
    bool retval;

    const char* keywords[] = { "filename", "img", "params", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:imwritemulti", (char**)keywords, &jsobj_filename, &jsobj_img, &jsobj_params) &&
        jsopencv_to_safe(jsobj_filename, filename, ArgInfo("filename", 0)) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 0)) &&
        jsopencv_to_safe(jsobj_params, params, ArgInfo("params", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::imwritemulti(filename, img, params));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_filename = NULL;
    String filename;
    Napi::Value* jsobj_img = NULL;
    vector_UMat img;
    Napi::Value* jsobj_params = NULL;
    vector_int params=std::vector<int>();
    bool retval;

    const char* keywords[] = { "filename", "img", "params", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:imwritemulti", (char**)keywords, &jsobj_filename, &jsobj_img, &jsobj_params) &&
        jsopencv_to_safe(jsobj_filename, filename, ArgInfo("filename", 0)) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 0)) &&
        jsopencv_to_safe(jsobj_params, params, ArgInfo("params", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::imwritemulti(filename, img, params));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "imwritemulti");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_inRange(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_lowerb = NULL;
    Mat lowerb;
    Napi::Value* jsobj_upperb = NULL;
    Mat upperb;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;

    const char* keywords[] = { "src", "lowerb", "upperb", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:inRange", (char**)keywords, &jsobj_src, &jsobj_lowerb, &jsobj_upperb, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_lowerb, lowerb, ArgInfo("lowerb", 0)) &&
        jsopencv_to_safe(jsobj_upperb, upperb, ArgInfo("upperb", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)))
    {
        ERRWRAP2_NAPI(info, cv::inRange(src, lowerb, upperb, dst));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_lowerb = NULL;
    UMat lowerb;
    Napi::Value* jsobj_upperb = NULL;
    UMat upperb;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;

    const char* keywords[] = { "src", "lowerb", "upperb", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:inRange", (char**)keywords, &jsobj_src, &jsobj_lowerb, &jsobj_upperb, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_lowerb, lowerb, ArgInfo("lowerb", 0)) &&
        jsopencv_to_safe(jsobj_upperb, upperb, ArgInfo("upperb", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)))
    {
        ERRWRAP2_NAPI(info, cv::inRange(src, lowerb, upperb, dst));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "inRange");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_initCameraMatrix2D(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_objectPoints = NULL;
    vector_Mat objectPoints;
    Napi::Value* jsobj_imagePoints = NULL;
    vector_Mat imagePoints;
    Napi::Value* jsobj_imageSize = NULL;
    Size imageSize;
    Napi::Value* jsobj_aspectRatio = NULL;
    double aspectRatio=1.0;
    Mat retval;

    const char* keywords[] = { "objectPoints", "imagePoints", "imageSize", "aspectRatio", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:initCameraMatrix2D", (char**)keywords, &jsobj_objectPoints, &jsobj_imagePoints, &jsobj_imageSize, &jsobj_aspectRatio) &&
        jsopencv_to_safe(jsobj_objectPoints, objectPoints, ArgInfo("objectPoints", 0)) &&
        jsopencv_to_safe(jsobj_imagePoints, imagePoints, ArgInfo("imagePoints", 0)) &&
        jsopencv_to_safe(jsobj_imageSize, imageSize, ArgInfo("imageSize", 0)) &&
        jsopencv_to_safe(jsobj_aspectRatio, aspectRatio, ArgInfo("aspectRatio", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::initCameraMatrix2D(objectPoints, imagePoints, imageSize, aspectRatio));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_objectPoints = NULL;
    vector_UMat objectPoints;
    Napi::Value* jsobj_imagePoints = NULL;
    vector_UMat imagePoints;
    Napi::Value* jsobj_imageSize = NULL;
    Size imageSize;
    Napi::Value* jsobj_aspectRatio = NULL;
    double aspectRatio=1.0;
    Mat retval;

    const char* keywords[] = { "objectPoints", "imagePoints", "imageSize", "aspectRatio", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:initCameraMatrix2D", (char**)keywords, &jsobj_objectPoints, &jsobj_imagePoints, &jsobj_imageSize, &jsobj_aspectRatio) &&
        jsopencv_to_safe(jsobj_objectPoints, objectPoints, ArgInfo("objectPoints", 0)) &&
        jsopencv_to_safe(jsobj_imagePoints, imagePoints, ArgInfo("imagePoints", 0)) &&
        jsopencv_to_safe(jsobj_imageSize, imageSize, ArgInfo("imageSize", 0)) &&
        jsopencv_to_safe(jsobj_aspectRatio, aspectRatio, ArgInfo("aspectRatio", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::initCameraMatrix2D(objectPoints, imagePoints, imageSize, aspectRatio));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "initCameraMatrix2D");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_initInverseRectificationMap(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_cameraMatrix = NULL;
    Mat cameraMatrix;
    Napi::Value* jsobj_distCoeffs = NULL;
    Mat distCoeffs;
    Napi::Value* jsobj_R = NULL;
    Mat R;
    Napi::Value* jsobj_newCameraMatrix = NULL;
    Mat newCameraMatrix;
    Napi::Value* jsobj_size = NULL;
    Size size;
    Napi::Value* jsobj_m1type = NULL;
    int m1type=0;
    Napi::Value* jsobj_map1 = NULL;
    Mat map1;
    Napi::Value* jsobj_map2 = NULL;
    Mat map2;

    const char* keywords[] = { "cameraMatrix", "distCoeffs", "R", "newCameraMatrix", "size", "m1type", "map1", "map2", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOO|OO:initInverseRectificationMap", (char**)keywords, &jsobj_cameraMatrix, &jsobj_distCoeffs, &jsobj_R, &jsobj_newCameraMatrix, &jsobj_size, &jsobj_m1type, &jsobj_map1, &jsobj_map2) &&
        jsopencv_to_safe(jsobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 0)) &&
        jsopencv_to_safe(jsobj_distCoeffs, distCoeffs, ArgInfo("distCoeffs", 0)) &&
        jsopencv_to_safe(jsobj_R, R, ArgInfo("R", 0)) &&
        jsopencv_to_safe(jsobj_newCameraMatrix, newCameraMatrix, ArgInfo("newCameraMatrix", 0)) &&
        jsopencv_to_safe(jsobj_size, size, ArgInfo("size", 0)) &&
        jsopencv_to_safe(jsobj_m1type, m1type, ArgInfo("m1type", 0)) &&
        jsopencv_to_safe(jsobj_map1, map1, ArgInfo("map1", 1)) &&
        jsopencv_to_safe(jsobj_map2, map2, ArgInfo("map2", 1)))
    {
        ERRWRAP2_NAPI(info, cv::initInverseRectificationMap(cameraMatrix, distCoeffs, R, newCameraMatrix, size, m1type, map1, map2));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, map1), jsopencv_from(info, map2));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_cameraMatrix = NULL;
    UMat cameraMatrix;
    Napi::Value* jsobj_distCoeffs = NULL;
    UMat distCoeffs;
    Napi::Value* jsobj_R = NULL;
    UMat R;
    Napi::Value* jsobj_newCameraMatrix = NULL;
    UMat newCameraMatrix;
    Napi::Value* jsobj_size = NULL;
    Size size;
    Napi::Value* jsobj_m1type = NULL;
    int m1type=0;
    Napi::Value* jsobj_map1 = NULL;
    UMat map1;
    Napi::Value* jsobj_map2 = NULL;
    UMat map2;

    const char* keywords[] = { "cameraMatrix", "distCoeffs", "R", "newCameraMatrix", "size", "m1type", "map1", "map2", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOO|OO:initInverseRectificationMap", (char**)keywords, &jsobj_cameraMatrix, &jsobj_distCoeffs, &jsobj_R, &jsobj_newCameraMatrix, &jsobj_size, &jsobj_m1type, &jsobj_map1, &jsobj_map2) &&
        jsopencv_to_safe(jsobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 0)) &&
        jsopencv_to_safe(jsobj_distCoeffs, distCoeffs, ArgInfo("distCoeffs", 0)) &&
        jsopencv_to_safe(jsobj_R, R, ArgInfo("R", 0)) &&
        jsopencv_to_safe(jsobj_newCameraMatrix, newCameraMatrix, ArgInfo("newCameraMatrix", 0)) &&
        jsopencv_to_safe(jsobj_size, size, ArgInfo("size", 0)) &&
        jsopencv_to_safe(jsobj_m1type, m1type, ArgInfo("m1type", 0)) &&
        jsopencv_to_safe(jsobj_map1, map1, ArgInfo("map1", 1)) &&
        jsopencv_to_safe(jsobj_map2, map2, ArgInfo("map2", 1)))
    {
        ERRWRAP2_NAPI(info, cv::initInverseRectificationMap(cameraMatrix, distCoeffs, R, newCameraMatrix, size, m1type, map1, map2));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, map1), jsopencv_from(info, map2));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "initInverseRectificationMap");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_initUndistortRectifyMap(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_cameraMatrix = NULL;
    Mat cameraMatrix;
    Napi::Value* jsobj_distCoeffs = NULL;
    Mat distCoeffs;
    Napi::Value* jsobj_R = NULL;
    Mat R;
    Napi::Value* jsobj_newCameraMatrix = NULL;
    Mat newCameraMatrix;
    Napi::Value* jsobj_size = NULL;
    Size size;
    Napi::Value* jsobj_m1type = NULL;
    int m1type=0;
    Napi::Value* jsobj_map1 = NULL;
    Mat map1;
    Napi::Value* jsobj_map2 = NULL;
    Mat map2;

    const char* keywords[] = { "cameraMatrix", "distCoeffs", "R", "newCameraMatrix", "size", "m1type", "map1", "map2", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOO|OO:initUndistortRectifyMap", (char**)keywords, &jsobj_cameraMatrix, &jsobj_distCoeffs, &jsobj_R, &jsobj_newCameraMatrix, &jsobj_size, &jsobj_m1type, &jsobj_map1, &jsobj_map2) &&
        jsopencv_to_safe(jsobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 0)) &&
        jsopencv_to_safe(jsobj_distCoeffs, distCoeffs, ArgInfo("distCoeffs", 0)) &&
        jsopencv_to_safe(jsobj_R, R, ArgInfo("R", 0)) &&
        jsopencv_to_safe(jsobj_newCameraMatrix, newCameraMatrix, ArgInfo("newCameraMatrix", 0)) &&
        jsopencv_to_safe(jsobj_size, size, ArgInfo("size", 0)) &&
        jsopencv_to_safe(jsobj_m1type, m1type, ArgInfo("m1type", 0)) &&
        jsopencv_to_safe(jsobj_map1, map1, ArgInfo("map1", 1)) &&
        jsopencv_to_safe(jsobj_map2, map2, ArgInfo("map2", 1)))
    {
        ERRWRAP2_NAPI(info, cv::initUndistortRectifyMap(cameraMatrix, distCoeffs, R, newCameraMatrix, size, m1type, map1, map2));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, map1), jsopencv_from(info, map2));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_cameraMatrix = NULL;
    UMat cameraMatrix;
    Napi::Value* jsobj_distCoeffs = NULL;
    UMat distCoeffs;
    Napi::Value* jsobj_R = NULL;
    UMat R;
    Napi::Value* jsobj_newCameraMatrix = NULL;
    UMat newCameraMatrix;
    Napi::Value* jsobj_size = NULL;
    Size size;
    Napi::Value* jsobj_m1type = NULL;
    int m1type=0;
    Napi::Value* jsobj_map1 = NULL;
    UMat map1;
    Napi::Value* jsobj_map2 = NULL;
    UMat map2;

    const char* keywords[] = { "cameraMatrix", "distCoeffs", "R", "newCameraMatrix", "size", "m1type", "map1", "map2", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOO|OO:initUndistortRectifyMap", (char**)keywords, &jsobj_cameraMatrix, &jsobj_distCoeffs, &jsobj_R, &jsobj_newCameraMatrix, &jsobj_size, &jsobj_m1type, &jsobj_map1, &jsobj_map2) &&
        jsopencv_to_safe(jsobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 0)) &&
        jsopencv_to_safe(jsobj_distCoeffs, distCoeffs, ArgInfo("distCoeffs", 0)) &&
        jsopencv_to_safe(jsobj_R, R, ArgInfo("R", 0)) &&
        jsopencv_to_safe(jsobj_newCameraMatrix, newCameraMatrix, ArgInfo("newCameraMatrix", 0)) &&
        jsopencv_to_safe(jsobj_size, size, ArgInfo("size", 0)) &&
        jsopencv_to_safe(jsobj_m1type, m1type, ArgInfo("m1type", 0)) &&
        jsopencv_to_safe(jsobj_map1, map1, ArgInfo("map1", 1)) &&
        jsopencv_to_safe(jsobj_map2, map2, ArgInfo("map2", 1)))
    {
        ERRWRAP2_NAPI(info, cv::initUndistortRectifyMap(cameraMatrix, distCoeffs, R, newCameraMatrix, size, m1type, map1, map2));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, map1), jsopencv_from(info, map2));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "initUndistortRectifyMap");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_inpaint(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_inpaintMask = NULL;
    Mat inpaintMask;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_inpaintRadius = NULL;
    double inpaintRadius=0;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;

    const char* keywords[] = { "src", "inpaintMask", "inpaintRadius", "flags", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|O:inpaint", (char**)keywords, &jsobj_src, &jsobj_inpaintMask, &jsobj_inpaintRadius, &jsobj_flags, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_inpaintMask, inpaintMask, ArgInfo("inpaintMask", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_inpaintRadius, inpaintRadius, ArgInfo("inpaintRadius", 0)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, cv::inpaint(src, inpaintMask, dst, inpaintRadius, flags));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_inpaintMask = NULL;
    UMat inpaintMask;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_inpaintRadius = NULL;
    double inpaintRadius=0;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;

    const char* keywords[] = { "src", "inpaintMask", "inpaintRadius", "flags", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|O:inpaint", (char**)keywords, &jsobj_src, &jsobj_inpaintMask, &jsobj_inpaintRadius, &jsobj_flags, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_inpaintMask, inpaintMask, ArgInfo("inpaintMask", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_inpaintRadius, inpaintRadius, ArgInfo("inpaintRadius", 0)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, cv::inpaint(src, inpaintMask, dst, inpaintRadius, flags));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "inpaint");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_insertChannel(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_coi = NULL;
    int coi=0;

    const char* keywords[] = { "src", "dst", "coi", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:insertChannel", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_coi) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_coi, coi, ArgInfo("coi", 0)))
    {
        ERRWRAP2_NAPI(info, cv::insertChannel(src, dst, coi));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_coi = NULL;
    int coi=0;

    const char* keywords[] = { "src", "dst", "coi", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:insertChannel", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_coi) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_coi, coi, ArgInfo("coi", 0)))
    {
        ERRWRAP2_NAPI(info, cv::insertChannel(src, dst, coi));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "insertChannel");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_integral(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_sum = NULL;
    Mat sum;
    Napi::Value* jsobj_sdepth = NULL;
    int sdepth=-1;

    const char* keywords[] = { "src", "sum", "sdepth", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OO:integral", (char**)keywords, &jsobj_src, &jsobj_sum, &jsobj_sdepth) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_sum, sum, ArgInfo("sum", 1)) &&
        jsopencv_to_safe(jsobj_sdepth, sdepth, ArgInfo("sdepth", 0)))
    {
        ERRWRAP2_NAPI(info, cv::integral(src, sum, sdepth));
        return jsopencv_from(info, sum);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_sum = NULL;
    UMat sum;
    Napi::Value* jsobj_sdepth = NULL;
    int sdepth=-1;

    const char* keywords[] = { "src", "sum", "sdepth", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OO:integral", (char**)keywords, &jsobj_src, &jsobj_sum, &jsobj_sdepth) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_sum, sum, ArgInfo("sum", 1)) &&
        jsopencv_to_safe(jsobj_sdepth, sdepth, ArgInfo("sdepth", 0)))
    {
        ERRWRAP2_NAPI(info, cv::integral(src, sum, sdepth));
        return jsopencv_from(info, sum);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "integral");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_integral2(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_sum = NULL;
    Mat sum;
    Napi::Value* jsobj_sqsum = NULL;
    Mat sqsum;
    Napi::Value* jsobj_sdepth = NULL;
    int sdepth=-1;
    Napi::Value* jsobj_sqdepth = NULL;
    int sqdepth=-1;

    const char* keywords[] = { "src", "sum", "sqsum", "sdepth", "sqdepth", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOOO:integral2", (char**)keywords, &jsobj_src, &jsobj_sum, &jsobj_sqsum, &jsobj_sdepth, &jsobj_sqdepth) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_sum, sum, ArgInfo("sum", 1)) &&
        jsopencv_to_safe(jsobj_sqsum, sqsum, ArgInfo("sqsum", 1)) &&
        jsopencv_to_safe(jsobj_sdepth, sdepth, ArgInfo("sdepth", 0)) &&
        jsopencv_to_safe(jsobj_sqdepth, sqdepth, ArgInfo("sqdepth", 0)))
    {
        ERRWRAP2_NAPI(info, cv::integral(src, sum, sqsum, sdepth, sqdepth));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, sum), jsopencv_from(info, sqsum));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_sum = NULL;
    UMat sum;
    Napi::Value* jsobj_sqsum = NULL;
    UMat sqsum;
    Napi::Value* jsobj_sdepth = NULL;
    int sdepth=-1;
    Napi::Value* jsobj_sqdepth = NULL;
    int sqdepth=-1;

    const char* keywords[] = { "src", "sum", "sqsum", "sdepth", "sqdepth", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOOO:integral2", (char**)keywords, &jsobj_src, &jsobj_sum, &jsobj_sqsum, &jsobj_sdepth, &jsobj_sqdepth) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_sum, sum, ArgInfo("sum", 1)) &&
        jsopencv_to_safe(jsobj_sqsum, sqsum, ArgInfo("sqsum", 1)) &&
        jsopencv_to_safe(jsobj_sdepth, sdepth, ArgInfo("sdepth", 0)) &&
        jsopencv_to_safe(jsobj_sqdepth, sqdepth, ArgInfo("sqdepth", 0)))
    {
        ERRWRAP2_NAPI(info, cv::integral(src, sum, sqsum, sdepth, sqdepth));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, sum), jsopencv_from(info, sqsum));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "integral2");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_integral3(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_sum = NULL;
    Mat sum;
    Napi::Value* jsobj_sqsum = NULL;
    Mat sqsum;
    Napi::Value* jsobj_tilted = NULL;
    Mat tilted;
    Napi::Value* jsobj_sdepth = NULL;
    int sdepth=-1;
    Napi::Value* jsobj_sqdepth = NULL;
    int sqdepth=-1;

    const char* keywords[] = { "src", "sum", "sqsum", "tilted", "sdepth", "sqdepth", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOOOO:integral3", (char**)keywords, &jsobj_src, &jsobj_sum, &jsobj_sqsum, &jsobj_tilted, &jsobj_sdepth, &jsobj_sqdepth) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_sum, sum, ArgInfo("sum", 1)) &&
        jsopencv_to_safe(jsobj_sqsum, sqsum, ArgInfo("sqsum", 1)) &&
        jsopencv_to_safe(jsobj_tilted, tilted, ArgInfo("tilted", 1)) &&
        jsopencv_to_safe(jsobj_sdepth, sdepth, ArgInfo("sdepth", 0)) &&
        jsopencv_to_safe(jsobj_sqdepth, sqdepth, ArgInfo("sqdepth", 0)))
    {
        ERRWRAP2_NAPI(info, cv::integral(src, sum, sqsum, tilted, sdepth, sqdepth));
        return Js_BuildValue(info, "(NNN)", jsopencv_from(info, sum), jsopencv_from(info, sqsum), jsopencv_from(info, tilted));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_sum = NULL;
    UMat sum;
    Napi::Value* jsobj_sqsum = NULL;
    UMat sqsum;
    Napi::Value* jsobj_tilted = NULL;
    UMat tilted;
    Napi::Value* jsobj_sdepth = NULL;
    int sdepth=-1;
    Napi::Value* jsobj_sqdepth = NULL;
    int sqdepth=-1;

    const char* keywords[] = { "src", "sum", "sqsum", "tilted", "sdepth", "sqdepth", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOOOO:integral3", (char**)keywords, &jsobj_src, &jsobj_sum, &jsobj_sqsum, &jsobj_tilted, &jsobj_sdepth, &jsobj_sqdepth) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_sum, sum, ArgInfo("sum", 1)) &&
        jsopencv_to_safe(jsobj_sqsum, sqsum, ArgInfo("sqsum", 1)) &&
        jsopencv_to_safe(jsobj_tilted, tilted, ArgInfo("tilted", 1)) &&
        jsopencv_to_safe(jsobj_sdepth, sdepth, ArgInfo("sdepth", 0)) &&
        jsopencv_to_safe(jsobj_sqdepth, sqdepth, ArgInfo("sqdepth", 0)))
    {
        ERRWRAP2_NAPI(info, cv::integral(src, sum, sqsum, tilted, sdepth, sqdepth));
        return Js_BuildValue(info, "(NNN)", jsopencv_from(info, sum), jsopencv_from(info, sqsum), jsopencv_from(info, tilted));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "integral3");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_intersectConvexConvex(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_p1 = NULL;
    Mat p1;
    Napi::Value* jsobj_p2 = NULL;
    Mat p2;
    Napi::Value* jsobj_p12 = NULL;
    Mat p12;
    Napi::Value* jsobj_handleNested = NULL;
    bool handleNested=true;
    float retval;

    const char* keywords[] = { "p1", "p2", "p12", "handleNested", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:intersectConvexConvex", (char**)keywords, &jsobj_p1, &jsobj_p2, &jsobj_p12, &jsobj_handleNested) &&
        jsopencv_to_safe(jsobj_p1, p1, ArgInfo("p1", 0)) &&
        jsopencv_to_safe(jsobj_p2, p2, ArgInfo("p2", 0)) &&
        jsopencv_to_safe(jsobj_p12, p12, ArgInfo("p12", 1)) &&
        jsopencv_to_safe(jsobj_handleNested, handleNested, ArgInfo("handleNested", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::intersectConvexConvex(p1, p2, p12, handleNested));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, p12));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_p1 = NULL;
    UMat p1;
    Napi::Value* jsobj_p2 = NULL;
    UMat p2;
    Napi::Value* jsobj_p12 = NULL;
    UMat p12;
    Napi::Value* jsobj_handleNested = NULL;
    bool handleNested=true;
    float retval;

    const char* keywords[] = { "p1", "p2", "p12", "handleNested", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:intersectConvexConvex", (char**)keywords, &jsobj_p1, &jsobj_p2, &jsobj_p12, &jsobj_handleNested) &&
        jsopencv_to_safe(jsobj_p1, p1, ArgInfo("p1", 0)) &&
        jsopencv_to_safe(jsobj_p2, p2, ArgInfo("p2", 0)) &&
        jsopencv_to_safe(jsobj_p12, p12, ArgInfo("p12", 1)) &&
        jsopencv_to_safe(jsobj_handleNested, handleNested, ArgInfo("handleNested", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::intersectConvexConvex(p1, p2, p12, handleNested));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, p12));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "intersectConvexConvex");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_invert(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_flags = NULL;
    int flags=DECOMP_LU;
    double retval;

    const char* keywords[] = { "src", "dst", "flags", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OO:invert", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_flags) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::invert(src, dst, flags));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, dst));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_flags = NULL;
    int flags=DECOMP_LU;
    double retval;

    const char* keywords[] = { "src", "dst", "flags", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OO:invert", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_flags) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::invert(src, dst, flags));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, dst));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "invert");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_invertAffineTransform(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_M = NULL;
    Mat M;
    Napi::Value* jsobj_iM = NULL;
    Mat iM;

    const char* keywords[] = { "M", "iM", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:invertAffineTransform", (char**)keywords, &jsobj_M, &jsobj_iM) &&
        jsopencv_to_safe(jsobj_M, M, ArgInfo("M", 0)) &&
        jsopencv_to_safe(jsobj_iM, iM, ArgInfo("iM", 1)))
    {
        ERRWRAP2_NAPI(info, cv::invertAffineTransform(M, iM));
        return jsopencv_from(info, iM);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_M = NULL;
    UMat M;
    Napi::Value* jsobj_iM = NULL;
    UMat iM;

    const char* keywords[] = { "M", "iM", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:invertAffineTransform", (char**)keywords, &jsobj_M, &jsobj_iM) &&
        jsopencv_to_safe(jsobj_M, M, ArgInfo("M", 0)) &&
        jsopencv_to_safe(jsobj_iM, iM, ArgInfo("iM", 1)))
    {
        ERRWRAP2_NAPI(info, cv::invertAffineTransform(M, iM));
        return jsopencv_from(info, iM);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "invertAffineTransform");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_isContourConvex(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_contour = NULL;
    Mat contour;
    bool retval;

    const char* keywords[] = { "contour", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:isContourConvex", (char**)keywords, &jsobj_contour) &&
        jsopencv_to_safe(jsobj_contour, contour, ArgInfo("contour", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::isContourConvex(contour));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_contour = NULL;
    UMat contour;
    bool retval;

    const char* keywords[] = { "contour", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:isContourConvex", (char**)keywords, &jsobj_contour) &&
        jsopencv_to_safe(jsobj_contour, contour, ArgInfo("contour", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::isContourConvex(contour));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "isContourConvex");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_kmeans(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_data = NULL;
    Mat data;
    Napi::Value* jsobj_K = NULL;
    int K=0;
    Napi::Value* jsobj_bestLabels = NULL;
    Mat bestLabels;
    Napi::Value* jsobj_criteria = NULL;
    TermCriteria criteria;
    Napi::Value* jsobj_attempts = NULL;
    int attempts=0;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;
    Napi::Value* jsobj_centers = NULL;
    Mat centers;
    double retval;

    const char* keywords[] = { "data", "K", "bestLabels", "criteria", "attempts", "flags", "centers", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOO|O:kmeans", (char**)keywords, &jsobj_data, &jsobj_K, &jsobj_bestLabels, &jsobj_criteria, &jsobj_attempts, &jsobj_flags, &jsobj_centers) &&
        jsopencv_to_safe(jsobj_data, data, ArgInfo("data", 0)) &&
        jsopencv_to_safe(jsobj_K, K, ArgInfo("K", 0)) &&
        jsopencv_to_safe(jsobj_bestLabels, bestLabels, ArgInfo("bestLabels", 1)) &&
        jsopencv_to_safe(jsobj_criteria, criteria, ArgInfo("criteria", 0)) &&
        jsopencv_to_safe(jsobj_attempts, attempts, ArgInfo("attempts", 0)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_centers, centers, ArgInfo("centers", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::kmeans(data, K, bestLabels, criteria, attempts, flags, centers));
        return Js_BuildValue(info, "(NNN)", jsopencv_from(info, retval), jsopencv_from(info, bestLabels), jsopencv_from(info, centers));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_data = NULL;
    UMat data;
    Napi::Value* jsobj_K = NULL;
    int K=0;
    Napi::Value* jsobj_bestLabels = NULL;
    UMat bestLabels;
    Napi::Value* jsobj_criteria = NULL;
    TermCriteria criteria;
    Napi::Value* jsobj_attempts = NULL;
    int attempts=0;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;
    Napi::Value* jsobj_centers = NULL;
    UMat centers;
    double retval;

    const char* keywords[] = { "data", "K", "bestLabels", "criteria", "attempts", "flags", "centers", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOO|O:kmeans", (char**)keywords, &jsobj_data, &jsobj_K, &jsobj_bestLabels, &jsobj_criteria, &jsobj_attempts, &jsobj_flags, &jsobj_centers) &&
        jsopencv_to_safe(jsobj_data, data, ArgInfo("data", 0)) &&
        jsopencv_to_safe(jsobj_K, K, ArgInfo("K", 0)) &&
        jsopencv_to_safe(jsobj_bestLabels, bestLabels, ArgInfo("bestLabels", 1)) &&
        jsopencv_to_safe(jsobj_criteria, criteria, ArgInfo("criteria", 0)) &&
        jsopencv_to_safe(jsobj_attempts, attempts, ArgInfo("attempts", 0)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_centers, centers, ArgInfo("centers", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::kmeans(data, K, bestLabels, criteria, attempts, flags, centers));
        return Js_BuildValue(info, "(NNN)", jsopencv_from(info, retval), jsopencv_from(info, bestLabels), jsopencv_from(info, centers));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "kmeans");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_line(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_img = NULL;
    Mat img;
    Napi::Value* jsobj_pt1 = NULL;
    Point pt1;
    Napi::Value* jsobj_pt2 = NULL;
    Point pt2;
    Napi::Value* jsobj_color = NULL;
    Scalar color;
    Napi::Value* jsobj_thickness = NULL;
    int thickness=1;
    Napi::Value* jsobj_lineType = NULL;
    int lineType=LINE_8;
    Napi::Value* jsobj_shift = NULL;
    int shift=0;

    const char* keywords[] = { "img", "pt1", "pt2", "color", "thickness", "lineType", "shift", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOO:line", (char**)keywords, &jsobj_img, &jsobj_pt1, &jsobj_pt2, &jsobj_color, &jsobj_thickness, &jsobj_lineType, &jsobj_shift) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 1)) &&
        jsopencv_to_safe(jsobj_pt1, pt1, ArgInfo("pt1", 0)) &&
        jsopencv_to_safe(jsobj_pt2, pt2, ArgInfo("pt2", 0)) &&
        jsopencv_to_safe(jsobj_color, color, ArgInfo("color", 0)) &&
        jsopencv_to_safe(jsobj_thickness, thickness, ArgInfo("thickness", 0)) &&
        jsopencv_to_safe(jsobj_lineType, lineType, ArgInfo("lineType", 0)) &&
        jsopencv_to_safe(jsobj_shift, shift, ArgInfo("shift", 0)))
    {
        ERRWRAP2_NAPI(info, cv::line(img, pt1, pt2, color, thickness, lineType, shift));
        return jsopencv_from(info, img);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_img = NULL;
    UMat img;
    Napi::Value* jsobj_pt1 = NULL;
    Point pt1;
    Napi::Value* jsobj_pt2 = NULL;
    Point pt2;
    Napi::Value* jsobj_color = NULL;
    Scalar color;
    Napi::Value* jsobj_thickness = NULL;
    int thickness=1;
    Napi::Value* jsobj_lineType = NULL;
    int lineType=LINE_8;
    Napi::Value* jsobj_shift = NULL;
    int shift=0;

    const char* keywords[] = { "img", "pt1", "pt2", "color", "thickness", "lineType", "shift", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOO:line", (char**)keywords, &jsobj_img, &jsobj_pt1, &jsobj_pt2, &jsobj_color, &jsobj_thickness, &jsobj_lineType, &jsobj_shift) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 1)) &&
        jsopencv_to_safe(jsobj_pt1, pt1, ArgInfo("pt1", 0)) &&
        jsopencv_to_safe(jsobj_pt2, pt2, ArgInfo("pt2", 0)) &&
        jsopencv_to_safe(jsobj_color, color, ArgInfo("color", 0)) &&
        jsopencv_to_safe(jsobj_thickness, thickness, ArgInfo("thickness", 0)) &&
        jsopencv_to_safe(jsobj_lineType, lineType, ArgInfo("lineType", 0)) &&
        jsopencv_to_safe(jsobj_shift, shift, ArgInfo("shift", 0)))
    {
        ERRWRAP2_NAPI(info, cv::line(img, pt1, pt2, color, thickness, lineType, shift));
        return jsopencv_from(info, img);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "line");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_linearPolar(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_center = NULL;
    Point2f center;
    Napi::Value* jsobj_maxRadius = NULL;
    double maxRadius=0;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;

    const char* keywords[] = { "src", "center", "maxRadius", "flags", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|O:linearPolar", (char**)keywords, &jsobj_src, &jsobj_center, &jsobj_maxRadius, &jsobj_flags, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_center, center, ArgInfo("center", 0)) &&
        jsopencv_to_safe(jsobj_maxRadius, maxRadius, ArgInfo("maxRadius", 0)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, cv::linearPolar(src, dst, center, maxRadius, flags));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_center = NULL;
    Point2f center;
    Napi::Value* jsobj_maxRadius = NULL;
    double maxRadius=0;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;

    const char* keywords[] = { "src", "center", "maxRadius", "flags", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|O:linearPolar", (char**)keywords, &jsobj_src, &jsobj_center, &jsobj_maxRadius, &jsobj_flags, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_center, center, ArgInfo("center", 0)) &&
        jsopencv_to_safe(jsobj_maxRadius, maxRadius, ArgInfo("maxRadius", 0)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, cv::linearPolar(src, dst, center, maxRadius, flags));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "linearPolar");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_log(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;

    const char* keywords[] = { "src", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:log", (char**)keywords, &jsobj_src, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)))
    {
        ERRWRAP2_NAPI(info, cv::log(src, dst));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;

    const char* keywords[] = { "src", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:log", (char**)keywords, &jsobj_src, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)))
    {
        ERRWRAP2_NAPI(info, cv::log(src, dst));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "log");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_logPolar(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_center = NULL;
    Point2f center;
    Napi::Value* jsobj_M = NULL;
    double M=0;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;

    const char* keywords[] = { "src", "center", "M", "flags", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|O:logPolar", (char**)keywords, &jsobj_src, &jsobj_center, &jsobj_M, &jsobj_flags, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_center, center, ArgInfo("center", 0)) &&
        jsopencv_to_safe(jsobj_M, M, ArgInfo("M", 0)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, cv::logPolar(src, dst, center, M, flags));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_center = NULL;
    Point2f center;
    Napi::Value* jsobj_M = NULL;
    double M=0;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;

    const char* keywords[] = { "src", "center", "M", "flags", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|O:logPolar", (char**)keywords, &jsobj_src, &jsobj_center, &jsobj_M, &jsobj_flags, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_center, center, ArgInfo("center", 0)) &&
        jsopencv_to_safe(jsobj_M, M, ArgInfo("M", 0)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, cv::logPolar(src, dst, center, M, flags));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "logPolar");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_magnitude(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_x = NULL;
    Mat x;
    Napi::Value* jsobj_y = NULL;
    Mat y;
    Napi::Value* jsobj_magnitude = NULL;
    Mat magnitude;

    const char* keywords[] = { "x", "y", "magnitude", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:magnitude", (char**)keywords, &jsobj_x, &jsobj_y, &jsobj_magnitude) &&
        jsopencv_to_safe(jsobj_x, x, ArgInfo("x", 0)) &&
        jsopencv_to_safe(jsobj_y, y, ArgInfo("y", 0)) &&
        jsopencv_to_safe(jsobj_magnitude, magnitude, ArgInfo("magnitude", 1)))
    {
        ERRWRAP2_NAPI(info, cv::magnitude(x, y, magnitude));
        return jsopencv_from(info, magnitude);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_x = NULL;
    UMat x;
    Napi::Value* jsobj_y = NULL;
    UMat y;
    Napi::Value* jsobj_magnitude = NULL;
    UMat magnitude;

    const char* keywords[] = { "x", "y", "magnitude", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:magnitude", (char**)keywords, &jsobj_x, &jsobj_y, &jsobj_magnitude) &&
        jsopencv_to_safe(jsobj_x, x, ArgInfo("x", 0)) &&
        jsopencv_to_safe(jsobj_y, y, ArgInfo("y", 0)) &&
        jsopencv_to_safe(jsobj_magnitude, magnitude, ArgInfo("magnitude", 1)))
    {
        ERRWRAP2_NAPI(info, cv::magnitude(x, y, magnitude));
        return jsopencv_from(info, magnitude);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "magnitude");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_matMulDeriv(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_A = NULL;
    Mat A;
    Napi::Value* jsobj_B = NULL;
    Mat B;
    Napi::Value* jsobj_dABdA = NULL;
    Mat dABdA;
    Napi::Value* jsobj_dABdB = NULL;
    Mat dABdB;

    const char* keywords[] = { "A", "B", "dABdA", "dABdB", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:matMulDeriv", (char**)keywords, &jsobj_A, &jsobj_B, &jsobj_dABdA, &jsobj_dABdB) &&
        jsopencv_to_safe(jsobj_A, A, ArgInfo("A", 0)) &&
        jsopencv_to_safe(jsobj_B, B, ArgInfo("B", 0)) &&
        jsopencv_to_safe(jsobj_dABdA, dABdA, ArgInfo("dABdA", 1)) &&
        jsopencv_to_safe(jsobj_dABdB, dABdB, ArgInfo("dABdB", 1)))
    {
        ERRWRAP2_NAPI(info, cv::matMulDeriv(A, B, dABdA, dABdB));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, dABdA), jsopencv_from(info, dABdB));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_A = NULL;
    UMat A;
    Napi::Value* jsobj_B = NULL;
    UMat B;
    Napi::Value* jsobj_dABdA = NULL;
    UMat dABdA;
    Napi::Value* jsobj_dABdB = NULL;
    UMat dABdB;

    const char* keywords[] = { "A", "B", "dABdA", "dABdB", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:matMulDeriv", (char**)keywords, &jsobj_A, &jsobj_B, &jsobj_dABdA, &jsobj_dABdB) &&
        jsopencv_to_safe(jsobj_A, A, ArgInfo("A", 0)) &&
        jsopencv_to_safe(jsobj_B, B, ArgInfo("B", 0)) &&
        jsopencv_to_safe(jsobj_dABdA, dABdA, ArgInfo("dABdA", 1)) &&
        jsopencv_to_safe(jsobj_dABdB, dABdB, ArgInfo("dABdB", 1)))
    {
        ERRWRAP2_NAPI(info, cv::matMulDeriv(A, B, dABdA, dABdB));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, dABdA), jsopencv_from(info, dABdB));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "matMulDeriv");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_matchShapes(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_contour1 = NULL;
    Mat contour1;
    Napi::Value* jsobj_contour2 = NULL;
    Mat contour2;
    Napi::Value* jsobj_method = NULL;
    int method=0;
    Napi::Value* jsobj_parameter = NULL;
    double parameter=0;
    double retval;

    const char* keywords[] = { "contour1", "contour2", "method", "parameter", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO:matchShapes", (char**)keywords, &jsobj_contour1, &jsobj_contour2, &jsobj_method, &jsobj_parameter) &&
        jsopencv_to_safe(jsobj_contour1, contour1, ArgInfo("contour1", 0)) &&
        jsopencv_to_safe(jsobj_contour2, contour2, ArgInfo("contour2", 0)) &&
        jsopencv_to_safe(jsobj_method, method, ArgInfo("method", 0)) &&
        jsopencv_to_safe(jsobj_parameter, parameter, ArgInfo("parameter", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::matchShapes(contour1, contour2, method, parameter));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_contour1 = NULL;
    UMat contour1;
    Napi::Value* jsobj_contour2 = NULL;
    UMat contour2;
    Napi::Value* jsobj_method = NULL;
    int method=0;
    Napi::Value* jsobj_parameter = NULL;
    double parameter=0;
    double retval;

    const char* keywords[] = { "contour1", "contour2", "method", "parameter", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO:matchShapes", (char**)keywords, &jsobj_contour1, &jsobj_contour2, &jsobj_method, &jsobj_parameter) &&
        jsopencv_to_safe(jsobj_contour1, contour1, ArgInfo("contour1", 0)) &&
        jsopencv_to_safe(jsobj_contour2, contour2, ArgInfo("contour2", 0)) &&
        jsopencv_to_safe(jsobj_method, method, ArgInfo("method", 0)) &&
        jsopencv_to_safe(jsobj_parameter, parameter, ArgInfo("parameter", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::matchShapes(contour1, contour2, method, parameter));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "matchShapes");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_matchTemplate(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_image = NULL;
    Mat image;
    Napi::Value* jsobj_templ = NULL;
    Mat templ;
    Napi::Value* jsobj_result = NULL;
    Mat result;
    Napi::Value* jsobj_method = NULL;
    int method=0;
    Napi::Value* jsobj_mask = NULL;
    Mat mask;

    const char* keywords[] = { "image", "templ", "method", "result", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OO:matchTemplate", (char**)keywords, &jsobj_image, &jsobj_templ, &jsobj_method, &jsobj_result, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_templ, templ, ArgInfo("templ", 0)) &&
        jsopencv_to_safe(jsobj_result, result, ArgInfo("result", 1)) &&
        jsopencv_to_safe(jsobj_method, method, ArgInfo("method", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)))
    {
        ERRWRAP2_NAPI(info, cv::matchTemplate(image, templ, result, method, mask));
        return jsopencv_from(info, result);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_image = NULL;
    UMat image;
    Napi::Value* jsobj_templ = NULL;
    UMat templ;
    Napi::Value* jsobj_result = NULL;
    UMat result;
    Napi::Value* jsobj_method = NULL;
    int method=0;
    Napi::Value* jsobj_mask = NULL;
    UMat mask;

    const char* keywords[] = { "image", "templ", "method", "result", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OO:matchTemplate", (char**)keywords, &jsobj_image, &jsobj_templ, &jsobj_method, &jsobj_result, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_templ, templ, ArgInfo("templ", 0)) &&
        jsopencv_to_safe(jsobj_result, result, ArgInfo("result", 1)) &&
        jsopencv_to_safe(jsobj_method, method, ArgInfo("method", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)))
    {
        ERRWRAP2_NAPI(info, cv::matchTemplate(image, templ, result, method, mask));
        return jsopencv_from(info, result);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "matchTemplate");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_max(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src1 = NULL;
    Mat src1;
    Napi::Value* jsobj_src2 = NULL;
    Mat src2;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;

    const char* keywords[] = { "src1", "src2", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:max", (char**)keywords, &jsobj_src1, &jsobj_src2, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)))
    {
        ERRWRAP2_NAPI(info, cv::max(src1, src2, dst));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src1 = NULL;
    UMat src1;
    Napi::Value* jsobj_src2 = NULL;
    UMat src2;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;

    const char* keywords[] = { "src1", "src2", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:max", (char**)keywords, &jsobj_src1, &jsobj_src2, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)))
    {
        ERRWRAP2_NAPI(info, cv::max(src1, src2, dst));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "max");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_mean(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_mask = NULL;
    Mat mask;
    Scalar retval;

    const char* keywords[] = { "src", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:mean", (char**)keywords, &jsobj_src, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::mean(src, mask));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_mask = NULL;
    UMat mask;
    Scalar retval;

    const char* keywords[] = { "src", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:mean", (char**)keywords, &jsobj_src, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::mean(src, mask));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "mean");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_meanShift(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_probImage = NULL;
    Mat probImage;
    Napi::Value* jsobj_window = NULL;
    Rect window;
    Napi::Value* jsobj_criteria = NULL;
    TermCriteria criteria;
    int retval;

    const char* keywords[] = { "probImage", "window", "criteria", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:meanShift", (char**)keywords, &jsobj_probImage, &jsobj_window, &jsobj_criteria) &&
        jsopencv_to_safe(jsobj_probImage, probImage, ArgInfo("probImage", 0)) &&
        jsopencv_to_safe(jsobj_window, window, ArgInfo("window", 1)) &&
        jsopencv_to_safe(jsobj_criteria, criteria, ArgInfo("criteria", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::meanShift(probImage, window, criteria));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, window));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_probImage = NULL;
    UMat probImage;
    Napi::Value* jsobj_window = NULL;
    Rect window;
    Napi::Value* jsobj_criteria = NULL;
    TermCriteria criteria;
    int retval;

    const char* keywords[] = { "probImage", "window", "criteria", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:meanShift", (char**)keywords, &jsobj_probImage, &jsobj_window, &jsobj_criteria) &&
        jsopencv_to_safe(jsobj_probImage, probImage, ArgInfo("probImage", 0)) &&
        jsopencv_to_safe(jsobj_window, window, ArgInfo("window", 1)) &&
        jsopencv_to_safe(jsobj_criteria, criteria, ArgInfo("criteria", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::meanShift(probImage, window, criteria));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, window));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "meanShift");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_meanStdDev(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_mean = NULL;
    Mat mean;
    Napi::Value* jsobj_stddev = NULL;
    Mat stddev;
    Napi::Value* jsobj_mask = NULL;
    Mat mask;

    const char* keywords[] = { "src", "mean", "stddev", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOO:meanStdDev", (char**)keywords, &jsobj_src, &jsobj_mean, &jsobj_stddev, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_mean, mean, ArgInfo("mean", 1)) &&
        jsopencv_to_safe(jsobj_stddev, stddev, ArgInfo("stddev", 1)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)))
    {
        ERRWRAP2_NAPI(info, cv::meanStdDev(src, mean, stddev, mask));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, mean), jsopencv_from(info, stddev));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_mean = NULL;
    UMat mean;
    Napi::Value* jsobj_stddev = NULL;
    UMat stddev;
    Napi::Value* jsobj_mask = NULL;
    UMat mask;

    const char* keywords[] = { "src", "mean", "stddev", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOO:meanStdDev", (char**)keywords, &jsobj_src, &jsobj_mean, &jsobj_stddev, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_mean, mean, ArgInfo("mean", 1)) &&
        jsopencv_to_safe(jsobj_stddev, stddev, ArgInfo("stddev", 1)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)))
    {
        ERRWRAP2_NAPI(info, cv::meanStdDev(src, mean, stddev, mask));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, mean), jsopencv_from(info, stddev));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "meanStdDev");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_medianBlur(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_ksize = NULL;
    int ksize=0;

    const char* keywords[] = { "src", "ksize", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:medianBlur", (char**)keywords, &jsobj_src, &jsobj_ksize, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_ksize, ksize, ArgInfo("ksize", 0)))
    {
        ERRWRAP2_NAPI(info, cv::medianBlur(src, dst, ksize));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_ksize = NULL;
    int ksize=0;

    const char* keywords[] = { "src", "ksize", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:medianBlur", (char**)keywords, &jsobj_src, &jsobj_ksize, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_ksize, ksize, ArgInfo("ksize", 0)))
    {
        ERRWRAP2_NAPI(info, cv::medianBlur(src, dst, ksize));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "medianBlur");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_merge(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_mv = NULL;
    vector_Mat mv;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;

    const char* keywords[] = { "mv", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:merge", (char**)keywords, &jsobj_mv, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_mv, mv, ArgInfo("mv", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)))
    {
        ERRWRAP2_NAPI(info, cv::merge(mv, dst));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_mv = NULL;
    vector_UMat mv;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;

    const char* keywords[] = { "mv", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:merge", (char**)keywords, &jsobj_mv, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_mv, mv, ArgInfo("mv", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)))
    {
        ERRWRAP2_NAPI(info, cv::merge(mv, dst));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "merge");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_min(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src1 = NULL;
    Mat src1;
    Napi::Value* jsobj_src2 = NULL;
    Mat src2;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;

    const char* keywords[] = { "src1", "src2", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:min", (char**)keywords, &jsobj_src1, &jsobj_src2, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)))
    {
        ERRWRAP2_NAPI(info, cv::min(src1, src2, dst));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src1 = NULL;
    UMat src1;
    Napi::Value* jsobj_src2 = NULL;
    UMat src2;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;

    const char* keywords[] = { "src1", "src2", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:min", (char**)keywords, &jsobj_src1, &jsobj_src2, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)))
    {
        ERRWRAP2_NAPI(info, cv::min(src1, src2, dst));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "min");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_minAreaRect(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_points = NULL;
    Mat points;
    RotatedRect retval;

    const char* keywords[] = { "points", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:minAreaRect", (char**)keywords, &jsobj_points) &&
        jsopencv_to_safe(jsobj_points, points, ArgInfo("points", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::minAreaRect(points));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_points = NULL;
    UMat points;
    RotatedRect retval;

    const char* keywords[] = { "points", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:minAreaRect", (char**)keywords, &jsobj_points) &&
        jsopencv_to_safe(jsobj_points, points, ArgInfo("points", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::minAreaRect(points));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "minAreaRect");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_minEnclosingCircle(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_points = NULL;
    Mat points;
    Point2f center;
    float radius;

    const char* keywords[] = { "points", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:minEnclosingCircle", (char**)keywords, &jsobj_points) &&
        jsopencv_to_safe(jsobj_points, points, ArgInfo("points", 0)))
    {
        ERRWRAP2_NAPI(info, cv::minEnclosingCircle(points, center, radius));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, center), jsopencv_from(info, radius));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_points = NULL;
    UMat points;
    Point2f center;
    float radius;

    const char* keywords[] = { "points", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:minEnclosingCircle", (char**)keywords, &jsobj_points) &&
        jsopencv_to_safe(jsobj_points, points, ArgInfo("points", 0)))
    {
        ERRWRAP2_NAPI(info, cv::minEnclosingCircle(points, center, radius));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, center), jsopencv_from(info, radius));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "minEnclosingCircle");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_minEnclosingTriangle(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_points = NULL;
    Mat points;
    Napi::Value* jsobj_triangle = NULL;
    Mat triangle;
    double retval;

    const char* keywords[] = { "points", "triangle", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:minEnclosingTriangle", (char**)keywords, &jsobj_points, &jsobj_triangle) &&
        jsopencv_to_safe(jsobj_points, points, ArgInfo("points", 0)) &&
        jsopencv_to_safe(jsobj_triangle, triangle, ArgInfo("triangle", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::minEnclosingTriangle(points, triangle));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, triangle));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_points = NULL;
    UMat points;
    Napi::Value* jsobj_triangle = NULL;
    UMat triangle;
    double retval;

    const char* keywords[] = { "points", "triangle", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:minEnclosingTriangle", (char**)keywords, &jsobj_points, &jsobj_triangle) &&
        jsopencv_to_safe(jsobj_points, points, ArgInfo("points", 0)) &&
        jsopencv_to_safe(jsobj_triangle, triangle, ArgInfo("triangle", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::minEnclosingTriangle(points, triangle));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, triangle));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "minEnclosingTriangle");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_minMaxLoc(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    double minVal;
    double maxVal;
    Point minLoc;
    Point maxLoc;
    Napi::Value* jsobj_mask = NULL;
    Mat mask;

    const char* keywords[] = { "src", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:minMaxLoc", (char**)keywords, &jsobj_src, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)))
    {
        ERRWRAP2_NAPI(info, cv::minMaxLoc(src, &minVal, &maxVal, &minLoc, &maxLoc, mask));
        return Js_BuildValue(info, "(NNNN)", jsopencv_from(info, minVal), jsopencv_from(info, maxVal), jsopencv_from(info, minLoc), jsopencv_from(info, maxLoc));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    double minVal;
    double maxVal;
    Point minLoc;
    Point maxLoc;
    Napi::Value* jsobj_mask = NULL;
    UMat mask;

    const char* keywords[] = { "src", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:minMaxLoc", (char**)keywords, &jsobj_src, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)))
    {
        ERRWRAP2_NAPI(info, cv::minMaxLoc(src, &minVal, &maxVal, &minLoc, &maxLoc, mask));
        return Js_BuildValue(info, "(NNNN)", jsopencv_from(info, minVal), jsopencv_from(info, maxVal), jsopencv_from(info, minLoc), jsopencv_from(info, maxLoc));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "minMaxLoc");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_mixChannels(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    vector_Mat src;
    Napi::Value* jsobj_dst = NULL;
    vector_Mat dst;
    Napi::Value* jsobj_fromTo = NULL;
    vector_int fromTo;

    const char* keywords[] = { "src", "dst", "fromTo", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:mixChannels", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_fromTo) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_fromTo, fromTo, ArgInfo("fromTo", 0)))
    {
        ERRWRAP2_NAPI(info, cv::mixChannels(src, dst, fromTo));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    vector_UMat src;
    Napi::Value* jsobj_dst = NULL;
    vector_UMat dst;
    Napi::Value* jsobj_fromTo = NULL;
    vector_int fromTo;

    const char* keywords[] = { "src", "dst", "fromTo", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:mixChannels", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_fromTo) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_fromTo, fromTo, ArgInfo("fromTo", 0)))
    {
        ERRWRAP2_NAPI(info, cv::mixChannels(src, dst, fromTo));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "mixChannels");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_moments(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_array = NULL;
    Mat array;
    Napi::Value* jsobj_binaryImage = NULL;
    bool binaryImage=false;
    Moments retval;

    const char* keywords[] = { "array", "binaryImage", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:moments", (char**)keywords, &jsobj_array, &jsobj_binaryImage) &&
        jsopencv_to_safe(jsobj_array, array, ArgInfo("array", 0)) &&
        jsopencv_to_safe(jsobj_binaryImage, binaryImage, ArgInfo("binaryImage", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::moments(array, binaryImage));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_array = NULL;
    UMat array;
    Napi::Value* jsobj_binaryImage = NULL;
    bool binaryImage=false;
    Moments retval;

    const char* keywords[] = { "array", "binaryImage", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:moments", (char**)keywords, &jsobj_array, &jsobj_binaryImage) &&
        jsopencv_to_safe(jsobj_array, array, ArgInfo("array", 0)) &&
        jsopencv_to_safe(jsobj_binaryImage, binaryImage, ArgInfo("binaryImage", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::moments(array, binaryImage));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "moments");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_morphologyEx(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_op = NULL;
    int op=0;
    Napi::Value* jsobj_kernel = NULL;
    Mat kernel;
    Napi::Value* jsobj_anchor = NULL;
    Point anchor=Point(-1,-1);
    Napi::Value* jsobj_iterations = NULL;
    int iterations=1;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_CONSTANT;
    Napi::Value* jsobj_borderValue = NULL;
    Scalar borderValue=morphologyDefaultBorderValue();

    const char* keywords[] = { "src", "op", "kernel", "dst", "anchor", "iterations", "borderType", "borderValue", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOOOO:morphologyEx", (char**)keywords, &jsobj_src, &jsobj_op, &jsobj_kernel, &jsobj_dst, &jsobj_anchor, &jsobj_iterations, &jsobj_borderType, &jsobj_borderValue) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_op, op, ArgInfo("op", 0)) &&
        jsopencv_to_safe(jsobj_kernel, kernel, ArgInfo("kernel", 0)) &&
        jsopencv_to_safe(jsobj_anchor, anchor, ArgInfo("anchor", 0)) &&
        jsopencv_to_safe(jsobj_iterations, iterations, ArgInfo("iterations", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)) &&
        jsopencv_to_safe(jsobj_borderValue, borderValue, ArgInfo("borderValue", 0)))
    {
        ERRWRAP2_NAPI(info, cv::morphologyEx(src, dst, op, kernel, anchor, iterations, borderType, borderValue));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_op = NULL;
    int op=0;
    Napi::Value* jsobj_kernel = NULL;
    UMat kernel;
    Napi::Value* jsobj_anchor = NULL;
    Point anchor=Point(-1,-1);
    Napi::Value* jsobj_iterations = NULL;
    int iterations=1;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_CONSTANT;
    Napi::Value* jsobj_borderValue = NULL;
    Scalar borderValue=morphologyDefaultBorderValue();

    const char* keywords[] = { "src", "op", "kernel", "dst", "anchor", "iterations", "borderType", "borderValue", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOOOO:morphologyEx", (char**)keywords, &jsobj_src, &jsobj_op, &jsobj_kernel, &jsobj_dst, &jsobj_anchor, &jsobj_iterations, &jsobj_borderType, &jsobj_borderValue) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_op, op, ArgInfo("op", 0)) &&
        jsopencv_to_safe(jsobj_kernel, kernel, ArgInfo("kernel", 0)) &&
        jsopencv_to_safe(jsobj_anchor, anchor, ArgInfo("anchor", 0)) &&
        jsopencv_to_safe(jsobj_iterations, iterations, ArgInfo("iterations", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)) &&
        jsopencv_to_safe(jsobj_borderValue, borderValue, ArgInfo("borderValue", 0)))
    {
        ERRWRAP2_NAPI(info, cv::morphologyEx(src, dst, op, kernel, anchor, iterations, borderType, borderValue));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "morphologyEx");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_moveWindow(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_winname = NULL;
    String winname;
    Napi::Value* jsobj_x = NULL;
    int x=0;
    Napi::Value* jsobj_y = NULL;
    int y=0;

    const char* keywords[] = { "winname", "x", "y", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:moveWindow", (char**)keywords, &jsobj_winname, &jsobj_x, &jsobj_y) &&
        jsopencv_to_safe(jsobj_winname, winname, ArgInfo("winname", 0)) &&
        jsopencv_to_safe(jsobj_x, x, ArgInfo("x", 0)) &&
        jsopencv_to_safe(jsobj_y, y, ArgInfo("y", 0)))
    {
        ERRWRAP2_NAPI(info, cv::moveWindow(winname, x, y));
        return info.Env().Null();;
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_mulSpectrums(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_a = NULL;
    Mat a;
    Napi::Value* jsobj_b = NULL;
    Mat b;
    Napi::Value* jsobj_c = NULL;
    Mat c;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;
    Napi::Value* jsobj_conjB = NULL;
    bool conjB=false;

    const char* keywords[] = { "a", "b", "flags", "c", "conjB", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OO:mulSpectrums", (char**)keywords, &jsobj_a, &jsobj_b, &jsobj_flags, &jsobj_c, &jsobj_conjB) &&
        jsopencv_to_safe(jsobj_a, a, ArgInfo("a", 0)) &&
        jsopencv_to_safe(jsobj_b, b, ArgInfo("b", 0)) &&
        jsopencv_to_safe(jsobj_c, c, ArgInfo("c", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_conjB, conjB, ArgInfo("conjB", 0)))
    {
        ERRWRAP2_NAPI(info, cv::mulSpectrums(a, b, c, flags, conjB));
        return jsopencv_from(info, c);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_a = NULL;
    UMat a;
    Napi::Value* jsobj_b = NULL;
    UMat b;
    Napi::Value* jsobj_c = NULL;
    UMat c;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;
    Napi::Value* jsobj_conjB = NULL;
    bool conjB=false;

    const char* keywords[] = { "a", "b", "flags", "c", "conjB", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OO:mulSpectrums", (char**)keywords, &jsobj_a, &jsobj_b, &jsobj_flags, &jsobj_c, &jsobj_conjB) &&
        jsopencv_to_safe(jsobj_a, a, ArgInfo("a", 0)) &&
        jsopencv_to_safe(jsobj_b, b, ArgInfo("b", 0)) &&
        jsopencv_to_safe(jsobj_c, c, ArgInfo("c", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_conjB, conjB, ArgInfo("conjB", 0)))
    {
        ERRWRAP2_NAPI(info, cv::mulSpectrums(a, b, c, flags, conjB));
        return jsopencv_from(info, c);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "mulSpectrums");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_mulTransposed(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_aTa = NULL;
    bool aTa=0;
    Napi::Value* jsobj_delta = NULL;
    Mat delta;
    Napi::Value* jsobj_scale = NULL;
    double scale=1;
    Napi::Value* jsobj_dtype = NULL;
    int dtype=-1;

    const char* keywords[] = { "src", "aTa", "dst", "delta", "scale", "dtype", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOOO:mulTransposed", (char**)keywords, &jsobj_src, &jsobj_aTa, &jsobj_dst, &jsobj_delta, &jsobj_scale, &jsobj_dtype) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_aTa, aTa, ArgInfo("aTa", 0)) &&
        jsopencv_to_safe(jsobj_delta, delta, ArgInfo("delta", 0)) &&
        jsopencv_to_safe(jsobj_scale, scale, ArgInfo("scale", 0)) &&
        jsopencv_to_safe(jsobj_dtype, dtype, ArgInfo("dtype", 0)))
    {
        ERRWRAP2_NAPI(info, cv::mulTransposed(src, dst, aTa, delta, scale, dtype));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_aTa = NULL;
    bool aTa=0;
    Napi::Value* jsobj_delta = NULL;
    UMat delta;
    Napi::Value* jsobj_scale = NULL;
    double scale=1;
    Napi::Value* jsobj_dtype = NULL;
    int dtype=-1;

    const char* keywords[] = { "src", "aTa", "dst", "delta", "scale", "dtype", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOOO:mulTransposed", (char**)keywords, &jsobj_src, &jsobj_aTa, &jsobj_dst, &jsobj_delta, &jsobj_scale, &jsobj_dtype) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_aTa, aTa, ArgInfo("aTa", 0)) &&
        jsopencv_to_safe(jsobj_delta, delta, ArgInfo("delta", 0)) &&
        jsopencv_to_safe(jsobj_scale, scale, ArgInfo("scale", 0)) &&
        jsopencv_to_safe(jsobj_dtype, dtype, ArgInfo("dtype", 0)))
    {
        ERRWRAP2_NAPI(info, cv::mulTransposed(src, dst, aTa, delta, scale, dtype));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "mulTransposed");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_multiply(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src1 = NULL;
    Mat src1;
    Napi::Value* jsobj_src2 = NULL;
    Mat src2;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_scale = NULL;
    double scale=1;
    Napi::Value* jsobj_dtype = NULL;
    int dtype=-1;

    const char* keywords[] = { "src1", "src2", "dst", "scale", "dtype", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOO:multiply", (char**)keywords, &jsobj_src1, &jsobj_src2, &jsobj_dst, &jsobj_scale, &jsobj_dtype) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_scale, scale, ArgInfo("scale", 0)) &&
        jsopencv_to_safe(jsobj_dtype, dtype, ArgInfo("dtype", 0)))
    {
        ERRWRAP2_NAPI(info, cv::multiply(src1, src2, dst, scale, dtype));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src1 = NULL;
    UMat src1;
    Napi::Value* jsobj_src2 = NULL;
    UMat src2;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_scale = NULL;
    double scale=1;
    Napi::Value* jsobj_dtype = NULL;
    int dtype=-1;

    const char* keywords[] = { "src1", "src2", "dst", "scale", "dtype", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOO:multiply", (char**)keywords, &jsobj_src1, &jsobj_src2, &jsobj_dst, &jsobj_scale, &jsobj_dtype) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_scale, scale, ArgInfo("scale", 0)) &&
        jsopencv_to_safe(jsobj_dtype, dtype, ArgInfo("dtype", 0)))
    {
        ERRWRAP2_NAPI(info, cv::multiply(src1, src2, dst, scale, dtype));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "multiply");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_namedWindow(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_winname = NULL;
    String winname;
    Napi::Value* jsobj_flags = NULL;
    int flags=WINDOW_AUTOSIZE;

    const char* keywords[] = { "winname", "flags", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:namedWindow", (char**)keywords, &jsobj_winname, &jsobj_flags) &&
        jsopencv_to_safe(jsobj_winname, winname, ArgInfo("winname", 0)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, cv::namedWindow(winname, flags));
        return info.Env().Null();;
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_norm(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(4);

    {
    Napi::Value* jsobj_src1 = NULL;
    Mat src1;
    Napi::Value* jsobj_normType = NULL;
    int normType=NORM_L2;
    Napi::Value* jsobj_mask = NULL;
    Mat mask;
    double retval;

    const char* keywords[] = { "src1", "normType", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OO:norm", (char**)keywords, &jsobj_src1, &jsobj_normType, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_normType, normType, ArgInfo("normType", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::norm(src1, normType, mask));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src1 = NULL;
    UMat src1;
    Napi::Value* jsobj_normType = NULL;
    int normType=NORM_L2;
    Napi::Value* jsobj_mask = NULL;
    UMat mask;
    double retval;

    const char* keywords[] = { "src1", "normType", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OO:norm", (char**)keywords, &jsobj_src1, &jsobj_normType, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_normType, normType, ArgInfo("normType", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::norm(src1, normType, mask));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src1 = NULL;
    Mat src1;
    Napi::Value* jsobj_src2 = NULL;
    Mat src2;
    Napi::Value* jsobj_normType = NULL;
    int normType=NORM_L2;
    Napi::Value* jsobj_mask = NULL;
    Mat mask;
    double retval;

    const char* keywords[] = { "src1", "src2", "normType", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:norm", (char**)keywords, &jsobj_src1, &jsobj_src2, &jsobj_normType, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_normType, normType, ArgInfo("normType", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::norm(src1, src2, normType, mask));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src1 = NULL;
    UMat src1;
    Napi::Value* jsobj_src2 = NULL;
    UMat src2;
    Napi::Value* jsobj_normType = NULL;
    int normType=NORM_L2;
    Napi::Value* jsobj_mask = NULL;
    UMat mask;
    double retval;

    const char* keywords[] = { "src1", "src2", "normType", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:norm", (char**)keywords, &jsobj_src1, &jsobj_src2, &jsobj_normType, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_normType, normType, ArgInfo("normType", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::norm(src1, src2, normType, mask));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "norm");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_normalize(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_alpha = NULL;
    double alpha=1;
    Napi::Value* jsobj_beta = NULL;
    double beta=0;
    Napi::Value* jsobj_norm_type = NULL;
    int norm_type=NORM_L2;
    Napi::Value* jsobj_dtype = NULL;
    int dtype=-1;
    Napi::Value* jsobj_mask = NULL;
    Mat mask;

    const char* keywords[] = { "src", "dst", "alpha", "beta", "norm_type", "dtype", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOOOO:normalize", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_alpha, &jsobj_beta, &jsobj_norm_type, &jsobj_dtype, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_alpha, alpha, ArgInfo("alpha", 0)) &&
        jsopencv_to_safe(jsobj_beta, beta, ArgInfo("beta", 0)) &&
        jsopencv_to_safe(jsobj_norm_type, norm_type, ArgInfo("norm_type", 0)) &&
        jsopencv_to_safe(jsobj_dtype, dtype, ArgInfo("dtype", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)))
    {
        ERRWRAP2_NAPI(info, cv::normalize(src, dst, alpha, beta, norm_type, dtype, mask));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_alpha = NULL;
    double alpha=1;
    Napi::Value* jsobj_beta = NULL;
    double beta=0;
    Napi::Value* jsobj_norm_type = NULL;
    int norm_type=NORM_L2;
    Napi::Value* jsobj_dtype = NULL;
    int dtype=-1;
    Napi::Value* jsobj_mask = NULL;
    UMat mask;

    const char* keywords[] = { "src", "dst", "alpha", "beta", "norm_type", "dtype", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOOOO:normalize", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_alpha, &jsobj_beta, &jsobj_norm_type, &jsobj_dtype, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_alpha, alpha, ArgInfo("alpha", 0)) &&
        jsopencv_to_safe(jsobj_beta, beta, ArgInfo("beta", 0)) &&
        jsopencv_to_safe(jsobj_norm_type, norm_type, ArgInfo("norm_type", 0)) &&
        jsopencv_to_safe(jsobj_dtype, dtype, ArgInfo("dtype", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)))
    {
        ERRWRAP2_NAPI(info, cv::normalize(src, dst, alpha, beta, norm_type, dtype, mask));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "normalize");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_patchNaNs(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_a = NULL;
    Mat a;
    Napi::Value* jsobj_val = NULL;
    double val=0;

    const char* keywords[] = { "a", "val", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:patchNaNs", (char**)keywords, &jsobj_a, &jsobj_val) &&
        jsopencv_to_safe(jsobj_a, a, ArgInfo("a", 1)) &&
        jsopencv_to_safe(jsobj_val, val, ArgInfo("val", 0)))
    {
        ERRWRAP2_NAPI(info, cv::patchNaNs(a, val));
        return jsopencv_from(info, a);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_a = NULL;
    UMat a;
    Napi::Value* jsobj_val = NULL;
    double val=0;

    const char* keywords[] = { "a", "val", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:patchNaNs", (char**)keywords, &jsobj_a, &jsobj_val) &&
        jsopencv_to_safe(jsobj_a, a, ArgInfo("a", 1)) &&
        jsopencv_to_safe(jsobj_val, val, ArgInfo("val", 0)))
    {
        ERRWRAP2_NAPI(info, cv::patchNaNs(a, val));
        return jsopencv_from(info, a);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "patchNaNs");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_pencilSketch(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst1 = NULL;
    Mat dst1;
    Napi::Value* jsobj_dst2 = NULL;
    Mat dst2;
    Napi::Value* jsobj_sigma_s = NULL;
    float sigma_s=60;
    Napi::Value* jsobj_sigma_r = NULL;
    float sigma_r=0.07f;
    Napi::Value* jsobj_shade_factor = NULL;
    float shade_factor=0.02f;

    const char* keywords[] = { "src", "dst1", "dst2", "sigma_s", "sigma_r", "shade_factor", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOOOO:pencilSketch", (char**)keywords, &jsobj_src, &jsobj_dst1, &jsobj_dst2, &jsobj_sigma_s, &jsobj_sigma_r, &jsobj_shade_factor) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst1, dst1, ArgInfo("dst1", 1)) &&
        jsopencv_to_safe(jsobj_dst2, dst2, ArgInfo("dst2", 1)) &&
        jsopencv_to_safe(jsobj_sigma_s, sigma_s, ArgInfo("sigma_s", 0)) &&
        jsopencv_to_safe(jsobj_sigma_r, sigma_r, ArgInfo("sigma_r", 0)) &&
        jsopencv_to_safe(jsobj_shade_factor, shade_factor, ArgInfo("shade_factor", 0)))
    {
        ERRWRAP2_NAPI(info, cv::pencilSketch(src, dst1, dst2, sigma_s, sigma_r, shade_factor));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, dst1), jsopencv_from(info, dst2));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst1 = NULL;
    UMat dst1;
    Napi::Value* jsobj_dst2 = NULL;
    UMat dst2;
    Napi::Value* jsobj_sigma_s = NULL;
    float sigma_s=60;
    Napi::Value* jsobj_sigma_r = NULL;
    float sigma_r=0.07f;
    Napi::Value* jsobj_shade_factor = NULL;
    float shade_factor=0.02f;

    const char* keywords[] = { "src", "dst1", "dst2", "sigma_s", "sigma_r", "shade_factor", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOOOO:pencilSketch", (char**)keywords, &jsobj_src, &jsobj_dst1, &jsobj_dst2, &jsobj_sigma_s, &jsobj_sigma_r, &jsobj_shade_factor) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst1, dst1, ArgInfo("dst1", 1)) &&
        jsopencv_to_safe(jsobj_dst2, dst2, ArgInfo("dst2", 1)) &&
        jsopencv_to_safe(jsobj_sigma_s, sigma_s, ArgInfo("sigma_s", 0)) &&
        jsopencv_to_safe(jsobj_sigma_r, sigma_r, ArgInfo("sigma_r", 0)) &&
        jsopencv_to_safe(jsobj_shade_factor, shade_factor, ArgInfo("shade_factor", 0)))
    {
        ERRWRAP2_NAPI(info, cv::pencilSketch(src, dst1, dst2, sigma_s, sigma_r, shade_factor));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, dst1), jsopencv_from(info, dst2));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "pencilSketch");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_perspectiveTransform(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_m = NULL;
    Mat m;

    const char* keywords[] = { "src", "m", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:perspectiveTransform", (char**)keywords, &jsobj_src, &jsobj_m, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_m, m, ArgInfo("m", 0)))
    {
        ERRWRAP2_NAPI(info, cv::perspectiveTransform(src, dst, m));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_m = NULL;
    UMat m;

    const char* keywords[] = { "src", "m", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:perspectiveTransform", (char**)keywords, &jsobj_src, &jsobj_m, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_m, m, ArgInfo("m", 0)))
    {
        ERRWRAP2_NAPI(info, cv::perspectiveTransform(src, dst, m));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "perspectiveTransform");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_phase(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_x = NULL;
    Mat x;
    Napi::Value* jsobj_y = NULL;
    Mat y;
    Napi::Value* jsobj_angle = NULL;
    Mat angle;
    Napi::Value* jsobj_angleInDegrees = NULL;
    bool angleInDegrees=false;

    const char* keywords[] = { "x", "y", "angle", "angleInDegrees", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:phase", (char**)keywords, &jsobj_x, &jsobj_y, &jsobj_angle, &jsobj_angleInDegrees) &&
        jsopencv_to_safe(jsobj_x, x, ArgInfo("x", 0)) &&
        jsopencv_to_safe(jsobj_y, y, ArgInfo("y", 0)) &&
        jsopencv_to_safe(jsobj_angle, angle, ArgInfo("angle", 1)) &&
        jsopencv_to_safe(jsobj_angleInDegrees, angleInDegrees, ArgInfo("angleInDegrees", 0)))
    {
        ERRWRAP2_NAPI(info, cv::phase(x, y, angle, angleInDegrees));
        return jsopencv_from(info, angle);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_x = NULL;
    UMat x;
    Napi::Value* jsobj_y = NULL;
    UMat y;
    Napi::Value* jsobj_angle = NULL;
    UMat angle;
    Napi::Value* jsobj_angleInDegrees = NULL;
    bool angleInDegrees=false;

    const char* keywords[] = { "x", "y", "angle", "angleInDegrees", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:phase", (char**)keywords, &jsobj_x, &jsobj_y, &jsobj_angle, &jsobj_angleInDegrees) &&
        jsopencv_to_safe(jsobj_x, x, ArgInfo("x", 0)) &&
        jsopencv_to_safe(jsobj_y, y, ArgInfo("y", 0)) &&
        jsopencv_to_safe(jsobj_angle, angle, ArgInfo("angle", 1)) &&
        jsopencv_to_safe(jsobj_angleInDegrees, angleInDegrees, ArgInfo("angleInDegrees", 0)))
    {
        ERRWRAP2_NAPI(info, cv::phase(x, y, angle, angleInDegrees));
        return jsopencv_from(info, angle);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "phase");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_phaseCorrelate(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src1 = NULL;
    Mat src1;
    Napi::Value* jsobj_src2 = NULL;
    Mat src2;
    Napi::Value* jsobj_window = NULL;
    Mat window;
    double response;
    Point2d retval;

    const char* keywords[] = { "src1", "src2", "window", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:phaseCorrelate", (char**)keywords, &jsobj_src1, &jsobj_src2, &jsobj_window) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_window, window, ArgInfo("window", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::phaseCorrelate(src1, src2, window, &response));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, response));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src1 = NULL;
    UMat src1;
    Napi::Value* jsobj_src2 = NULL;
    UMat src2;
    Napi::Value* jsobj_window = NULL;
    UMat window;
    double response;
    Point2d retval;

    const char* keywords[] = { "src1", "src2", "window", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:phaseCorrelate", (char**)keywords, &jsobj_src1, &jsobj_src2, &jsobj_window) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_window, window, ArgInfo("window", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::phaseCorrelate(src1, src2, window, &response));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, response));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "phaseCorrelate");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_pointPolygonTest(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_contour = NULL;
    Mat contour;
    Napi::Value* jsobj_pt = NULL;
    Point2f pt;
    Napi::Value* jsobj_measureDist = NULL;
    bool measureDist=0;
    double retval;

    const char* keywords[] = { "contour", "pt", "measureDist", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:pointPolygonTest", (char**)keywords, &jsobj_contour, &jsobj_pt, &jsobj_measureDist) &&
        jsopencv_to_safe(jsobj_contour, contour, ArgInfo("contour", 0)) &&
        jsopencv_to_safe(jsobj_pt, pt, ArgInfo("pt", 0)) &&
        jsopencv_to_safe(jsobj_measureDist, measureDist, ArgInfo("measureDist", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::pointPolygonTest(contour, pt, measureDist));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_contour = NULL;
    UMat contour;
    Napi::Value* jsobj_pt = NULL;
    Point2f pt;
    Napi::Value* jsobj_measureDist = NULL;
    bool measureDist=0;
    double retval;

    const char* keywords[] = { "contour", "pt", "measureDist", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:pointPolygonTest", (char**)keywords, &jsobj_contour, &jsobj_pt, &jsobj_measureDist) &&
        jsopencv_to_safe(jsobj_contour, contour, ArgInfo("contour", 0)) &&
        jsopencv_to_safe(jsobj_pt, pt, ArgInfo("pt", 0)) &&
        jsopencv_to_safe(jsobj_measureDist, measureDist, ArgInfo("measureDist", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::pointPolygonTest(contour, pt, measureDist));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "pointPolygonTest");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_polarToCart(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_magnitude = NULL;
    Mat magnitude;
    Napi::Value* jsobj_angle = NULL;
    Mat angle;
    Napi::Value* jsobj_x = NULL;
    Mat x;
    Napi::Value* jsobj_y = NULL;
    Mat y;
    Napi::Value* jsobj_angleInDegrees = NULL;
    bool angleInDegrees=false;

    const char* keywords[] = { "magnitude", "angle", "x", "y", "angleInDegrees", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOO:polarToCart", (char**)keywords, &jsobj_magnitude, &jsobj_angle, &jsobj_x, &jsobj_y, &jsobj_angleInDegrees) &&
        jsopencv_to_safe(jsobj_magnitude, magnitude, ArgInfo("magnitude", 0)) &&
        jsopencv_to_safe(jsobj_angle, angle, ArgInfo("angle", 0)) &&
        jsopencv_to_safe(jsobj_x, x, ArgInfo("x", 1)) &&
        jsopencv_to_safe(jsobj_y, y, ArgInfo("y", 1)) &&
        jsopencv_to_safe(jsobj_angleInDegrees, angleInDegrees, ArgInfo("angleInDegrees", 0)))
    {
        ERRWRAP2_NAPI(info, cv::polarToCart(magnitude, angle, x, y, angleInDegrees));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, x), jsopencv_from(info, y));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_magnitude = NULL;
    UMat magnitude;
    Napi::Value* jsobj_angle = NULL;
    UMat angle;
    Napi::Value* jsobj_x = NULL;
    UMat x;
    Napi::Value* jsobj_y = NULL;
    UMat y;
    Napi::Value* jsobj_angleInDegrees = NULL;
    bool angleInDegrees=false;

    const char* keywords[] = { "magnitude", "angle", "x", "y", "angleInDegrees", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOO:polarToCart", (char**)keywords, &jsobj_magnitude, &jsobj_angle, &jsobj_x, &jsobj_y, &jsobj_angleInDegrees) &&
        jsopencv_to_safe(jsobj_magnitude, magnitude, ArgInfo("magnitude", 0)) &&
        jsopencv_to_safe(jsobj_angle, angle, ArgInfo("angle", 0)) &&
        jsopencv_to_safe(jsobj_x, x, ArgInfo("x", 1)) &&
        jsopencv_to_safe(jsobj_y, y, ArgInfo("y", 1)) &&
        jsopencv_to_safe(jsobj_angleInDegrees, angleInDegrees, ArgInfo("angleInDegrees", 0)))
    {
        ERRWRAP2_NAPI(info, cv::polarToCart(magnitude, angle, x, y, angleInDegrees));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, x), jsopencv_from(info, y));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "polarToCart");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_pollKey(const Napi::CallbackInfo &info)
{
    using namespace cv;

    int retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::pollKey());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_polylines(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_img = NULL;
    Mat img;
    Napi::Value* jsobj_pts = NULL;
    vector_Mat pts;
    Napi::Value* jsobj_isClosed = NULL;
    bool isClosed=0;
    Napi::Value* jsobj_color = NULL;
    Scalar color;
    Napi::Value* jsobj_thickness = NULL;
    int thickness=1;
    Napi::Value* jsobj_lineType = NULL;
    int lineType=LINE_8;
    Napi::Value* jsobj_shift = NULL;
    int shift=0;

    const char* keywords[] = { "img", "pts", "isClosed", "color", "thickness", "lineType", "shift", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOO:polylines", (char**)keywords, &jsobj_img, &jsobj_pts, &jsobj_isClosed, &jsobj_color, &jsobj_thickness, &jsobj_lineType, &jsobj_shift) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 1)) &&
        jsopencv_to_safe(jsobj_pts, pts, ArgInfo("pts", 0)) &&
        jsopencv_to_safe(jsobj_isClosed, isClosed, ArgInfo("isClosed", 0)) &&
        jsopencv_to_safe(jsobj_color, color, ArgInfo("color", 0)) &&
        jsopencv_to_safe(jsobj_thickness, thickness, ArgInfo("thickness", 0)) &&
        jsopencv_to_safe(jsobj_lineType, lineType, ArgInfo("lineType", 0)) &&
        jsopencv_to_safe(jsobj_shift, shift, ArgInfo("shift", 0)))
    {
        ERRWRAP2_NAPI(info, cv::polylines(img, pts, isClosed, color, thickness, lineType, shift));
        return jsopencv_from(info, img);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_img = NULL;
    UMat img;
    Napi::Value* jsobj_pts = NULL;
    vector_UMat pts;
    Napi::Value* jsobj_isClosed = NULL;
    bool isClosed=0;
    Napi::Value* jsobj_color = NULL;
    Scalar color;
    Napi::Value* jsobj_thickness = NULL;
    int thickness=1;
    Napi::Value* jsobj_lineType = NULL;
    int lineType=LINE_8;
    Napi::Value* jsobj_shift = NULL;
    int shift=0;

    const char* keywords[] = { "img", "pts", "isClosed", "color", "thickness", "lineType", "shift", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOO:polylines", (char**)keywords, &jsobj_img, &jsobj_pts, &jsobj_isClosed, &jsobj_color, &jsobj_thickness, &jsobj_lineType, &jsobj_shift) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 1)) &&
        jsopencv_to_safe(jsobj_pts, pts, ArgInfo("pts", 0)) &&
        jsopencv_to_safe(jsobj_isClosed, isClosed, ArgInfo("isClosed", 0)) &&
        jsopencv_to_safe(jsobj_color, color, ArgInfo("color", 0)) &&
        jsopencv_to_safe(jsobj_thickness, thickness, ArgInfo("thickness", 0)) &&
        jsopencv_to_safe(jsobj_lineType, lineType, ArgInfo("lineType", 0)) &&
        jsopencv_to_safe(jsobj_shift, shift, ArgInfo("shift", 0)))
    {
        ERRWRAP2_NAPI(info, cv::polylines(img, pts, isClosed, color, thickness, lineType, shift));
        return jsopencv_from(info, img);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "polylines");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_pow(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_power = NULL;
    double power=0;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;

    const char* keywords[] = { "src", "power", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:pow", (char**)keywords, &jsobj_src, &jsobj_power, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_power, power, ArgInfo("power", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)))
    {
        ERRWRAP2_NAPI(info, cv::pow(src, power, dst));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_power = NULL;
    double power=0;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;

    const char* keywords[] = { "src", "power", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:pow", (char**)keywords, &jsobj_src, &jsobj_power, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_power, power, ArgInfo("power", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)))
    {
        ERRWRAP2_NAPI(info, cv::pow(src, power, dst));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "pow");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_preCornerDetect(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_ksize = NULL;
    int ksize=0;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_DEFAULT;

    const char* keywords[] = { "src", "ksize", "dst", "borderType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:preCornerDetect", (char**)keywords, &jsobj_src, &jsobj_ksize, &jsobj_dst, &jsobj_borderType) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_ksize, ksize, ArgInfo("ksize", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)))
    {
        ERRWRAP2_NAPI(info, cv::preCornerDetect(src, dst, ksize, borderType));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_ksize = NULL;
    int ksize=0;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_DEFAULT;

    const char* keywords[] = { "src", "ksize", "dst", "borderType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:preCornerDetect", (char**)keywords, &jsobj_src, &jsobj_ksize, &jsobj_dst, &jsobj_borderType) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_ksize, ksize, ArgInfo("ksize", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)))
    {
        ERRWRAP2_NAPI(info, cv::preCornerDetect(src, dst, ksize, borderType));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "preCornerDetect");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_projectPoints(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_objectPoints = NULL;
    Mat objectPoints;
    Napi::Value* jsobj_rvec = NULL;
    Mat rvec;
    Napi::Value* jsobj_tvec = NULL;
    Mat tvec;
    Napi::Value* jsobj_cameraMatrix = NULL;
    Mat cameraMatrix;
    Napi::Value* jsobj_distCoeffs = NULL;
    Mat distCoeffs;
    Napi::Value* jsobj_imagePoints = NULL;
    Mat imagePoints;
    Napi::Value* jsobj_jacobian = NULL;
    Mat jacobian;
    Napi::Value* jsobj_aspectRatio = NULL;
    double aspectRatio=0;

    const char* keywords[] = { "objectPoints", "rvec", "tvec", "cameraMatrix", "distCoeffs", "imagePoints", "jacobian", "aspectRatio", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOO|OOO:projectPoints", (char**)keywords, &jsobj_objectPoints, &jsobj_rvec, &jsobj_tvec, &jsobj_cameraMatrix, &jsobj_distCoeffs, &jsobj_imagePoints, &jsobj_jacobian, &jsobj_aspectRatio) &&
        jsopencv_to_safe(jsobj_objectPoints, objectPoints, ArgInfo("objectPoints", 0)) &&
        jsopencv_to_safe(jsobj_rvec, rvec, ArgInfo("rvec", 0)) &&
        jsopencv_to_safe(jsobj_tvec, tvec, ArgInfo("tvec", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 0)) &&
        jsopencv_to_safe(jsobj_distCoeffs, distCoeffs, ArgInfo("distCoeffs", 0)) &&
        jsopencv_to_safe(jsobj_imagePoints, imagePoints, ArgInfo("imagePoints", 1)) &&
        jsopencv_to_safe(jsobj_jacobian, jacobian, ArgInfo("jacobian", 1)) &&
        jsopencv_to_safe(jsobj_aspectRatio, aspectRatio, ArgInfo("aspectRatio", 0)))
    {
        ERRWRAP2_NAPI(info, cv::projectPoints(objectPoints, rvec, tvec, cameraMatrix, distCoeffs, imagePoints, jacobian, aspectRatio));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, imagePoints), jsopencv_from(info, jacobian));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_objectPoints = NULL;
    UMat objectPoints;
    Napi::Value* jsobj_rvec = NULL;
    UMat rvec;
    Napi::Value* jsobj_tvec = NULL;
    UMat tvec;
    Napi::Value* jsobj_cameraMatrix = NULL;
    UMat cameraMatrix;
    Napi::Value* jsobj_distCoeffs = NULL;
    UMat distCoeffs;
    Napi::Value* jsobj_imagePoints = NULL;
    UMat imagePoints;
    Napi::Value* jsobj_jacobian = NULL;
    UMat jacobian;
    Napi::Value* jsobj_aspectRatio = NULL;
    double aspectRatio=0;

    const char* keywords[] = { "objectPoints", "rvec", "tvec", "cameraMatrix", "distCoeffs", "imagePoints", "jacobian", "aspectRatio", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOO|OOO:projectPoints", (char**)keywords, &jsobj_objectPoints, &jsobj_rvec, &jsobj_tvec, &jsobj_cameraMatrix, &jsobj_distCoeffs, &jsobj_imagePoints, &jsobj_jacobian, &jsobj_aspectRatio) &&
        jsopencv_to_safe(jsobj_objectPoints, objectPoints, ArgInfo("objectPoints", 0)) &&
        jsopencv_to_safe(jsobj_rvec, rvec, ArgInfo("rvec", 0)) &&
        jsopencv_to_safe(jsobj_tvec, tvec, ArgInfo("tvec", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 0)) &&
        jsopencv_to_safe(jsobj_distCoeffs, distCoeffs, ArgInfo("distCoeffs", 0)) &&
        jsopencv_to_safe(jsobj_imagePoints, imagePoints, ArgInfo("imagePoints", 1)) &&
        jsopencv_to_safe(jsobj_jacobian, jacobian, ArgInfo("jacobian", 1)) &&
        jsopencv_to_safe(jsobj_aspectRatio, aspectRatio, ArgInfo("aspectRatio", 0)))
    {
        ERRWRAP2_NAPI(info, cv::projectPoints(objectPoints, rvec, tvec, cameraMatrix, distCoeffs, imagePoints, jacobian, aspectRatio));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, imagePoints), jsopencv_from(info, jacobian));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "projectPoints");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_putText(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_img = NULL;
    Mat img;
    Napi::Value* jsobj_text = NULL;
    String text;
    Napi::Value* jsobj_org = NULL;
    Point org;
    Napi::Value* jsobj_fontFace = NULL;
    int fontFace=0;
    Napi::Value* jsobj_fontScale = NULL;
    double fontScale=0;
    Napi::Value* jsobj_color = NULL;
    Scalar color;
    Napi::Value* jsobj_thickness = NULL;
    int thickness=1;
    Napi::Value* jsobj_lineType = NULL;
    int lineType=LINE_8;
    Napi::Value* jsobj_bottomLeftOrigin = NULL;
    bool bottomLeftOrigin=false;

    const char* keywords[] = { "img", "text", "org", "fontFace", "fontScale", "color", "thickness", "lineType", "bottomLeftOrigin", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOO|OOO:putText", (char**)keywords, &jsobj_img, &jsobj_text, &jsobj_org, &jsobj_fontFace, &jsobj_fontScale, &jsobj_color, &jsobj_thickness, &jsobj_lineType, &jsobj_bottomLeftOrigin) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 1)) &&
        jsopencv_to_safe(jsobj_text, text, ArgInfo("text", 0)) &&
        jsopencv_to_safe(jsobj_org, org, ArgInfo("org", 0)) &&
        jsopencv_to_safe(jsobj_fontFace, fontFace, ArgInfo("fontFace", 0)) &&
        jsopencv_to_safe(jsobj_fontScale, fontScale, ArgInfo("fontScale", 0)) &&
        jsopencv_to_safe(jsobj_color, color, ArgInfo("color", 0)) &&
        jsopencv_to_safe(jsobj_thickness, thickness, ArgInfo("thickness", 0)) &&
        jsopencv_to_safe(jsobj_lineType, lineType, ArgInfo("lineType", 0)) &&
        jsopencv_to_safe(jsobj_bottomLeftOrigin, bottomLeftOrigin, ArgInfo("bottomLeftOrigin", 0)))
    {
        ERRWRAP2_NAPI(info, cv::putText(img, text, org, fontFace, fontScale, color, thickness, lineType, bottomLeftOrigin));
        return jsopencv_from(info, img);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_img = NULL;
    UMat img;
    Napi::Value* jsobj_text = NULL;
    String text;
    Napi::Value* jsobj_org = NULL;
    Point org;
    Napi::Value* jsobj_fontFace = NULL;
    int fontFace=0;
    Napi::Value* jsobj_fontScale = NULL;
    double fontScale=0;
    Napi::Value* jsobj_color = NULL;
    Scalar color;
    Napi::Value* jsobj_thickness = NULL;
    int thickness=1;
    Napi::Value* jsobj_lineType = NULL;
    int lineType=LINE_8;
    Napi::Value* jsobj_bottomLeftOrigin = NULL;
    bool bottomLeftOrigin=false;

    const char* keywords[] = { "img", "text", "org", "fontFace", "fontScale", "color", "thickness", "lineType", "bottomLeftOrigin", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOO|OOO:putText", (char**)keywords, &jsobj_img, &jsobj_text, &jsobj_org, &jsobj_fontFace, &jsobj_fontScale, &jsobj_color, &jsobj_thickness, &jsobj_lineType, &jsobj_bottomLeftOrigin) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 1)) &&
        jsopencv_to_safe(jsobj_text, text, ArgInfo("text", 0)) &&
        jsopencv_to_safe(jsobj_org, org, ArgInfo("org", 0)) &&
        jsopencv_to_safe(jsobj_fontFace, fontFace, ArgInfo("fontFace", 0)) &&
        jsopencv_to_safe(jsobj_fontScale, fontScale, ArgInfo("fontScale", 0)) &&
        jsopencv_to_safe(jsobj_color, color, ArgInfo("color", 0)) &&
        jsopencv_to_safe(jsobj_thickness, thickness, ArgInfo("thickness", 0)) &&
        jsopencv_to_safe(jsobj_lineType, lineType, ArgInfo("lineType", 0)) &&
        jsopencv_to_safe(jsobj_bottomLeftOrigin, bottomLeftOrigin, ArgInfo("bottomLeftOrigin", 0)))
    {
        ERRWRAP2_NAPI(info, cv::putText(img, text, org, fontFace, fontScale, color, thickness, lineType, bottomLeftOrigin));
        return jsopencv_from(info, img);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "putText");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_pyrDown(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_dstsize = NULL;
    Size dstsize;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_DEFAULT;

    const char* keywords[] = { "src", "dst", "dstsize", "borderType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOO:pyrDown", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_dstsize, &jsobj_borderType) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_dstsize, dstsize, ArgInfo("dstsize", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)))
    {
        ERRWRAP2_NAPI(info, cv::pyrDown(src, dst, dstsize, borderType));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_dstsize = NULL;
    Size dstsize;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_DEFAULT;

    const char* keywords[] = { "src", "dst", "dstsize", "borderType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOO:pyrDown", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_dstsize, &jsobj_borderType) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_dstsize, dstsize, ArgInfo("dstsize", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)))
    {
        ERRWRAP2_NAPI(info, cv::pyrDown(src, dst, dstsize, borderType));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "pyrDown");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_pyrMeanShiftFiltering(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_sp = NULL;
    double sp=0;
    Napi::Value* jsobj_sr = NULL;
    double sr=0;
    Napi::Value* jsobj_maxLevel = NULL;
    int maxLevel=1;
    Napi::Value* jsobj_termcrit = NULL;
    TermCriteria termcrit=TermCriteria(TermCriteria::MAX_ITER+TermCriteria::EPS,5,1);

    const char* keywords[] = { "src", "sp", "sr", "dst", "maxLevel", "termcrit", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOO:pyrMeanShiftFiltering", (char**)keywords, &jsobj_src, &jsobj_sp, &jsobj_sr, &jsobj_dst, &jsobj_maxLevel, &jsobj_termcrit) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_sp, sp, ArgInfo("sp", 0)) &&
        jsopencv_to_safe(jsobj_sr, sr, ArgInfo("sr", 0)) &&
        jsopencv_to_safe(jsobj_maxLevel, maxLevel, ArgInfo("maxLevel", 0)) &&
        jsopencv_to_safe(jsobj_termcrit, termcrit, ArgInfo("termcrit", 0)))
    {
        ERRWRAP2_NAPI(info, cv::pyrMeanShiftFiltering(src, dst, sp, sr, maxLevel, termcrit));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_sp = NULL;
    double sp=0;
    Napi::Value* jsobj_sr = NULL;
    double sr=0;
    Napi::Value* jsobj_maxLevel = NULL;
    int maxLevel=1;
    Napi::Value* jsobj_termcrit = NULL;
    TermCriteria termcrit=TermCriteria(TermCriteria::MAX_ITER+TermCriteria::EPS,5,1);

    const char* keywords[] = { "src", "sp", "sr", "dst", "maxLevel", "termcrit", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOO:pyrMeanShiftFiltering", (char**)keywords, &jsobj_src, &jsobj_sp, &jsobj_sr, &jsobj_dst, &jsobj_maxLevel, &jsobj_termcrit) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_sp, sp, ArgInfo("sp", 0)) &&
        jsopencv_to_safe(jsobj_sr, sr, ArgInfo("sr", 0)) &&
        jsopencv_to_safe(jsobj_maxLevel, maxLevel, ArgInfo("maxLevel", 0)) &&
        jsopencv_to_safe(jsobj_termcrit, termcrit, ArgInfo("termcrit", 0)))
    {
        ERRWRAP2_NAPI(info, cv::pyrMeanShiftFiltering(src, dst, sp, sr, maxLevel, termcrit));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "pyrMeanShiftFiltering");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_pyrUp(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_dstsize = NULL;
    Size dstsize;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_DEFAULT;

    const char* keywords[] = { "src", "dst", "dstsize", "borderType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOO:pyrUp", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_dstsize, &jsobj_borderType) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_dstsize, dstsize, ArgInfo("dstsize", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)))
    {
        ERRWRAP2_NAPI(info, cv::pyrUp(src, dst, dstsize, borderType));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_dstsize = NULL;
    Size dstsize;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_DEFAULT;

    const char* keywords[] = { "src", "dst", "dstsize", "borderType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOO:pyrUp", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_dstsize, &jsobj_borderType) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_dstsize, dstsize, ArgInfo("dstsize", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)))
    {
        ERRWRAP2_NAPI(info, cv::pyrUp(src, dst, dstsize, borderType));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "pyrUp");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_randShuffle(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_iterFactor = NULL;
    double iterFactor=1.;

    const char* keywords[] = { "dst", "iterFactor", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:randShuffle", (char**)keywords, &jsobj_dst, &jsobj_iterFactor) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_iterFactor, iterFactor, ArgInfo("iterFactor", 0)))
    {
        ERRWRAP2_NAPI(info, cv::randShuffle(dst, iterFactor, 0));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_iterFactor = NULL;
    double iterFactor=1.;

    const char* keywords[] = { "dst", "iterFactor", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:randShuffle", (char**)keywords, &jsobj_dst, &jsobj_iterFactor) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_iterFactor, iterFactor, ArgInfo("iterFactor", 0)))
    {
        ERRWRAP2_NAPI(info, cv::randShuffle(dst, iterFactor, 0));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "randShuffle");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_randn(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_mean = NULL;
    Mat mean;
    Napi::Value* jsobj_stddev = NULL;
    Mat stddev;

    const char* keywords[] = { "dst", "mean", "stddev", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:randn", (char**)keywords, &jsobj_dst, &jsobj_mean, &jsobj_stddev) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_mean, mean, ArgInfo("mean", 0)) &&
        jsopencv_to_safe(jsobj_stddev, stddev, ArgInfo("stddev", 0)))
    {
        ERRWRAP2_NAPI(info, cv::randn(dst, mean, stddev));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_mean = NULL;
    UMat mean;
    Napi::Value* jsobj_stddev = NULL;
    UMat stddev;

    const char* keywords[] = { "dst", "mean", "stddev", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:randn", (char**)keywords, &jsobj_dst, &jsobj_mean, &jsobj_stddev) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_mean, mean, ArgInfo("mean", 0)) &&
        jsopencv_to_safe(jsobj_stddev, stddev, ArgInfo("stddev", 0)))
    {
        ERRWRAP2_NAPI(info, cv::randn(dst, mean, stddev));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "randn");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_randu(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_low = NULL;
    Mat low;
    Napi::Value* jsobj_high = NULL;
    Mat high;

    const char* keywords[] = { "dst", "low", "high", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:randu", (char**)keywords, &jsobj_dst, &jsobj_low, &jsobj_high) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_low, low, ArgInfo("low", 0)) &&
        jsopencv_to_safe(jsobj_high, high, ArgInfo("high", 0)))
    {
        ERRWRAP2_NAPI(info, cv::randu(dst, low, high));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_low = NULL;
    UMat low;
    Napi::Value* jsobj_high = NULL;
    UMat high;

    const char* keywords[] = { "dst", "low", "high", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:randu", (char**)keywords, &jsobj_dst, &jsobj_low, &jsobj_high) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_low, low, ArgInfo("low", 0)) &&
        jsopencv_to_safe(jsobj_high, high, ArgInfo("high", 0)))
    {
        ERRWRAP2_NAPI(info, cv::randu(dst, low, high));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "randu");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_readOpticalFlow(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_path = NULL;
    String path;
    Mat retval;

    const char* keywords[] = { "path", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:readOpticalFlow", (char**)keywords, &jsobj_path) &&
        jsopencv_to_safe(jsobj_path, path, ArgInfo("path", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::readOpticalFlow(path));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_recoverPose(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(8);

    {
    Napi::Value* jsobj_points1 = NULL;
    Mat points1;
    Napi::Value* jsobj_points2 = NULL;
    Mat points2;
    Napi::Value* jsobj_cameraMatrix1 = NULL;
    Mat cameraMatrix1;
    Napi::Value* jsobj_distCoeffs1 = NULL;
    Mat distCoeffs1;
    Napi::Value* jsobj_cameraMatrix2 = NULL;
    Mat cameraMatrix2;
    Napi::Value* jsobj_distCoeffs2 = NULL;
    Mat distCoeffs2;
    Napi::Value* jsobj_E = NULL;
    Mat E;
    Napi::Value* jsobj_R = NULL;
    Mat R;
    Napi::Value* jsobj_t = NULL;
    Mat t;
    Napi::Value* jsobj_method = NULL;
    int method=cv::RANSAC;
    Napi::Value* jsobj_prob = NULL;
    double prob=0.999;
    Napi::Value* jsobj_threshold = NULL;
    double threshold=1.0;
    Napi::Value* jsobj_mask = NULL;
    Mat mask;
    int retval;

    const char* keywords[] = { "points1", "points2", "cameraMatrix1", "distCoeffs1", "cameraMatrix2", "distCoeffs2", "E", "R", "t", "method", "prob", "threshold", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOO|OOOOOOO:recoverPose", (char**)keywords, &jsobj_points1, &jsobj_points2, &jsobj_cameraMatrix1, &jsobj_distCoeffs1, &jsobj_cameraMatrix2, &jsobj_distCoeffs2, &jsobj_E, &jsobj_R, &jsobj_t, &jsobj_method, &jsobj_prob, &jsobj_threshold, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_points1, points1, ArgInfo("points1", 0)) &&
        jsopencv_to_safe(jsobj_points2, points2, ArgInfo("points2", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix1, cameraMatrix1, ArgInfo("cameraMatrix1", 0)) &&
        jsopencv_to_safe(jsobj_distCoeffs1, distCoeffs1, ArgInfo("distCoeffs1", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix2, cameraMatrix2, ArgInfo("cameraMatrix2", 0)) &&
        jsopencv_to_safe(jsobj_distCoeffs2, distCoeffs2, ArgInfo("distCoeffs2", 0)) &&
        jsopencv_to_safe(jsobj_E, E, ArgInfo("E", 1)) &&
        jsopencv_to_safe(jsobj_R, R, ArgInfo("R", 1)) &&
        jsopencv_to_safe(jsobj_t, t, ArgInfo("t", 1)) &&
        jsopencv_to_safe(jsobj_method, method, ArgInfo("method", 0)) &&
        jsopencv_to_safe(jsobj_prob, prob, ArgInfo("prob", 0)) &&
        jsopencv_to_safe(jsobj_threshold, threshold, ArgInfo("threshold", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::recoverPose(points1, points2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, E, R, t, method, prob, threshold, mask));
        return Js_BuildValue(info, "(NNNNN)", jsopencv_from(info, retval), jsopencv_from(info, E), jsopencv_from(info, R), jsopencv_from(info, t), jsopencv_from(info, mask));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_points1 = NULL;
    UMat points1;
    Napi::Value* jsobj_points2 = NULL;
    UMat points2;
    Napi::Value* jsobj_cameraMatrix1 = NULL;
    UMat cameraMatrix1;
    Napi::Value* jsobj_distCoeffs1 = NULL;
    UMat distCoeffs1;
    Napi::Value* jsobj_cameraMatrix2 = NULL;
    UMat cameraMatrix2;
    Napi::Value* jsobj_distCoeffs2 = NULL;
    UMat distCoeffs2;
    Napi::Value* jsobj_E = NULL;
    UMat E;
    Napi::Value* jsobj_R = NULL;
    UMat R;
    Napi::Value* jsobj_t = NULL;
    UMat t;
    Napi::Value* jsobj_method = NULL;
    int method=cv::RANSAC;
    Napi::Value* jsobj_prob = NULL;
    double prob=0.999;
    Napi::Value* jsobj_threshold = NULL;
    double threshold=1.0;
    Napi::Value* jsobj_mask = NULL;
    UMat mask;
    int retval;

    const char* keywords[] = { "points1", "points2", "cameraMatrix1", "distCoeffs1", "cameraMatrix2", "distCoeffs2", "E", "R", "t", "method", "prob", "threshold", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOO|OOOOOOO:recoverPose", (char**)keywords, &jsobj_points1, &jsobj_points2, &jsobj_cameraMatrix1, &jsobj_distCoeffs1, &jsobj_cameraMatrix2, &jsobj_distCoeffs2, &jsobj_E, &jsobj_R, &jsobj_t, &jsobj_method, &jsobj_prob, &jsobj_threshold, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_points1, points1, ArgInfo("points1", 0)) &&
        jsopencv_to_safe(jsobj_points2, points2, ArgInfo("points2", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix1, cameraMatrix1, ArgInfo("cameraMatrix1", 0)) &&
        jsopencv_to_safe(jsobj_distCoeffs1, distCoeffs1, ArgInfo("distCoeffs1", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix2, cameraMatrix2, ArgInfo("cameraMatrix2", 0)) &&
        jsopencv_to_safe(jsobj_distCoeffs2, distCoeffs2, ArgInfo("distCoeffs2", 0)) &&
        jsopencv_to_safe(jsobj_E, E, ArgInfo("E", 1)) &&
        jsopencv_to_safe(jsobj_R, R, ArgInfo("R", 1)) &&
        jsopencv_to_safe(jsobj_t, t, ArgInfo("t", 1)) &&
        jsopencv_to_safe(jsobj_method, method, ArgInfo("method", 0)) &&
        jsopencv_to_safe(jsobj_prob, prob, ArgInfo("prob", 0)) &&
        jsopencv_to_safe(jsobj_threshold, threshold, ArgInfo("threshold", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::recoverPose(points1, points2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, E, R, t, method, prob, threshold, mask));
        return Js_BuildValue(info, "(NNNNN)", jsopencv_from(info, retval), jsopencv_from(info, E), jsopencv_from(info, R), jsopencv_from(info, t), jsopencv_from(info, mask));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_E = NULL;
    Mat E;
    Napi::Value* jsobj_points1 = NULL;
    Mat points1;
    Napi::Value* jsobj_points2 = NULL;
    Mat points2;
    Napi::Value* jsobj_cameraMatrix = NULL;
    Mat cameraMatrix;
    Napi::Value* jsobj_R = NULL;
    Mat R;
    Napi::Value* jsobj_t = NULL;
    Mat t;
    Napi::Value* jsobj_mask = NULL;
    Mat mask;
    int retval;

    const char* keywords[] = { "E", "points1", "points2", "cameraMatrix", "R", "t", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOO:recoverPose", (char**)keywords, &jsobj_E, &jsobj_points1, &jsobj_points2, &jsobj_cameraMatrix, &jsobj_R, &jsobj_t, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_E, E, ArgInfo("E", 0)) &&
        jsopencv_to_safe(jsobj_points1, points1, ArgInfo("points1", 0)) &&
        jsopencv_to_safe(jsobj_points2, points2, ArgInfo("points2", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 0)) &&
        jsopencv_to_safe(jsobj_R, R, ArgInfo("R", 1)) &&
        jsopencv_to_safe(jsobj_t, t, ArgInfo("t", 1)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::recoverPose(E, points1, points2, cameraMatrix, R, t, mask));
        return Js_BuildValue(info, "(NNNN)", jsopencv_from(info, retval), jsopencv_from(info, R), jsopencv_from(info, t), jsopencv_from(info, mask));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_E = NULL;
    UMat E;
    Napi::Value* jsobj_points1 = NULL;
    UMat points1;
    Napi::Value* jsobj_points2 = NULL;
    UMat points2;
    Napi::Value* jsobj_cameraMatrix = NULL;
    UMat cameraMatrix;
    Napi::Value* jsobj_R = NULL;
    UMat R;
    Napi::Value* jsobj_t = NULL;
    UMat t;
    Napi::Value* jsobj_mask = NULL;
    UMat mask;
    int retval;

    const char* keywords[] = { "E", "points1", "points2", "cameraMatrix", "R", "t", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOO:recoverPose", (char**)keywords, &jsobj_E, &jsobj_points1, &jsobj_points2, &jsobj_cameraMatrix, &jsobj_R, &jsobj_t, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_E, E, ArgInfo("E", 0)) &&
        jsopencv_to_safe(jsobj_points1, points1, ArgInfo("points1", 0)) &&
        jsopencv_to_safe(jsobj_points2, points2, ArgInfo("points2", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 0)) &&
        jsopencv_to_safe(jsobj_R, R, ArgInfo("R", 1)) &&
        jsopencv_to_safe(jsobj_t, t, ArgInfo("t", 1)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::recoverPose(E, points1, points2, cameraMatrix, R, t, mask));
        return Js_BuildValue(info, "(NNNN)", jsopencv_from(info, retval), jsopencv_from(info, R), jsopencv_from(info, t), jsopencv_from(info, mask));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_E = NULL;
    Mat E;
    Napi::Value* jsobj_points1 = NULL;
    Mat points1;
    Napi::Value* jsobj_points2 = NULL;
    Mat points2;
    Napi::Value* jsobj_R = NULL;
    Mat R;
    Napi::Value* jsobj_t = NULL;
    Mat t;
    Napi::Value* jsobj_focal = NULL;
    double focal=1.0;
    Napi::Value* jsobj_pp = NULL;
    Point2d pp=Point2d(0, 0);
    Napi::Value* jsobj_mask = NULL;
    Mat mask;
    int retval;

    const char* keywords[] = { "E", "points1", "points2", "R", "t", "focal", "pp", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOOOO:recoverPose", (char**)keywords, &jsobj_E, &jsobj_points1, &jsobj_points2, &jsobj_R, &jsobj_t, &jsobj_focal, &jsobj_pp, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_E, E, ArgInfo("E", 0)) &&
        jsopencv_to_safe(jsobj_points1, points1, ArgInfo("points1", 0)) &&
        jsopencv_to_safe(jsobj_points2, points2, ArgInfo("points2", 0)) &&
        jsopencv_to_safe(jsobj_R, R, ArgInfo("R", 1)) &&
        jsopencv_to_safe(jsobj_t, t, ArgInfo("t", 1)) &&
        jsopencv_to_safe(jsobj_focal, focal, ArgInfo("focal", 0)) &&
        jsopencv_to_safe(jsobj_pp, pp, ArgInfo("pp", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::recoverPose(E, points1, points2, R, t, focal, pp, mask));
        return Js_BuildValue(info, "(NNNN)", jsopencv_from(info, retval), jsopencv_from(info, R), jsopencv_from(info, t), jsopencv_from(info, mask));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_E = NULL;
    UMat E;
    Napi::Value* jsobj_points1 = NULL;
    UMat points1;
    Napi::Value* jsobj_points2 = NULL;
    UMat points2;
    Napi::Value* jsobj_R = NULL;
    UMat R;
    Napi::Value* jsobj_t = NULL;
    UMat t;
    Napi::Value* jsobj_focal = NULL;
    double focal=1.0;
    Napi::Value* jsobj_pp = NULL;
    Point2d pp=Point2d(0, 0);
    Napi::Value* jsobj_mask = NULL;
    UMat mask;
    int retval;

    const char* keywords[] = { "E", "points1", "points2", "R", "t", "focal", "pp", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOOOO:recoverPose", (char**)keywords, &jsobj_E, &jsobj_points1, &jsobj_points2, &jsobj_R, &jsobj_t, &jsobj_focal, &jsobj_pp, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_E, E, ArgInfo("E", 0)) &&
        jsopencv_to_safe(jsobj_points1, points1, ArgInfo("points1", 0)) &&
        jsopencv_to_safe(jsobj_points2, points2, ArgInfo("points2", 0)) &&
        jsopencv_to_safe(jsobj_R, R, ArgInfo("R", 1)) &&
        jsopencv_to_safe(jsobj_t, t, ArgInfo("t", 1)) &&
        jsopencv_to_safe(jsobj_focal, focal, ArgInfo("focal", 0)) &&
        jsopencv_to_safe(jsobj_pp, pp, ArgInfo("pp", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::recoverPose(E, points1, points2, R, t, focal, pp, mask));
        return Js_BuildValue(info, "(NNNN)", jsopencv_from(info, retval), jsopencv_from(info, R), jsopencv_from(info, t), jsopencv_from(info, mask));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_E = NULL;
    Mat E;
    Napi::Value* jsobj_points1 = NULL;
    Mat points1;
    Napi::Value* jsobj_points2 = NULL;
    Mat points2;
    Napi::Value* jsobj_cameraMatrix = NULL;
    Mat cameraMatrix;
    Napi::Value* jsobj_R = NULL;
    Mat R;
    Napi::Value* jsobj_t = NULL;
    Mat t;
    Napi::Value* jsobj_distanceThresh = NULL;
    double distanceThresh=0;
    Napi::Value* jsobj_mask = NULL;
    Mat mask;
    Napi::Value* jsobj_triangulatedPoints = NULL;
    Mat triangulatedPoints;
    int retval;

    const char* keywords[] = { "E", "points1", "points2", "cameraMatrix", "distanceThresh", "R", "t", "mask", "triangulatedPoints", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOO|OOOO:recoverPose", (char**)keywords, &jsobj_E, &jsobj_points1, &jsobj_points2, &jsobj_cameraMatrix, &jsobj_distanceThresh, &jsobj_R, &jsobj_t, &jsobj_mask, &jsobj_triangulatedPoints) &&
        jsopencv_to_safe(jsobj_E, E, ArgInfo("E", 0)) &&
        jsopencv_to_safe(jsobj_points1, points1, ArgInfo("points1", 0)) &&
        jsopencv_to_safe(jsobj_points2, points2, ArgInfo("points2", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 0)) &&
        jsopencv_to_safe(jsobj_R, R, ArgInfo("R", 1)) &&
        jsopencv_to_safe(jsobj_t, t, ArgInfo("t", 1)) &&
        jsopencv_to_safe(jsobj_distanceThresh, distanceThresh, ArgInfo("distanceThresh", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 1)) &&
        jsopencv_to_safe(jsobj_triangulatedPoints, triangulatedPoints, ArgInfo("triangulatedPoints", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::recoverPose(E, points1, points2, cameraMatrix, R, t, distanceThresh, mask, triangulatedPoints));
        return Js_BuildValue(info, "(NNNNN)", jsopencv_from(info, retval), jsopencv_from(info, R), jsopencv_from(info, t), jsopencv_from(info, mask), jsopencv_from(info, triangulatedPoints));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_E = NULL;
    UMat E;
    Napi::Value* jsobj_points1 = NULL;
    UMat points1;
    Napi::Value* jsobj_points2 = NULL;
    UMat points2;
    Napi::Value* jsobj_cameraMatrix = NULL;
    UMat cameraMatrix;
    Napi::Value* jsobj_R = NULL;
    UMat R;
    Napi::Value* jsobj_t = NULL;
    UMat t;
    Napi::Value* jsobj_distanceThresh = NULL;
    double distanceThresh=0;
    Napi::Value* jsobj_mask = NULL;
    UMat mask;
    Napi::Value* jsobj_triangulatedPoints = NULL;
    UMat triangulatedPoints;
    int retval;

    const char* keywords[] = { "E", "points1", "points2", "cameraMatrix", "distanceThresh", "R", "t", "mask", "triangulatedPoints", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOO|OOOO:recoverPose", (char**)keywords, &jsobj_E, &jsobj_points1, &jsobj_points2, &jsobj_cameraMatrix, &jsobj_distanceThresh, &jsobj_R, &jsobj_t, &jsobj_mask, &jsobj_triangulatedPoints) &&
        jsopencv_to_safe(jsobj_E, E, ArgInfo("E", 0)) &&
        jsopencv_to_safe(jsobj_points1, points1, ArgInfo("points1", 0)) &&
        jsopencv_to_safe(jsobj_points2, points2, ArgInfo("points2", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 0)) &&
        jsopencv_to_safe(jsobj_R, R, ArgInfo("R", 1)) &&
        jsopencv_to_safe(jsobj_t, t, ArgInfo("t", 1)) &&
        jsopencv_to_safe(jsobj_distanceThresh, distanceThresh, ArgInfo("distanceThresh", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 1)) &&
        jsopencv_to_safe(jsobj_triangulatedPoints, triangulatedPoints, ArgInfo("triangulatedPoints", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::recoverPose(E, points1, points2, cameraMatrix, R, t, distanceThresh, mask, triangulatedPoints));
        return Js_BuildValue(info, "(NNNNN)", jsopencv_from(info, retval), jsopencv_from(info, R), jsopencv_from(info, t), jsopencv_from(info, mask), jsopencv_from(info, triangulatedPoints));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "recoverPose");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_rectangle(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(4);

    {
    Napi::Value* jsobj_img = NULL;
    Mat img;
    Napi::Value* jsobj_pt1 = NULL;
    Point pt1;
    Napi::Value* jsobj_pt2 = NULL;
    Point pt2;
    Napi::Value* jsobj_color = NULL;
    Scalar color;
    Napi::Value* jsobj_thickness = NULL;
    int thickness=1;
    Napi::Value* jsobj_lineType = NULL;
    int lineType=LINE_8;
    Napi::Value* jsobj_shift = NULL;
    int shift=0;

    const char* keywords[] = { "img", "pt1", "pt2", "color", "thickness", "lineType", "shift", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOO:rectangle", (char**)keywords, &jsobj_img, &jsobj_pt1, &jsobj_pt2, &jsobj_color, &jsobj_thickness, &jsobj_lineType, &jsobj_shift) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 1)) &&
        jsopencv_to_safe(jsobj_pt1, pt1, ArgInfo("pt1", 0)) &&
        jsopencv_to_safe(jsobj_pt2, pt2, ArgInfo("pt2", 0)) &&
        jsopencv_to_safe(jsobj_color, color, ArgInfo("color", 0)) &&
        jsopencv_to_safe(jsobj_thickness, thickness, ArgInfo("thickness", 0)) &&
        jsopencv_to_safe(jsobj_lineType, lineType, ArgInfo("lineType", 0)) &&
        jsopencv_to_safe(jsobj_shift, shift, ArgInfo("shift", 0)))
    {
        ERRWRAP2_NAPI(info, cv::rectangle(img, pt1, pt2, color, thickness, lineType, shift));
        return jsopencv_from(info, img);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_img = NULL;
    UMat img;
    Napi::Value* jsobj_pt1 = NULL;
    Point pt1;
    Napi::Value* jsobj_pt2 = NULL;
    Point pt2;
    Napi::Value* jsobj_color = NULL;
    Scalar color;
    Napi::Value* jsobj_thickness = NULL;
    int thickness=1;
    Napi::Value* jsobj_lineType = NULL;
    int lineType=LINE_8;
    Napi::Value* jsobj_shift = NULL;
    int shift=0;

    const char* keywords[] = { "img", "pt1", "pt2", "color", "thickness", "lineType", "shift", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOO:rectangle", (char**)keywords, &jsobj_img, &jsobj_pt1, &jsobj_pt2, &jsobj_color, &jsobj_thickness, &jsobj_lineType, &jsobj_shift) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 1)) &&
        jsopencv_to_safe(jsobj_pt1, pt1, ArgInfo("pt1", 0)) &&
        jsopencv_to_safe(jsobj_pt2, pt2, ArgInfo("pt2", 0)) &&
        jsopencv_to_safe(jsobj_color, color, ArgInfo("color", 0)) &&
        jsopencv_to_safe(jsobj_thickness, thickness, ArgInfo("thickness", 0)) &&
        jsopencv_to_safe(jsobj_lineType, lineType, ArgInfo("lineType", 0)) &&
        jsopencv_to_safe(jsobj_shift, shift, ArgInfo("shift", 0)))
    {
        ERRWRAP2_NAPI(info, cv::rectangle(img, pt1, pt2, color, thickness, lineType, shift));
        return jsopencv_from(info, img);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_img = NULL;
    Mat img;
    Napi::Value* jsobj_rec = NULL;
    Rect rec;
    Napi::Value* jsobj_color = NULL;
    Scalar color;
    Napi::Value* jsobj_thickness = NULL;
    int thickness=1;
    Napi::Value* jsobj_lineType = NULL;
    int lineType=LINE_8;
    Napi::Value* jsobj_shift = NULL;
    int shift=0;

    const char* keywords[] = { "img", "rec", "color", "thickness", "lineType", "shift", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOO:rectangle", (char**)keywords, &jsobj_img, &jsobj_rec, &jsobj_color, &jsobj_thickness, &jsobj_lineType, &jsobj_shift) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 1)) &&
        jsopencv_to_safe(jsobj_rec, rec, ArgInfo("rec", 0)) &&
        jsopencv_to_safe(jsobj_color, color, ArgInfo("color", 0)) &&
        jsopencv_to_safe(jsobj_thickness, thickness, ArgInfo("thickness", 0)) &&
        jsopencv_to_safe(jsobj_lineType, lineType, ArgInfo("lineType", 0)) &&
        jsopencv_to_safe(jsobj_shift, shift, ArgInfo("shift", 0)))
    {
        ERRWRAP2_NAPI(info, cv::rectangle(img, rec, color, thickness, lineType, shift));
        return jsopencv_from(info, img);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_img = NULL;
    UMat img;
    Napi::Value* jsobj_rec = NULL;
    Rect rec;
    Napi::Value* jsobj_color = NULL;
    Scalar color;
    Napi::Value* jsobj_thickness = NULL;
    int thickness=1;
    Napi::Value* jsobj_lineType = NULL;
    int lineType=LINE_8;
    Napi::Value* jsobj_shift = NULL;
    int shift=0;

    const char* keywords[] = { "img", "rec", "color", "thickness", "lineType", "shift", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOO:rectangle", (char**)keywords, &jsobj_img, &jsobj_rec, &jsobj_color, &jsobj_thickness, &jsobj_lineType, &jsobj_shift) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 1)) &&
        jsopencv_to_safe(jsobj_rec, rec, ArgInfo("rec", 0)) &&
        jsopencv_to_safe(jsobj_color, color, ArgInfo("color", 0)) &&
        jsopencv_to_safe(jsobj_thickness, thickness, ArgInfo("thickness", 0)) &&
        jsopencv_to_safe(jsobj_lineType, lineType, ArgInfo("lineType", 0)) &&
        jsopencv_to_safe(jsobj_shift, shift, ArgInfo("shift", 0)))
    {
        ERRWRAP2_NAPI(info, cv::rectangle(img, rec, color, thickness, lineType, shift));
        return jsopencv_from(info, img);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "rectangle");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_rectangleIntersectionArea(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_a = NULL;
    Rect2d a;
    Napi::Value* jsobj_b = NULL;
    Rect2d b;
    double retval;

    const char* keywords[] = { "a", "b", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:rectangleIntersectionArea", (char**)keywords, &jsobj_a, &jsobj_b) &&
        jsopencv_to_safe(jsobj_a, a, ArgInfo("a", 0)) &&
        jsopencv_to_safe(jsobj_b, b, ArgInfo("b", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::rectangleIntersectionArea(a, b));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_rectify3Collinear(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_cameraMatrix1 = NULL;
    Mat cameraMatrix1;
    Napi::Value* jsobj_distCoeffs1 = NULL;
    Mat distCoeffs1;
    Napi::Value* jsobj_cameraMatrix2 = NULL;
    Mat cameraMatrix2;
    Napi::Value* jsobj_distCoeffs2 = NULL;
    Mat distCoeffs2;
    Napi::Value* jsobj_cameraMatrix3 = NULL;
    Mat cameraMatrix3;
    Napi::Value* jsobj_distCoeffs3 = NULL;
    Mat distCoeffs3;
    Napi::Value* jsobj_imgpt1 = NULL;
    vector_Mat imgpt1;
    Napi::Value* jsobj_imgpt3 = NULL;
    vector_Mat imgpt3;
    Napi::Value* jsobj_imageSize = NULL;
    Size imageSize;
    Napi::Value* jsobj_R12 = NULL;
    Mat R12;
    Napi::Value* jsobj_T12 = NULL;
    Mat T12;
    Napi::Value* jsobj_R13 = NULL;
    Mat R13;
    Napi::Value* jsobj_T13 = NULL;
    Mat T13;
    Napi::Value* jsobj_R1 = NULL;
    Mat R1;
    Napi::Value* jsobj_R2 = NULL;
    Mat R2;
    Napi::Value* jsobj_R3 = NULL;
    Mat R3;
    Napi::Value* jsobj_P1 = NULL;
    Mat P1;
    Napi::Value* jsobj_P2 = NULL;
    Mat P2;
    Napi::Value* jsobj_P3 = NULL;
    Mat P3;
    Napi::Value* jsobj_Q = NULL;
    Mat Q;
    Napi::Value* jsobj_alpha = NULL;
    double alpha=0;
    Napi::Value* jsobj_newImgSize = NULL;
    Size newImgSize;
    Rect roi1;
    Rect roi2;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;
    float retval;

    const char* keywords[] = { "cameraMatrix1", "distCoeffs1", "cameraMatrix2", "distCoeffs2", "cameraMatrix3", "distCoeffs3", "imgpt1", "imgpt3", "imageSize", "R12", "T12", "R13", "T13", "alpha", "newImgSize", "flags", "R1", "R2", "R3", "P1", "P2", "P3", "Q", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOOOOOOOOOOOO|OOOOOOO:rectify3Collinear", (char**)keywords, &jsobj_cameraMatrix1, &jsobj_distCoeffs1, &jsobj_cameraMatrix2, &jsobj_distCoeffs2, &jsobj_cameraMatrix3, &jsobj_distCoeffs3, &jsobj_imgpt1, &jsobj_imgpt3, &jsobj_imageSize, &jsobj_R12, &jsobj_T12, &jsobj_R13, &jsobj_T13, &jsobj_alpha, &jsobj_newImgSize, &jsobj_flags, &jsobj_R1, &jsobj_R2, &jsobj_R3, &jsobj_P1, &jsobj_P2, &jsobj_P3, &jsobj_Q) &&
        jsopencv_to_safe(jsobj_cameraMatrix1, cameraMatrix1, ArgInfo("cameraMatrix1", 0)) &&
        jsopencv_to_safe(jsobj_distCoeffs1, distCoeffs1, ArgInfo("distCoeffs1", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix2, cameraMatrix2, ArgInfo("cameraMatrix2", 0)) &&
        jsopencv_to_safe(jsobj_distCoeffs2, distCoeffs2, ArgInfo("distCoeffs2", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix3, cameraMatrix3, ArgInfo("cameraMatrix3", 0)) &&
        jsopencv_to_safe(jsobj_distCoeffs3, distCoeffs3, ArgInfo("distCoeffs3", 0)) &&
        jsopencv_to_safe(jsobj_imgpt1, imgpt1, ArgInfo("imgpt1", 0)) &&
        jsopencv_to_safe(jsobj_imgpt3, imgpt3, ArgInfo("imgpt3", 0)) &&
        jsopencv_to_safe(jsobj_imageSize, imageSize, ArgInfo("imageSize", 0)) &&
        jsopencv_to_safe(jsobj_R12, R12, ArgInfo("R12", 0)) &&
        jsopencv_to_safe(jsobj_T12, T12, ArgInfo("T12", 0)) &&
        jsopencv_to_safe(jsobj_R13, R13, ArgInfo("R13", 0)) &&
        jsopencv_to_safe(jsobj_T13, T13, ArgInfo("T13", 0)) &&
        jsopencv_to_safe(jsobj_R1, R1, ArgInfo("R1", 1)) &&
        jsopencv_to_safe(jsobj_R2, R2, ArgInfo("R2", 1)) &&
        jsopencv_to_safe(jsobj_R3, R3, ArgInfo("R3", 1)) &&
        jsopencv_to_safe(jsobj_P1, P1, ArgInfo("P1", 1)) &&
        jsopencv_to_safe(jsobj_P2, P2, ArgInfo("P2", 1)) &&
        jsopencv_to_safe(jsobj_P3, P3, ArgInfo("P3", 1)) &&
        jsopencv_to_safe(jsobj_Q, Q, ArgInfo("Q", 1)) &&
        jsopencv_to_safe(jsobj_alpha, alpha, ArgInfo("alpha", 0)) &&
        jsopencv_to_safe(jsobj_newImgSize, newImgSize, ArgInfo("newImgSize", 0)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::rectify3Collinear(cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, cameraMatrix3, distCoeffs3, imgpt1, imgpt3, imageSize, R12, T12, R13, T13, R1, R2, R3, P1, P2, P3, Q, alpha, newImgSize, &roi1, &roi2, flags));
        return Js_BuildValue(info, "(NNNNNNNNNN)", jsopencv_from(info, retval), jsopencv_from(info, R1), jsopencv_from(info, R2), jsopencv_from(info, R3), jsopencv_from(info, P1), jsopencv_from(info, P2), jsopencv_from(info, P3), jsopencv_from(info, Q), jsopencv_from(info, roi1), jsopencv_from(info, roi2));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_cameraMatrix1 = NULL;
    UMat cameraMatrix1;
    Napi::Value* jsobj_distCoeffs1 = NULL;
    UMat distCoeffs1;
    Napi::Value* jsobj_cameraMatrix2 = NULL;
    UMat cameraMatrix2;
    Napi::Value* jsobj_distCoeffs2 = NULL;
    UMat distCoeffs2;
    Napi::Value* jsobj_cameraMatrix3 = NULL;
    UMat cameraMatrix3;
    Napi::Value* jsobj_distCoeffs3 = NULL;
    UMat distCoeffs3;
    Napi::Value* jsobj_imgpt1 = NULL;
    vector_UMat imgpt1;
    Napi::Value* jsobj_imgpt3 = NULL;
    vector_UMat imgpt3;
    Napi::Value* jsobj_imageSize = NULL;
    Size imageSize;
    Napi::Value* jsobj_R12 = NULL;
    UMat R12;
    Napi::Value* jsobj_T12 = NULL;
    UMat T12;
    Napi::Value* jsobj_R13 = NULL;
    UMat R13;
    Napi::Value* jsobj_T13 = NULL;
    UMat T13;
    Napi::Value* jsobj_R1 = NULL;
    UMat R1;
    Napi::Value* jsobj_R2 = NULL;
    UMat R2;
    Napi::Value* jsobj_R3 = NULL;
    UMat R3;
    Napi::Value* jsobj_P1 = NULL;
    UMat P1;
    Napi::Value* jsobj_P2 = NULL;
    UMat P2;
    Napi::Value* jsobj_P3 = NULL;
    UMat P3;
    Napi::Value* jsobj_Q = NULL;
    UMat Q;
    Napi::Value* jsobj_alpha = NULL;
    double alpha=0;
    Napi::Value* jsobj_newImgSize = NULL;
    Size newImgSize;
    Rect roi1;
    Rect roi2;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;
    float retval;

    const char* keywords[] = { "cameraMatrix1", "distCoeffs1", "cameraMatrix2", "distCoeffs2", "cameraMatrix3", "distCoeffs3", "imgpt1", "imgpt3", "imageSize", "R12", "T12", "R13", "T13", "alpha", "newImgSize", "flags", "R1", "R2", "R3", "P1", "P2", "P3", "Q", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOOOOOOOOOOOO|OOOOOOO:rectify3Collinear", (char**)keywords, &jsobj_cameraMatrix1, &jsobj_distCoeffs1, &jsobj_cameraMatrix2, &jsobj_distCoeffs2, &jsobj_cameraMatrix3, &jsobj_distCoeffs3, &jsobj_imgpt1, &jsobj_imgpt3, &jsobj_imageSize, &jsobj_R12, &jsobj_T12, &jsobj_R13, &jsobj_T13, &jsobj_alpha, &jsobj_newImgSize, &jsobj_flags, &jsobj_R1, &jsobj_R2, &jsobj_R3, &jsobj_P1, &jsobj_P2, &jsobj_P3, &jsobj_Q) &&
        jsopencv_to_safe(jsobj_cameraMatrix1, cameraMatrix1, ArgInfo("cameraMatrix1", 0)) &&
        jsopencv_to_safe(jsobj_distCoeffs1, distCoeffs1, ArgInfo("distCoeffs1", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix2, cameraMatrix2, ArgInfo("cameraMatrix2", 0)) &&
        jsopencv_to_safe(jsobj_distCoeffs2, distCoeffs2, ArgInfo("distCoeffs2", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix3, cameraMatrix3, ArgInfo("cameraMatrix3", 0)) &&
        jsopencv_to_safe(jsobj_distCoeffs3, distCoeffs3, ArgInfo("distCoeffs3", 0)) &&
        jsopencv_to_safe(jsobj_imgpt1, imgpt1, ArgInfo("imgpt1", 0)) &&
        jsopencv_to_safe(jsobj_imgpt3, imgpt3, ArgInfo("imgpt3", 0)) &&
        jsopencv_to_safe(jsobj_imageSize, imageSize, ArgInfo("imageSize", 0)) &&
        jsopencv_to_safe(jsobj_R12, R12, ArgInfo("R12", 0)) &&
        jsopencv_to_safe(jsobj_T12, T12, ArgInfo("T12", 0)) &&
        jsopencv_to_safe(jsobj_R13, R13, ArgInfo("R13", 0)) &&
        jsopencv_to_safe(jsobj_T13, T13, ArgInfo("T13", 0)) &&
        jsopencv_to_safe(jsobj_R1, R1, ArgInfo("R1", 1)) &&
        jsopencv_to_safe(jsobj_R2, R2, ArgInfo("R2", 1)) &&
        jsopencv_to_safe(jsobj_R3, R3, ArgInfo("R3", 1)) &&
        jsopencv_to_safe(jsobj_P1, P1, ArgInfo("P1", 1)) &&
        jsopencv_to_safe(jsobj_P2, P2, ArgInfo("P2", 1)) &&
        jsopencv_to_safe(jsobj_P3, P3, ArgInfo("P3", 1)) &&
        jsopencv_to_safe(jsobj_Q, Q, ArgInfo("Q", 1)) &&
        jsopencv_to_safe(jsobj_alpha, alpha, ArgInfo("alpha", 0)) &&
        jsopencv_to_safe(jsobj_newImgSize, newImgSize, ArgInfo("newImgSize", 0)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::rectify3Collinear(cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, cameraMatrix3, distCoeffs3, imgpt1, imgpt3, imageSize, R12, T12, R13, T13, R1, R2, R3, P1, P2, P3, Q, alpha, newImgSize, &roi1, &roi2, flags));
        return Js_BuildValue(info, "(NNNNNNNNNN)", jsopencv_from(info, retval), jsopencv_from(info, R1), jsopencv_from(info, R2), jsopencv_from(info, R3), jsopencv_from(info, P1), jsopencv_from(info, P2), jsopencv_from(info, P3), jsopencv_from(info, Q), jsopencv_from(info, roi1), jsopencv_from(info, roi2));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "rectify3Collinear");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_reduce(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_dim = NULL;
    int dim=0;
    Napi::Value* jsobj_rtype = NULL;
    int rtype=0;
    Napi::Value* jsobj_dtype = NULL;
    int dtype=-1;

    const char* keywords[] = { "src", "dim", "rtype", "dst", "dtype", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OO:reduce", (char**)keywords, &jsobj_src, &jsobj_dim, &jsobj_rtype, &jsobj_dst, &jsobj_dtype) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_dim, dim, ArgInfo("dim", 0)) &&
        jsopencv_to_safe(jsobj_rtype, rtype, ArgInfo("rtype", 0)) &&
        jsopencv_to_safe(jsobj_dtype, dtype, ArgInfo("dtype", 0)))
    {
        ERRWRAP2_NAPI(info, cv::reduce(src, dst, dim, rtype, dtype));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_dim = NULL;
    int dim=0;
    Napi::Value* jsobj_rtype = NULL;
    int rtype=0;
    Napi::Value* jsobj_dtype = NULL;
    int dtype=-1;

    const char* keywords[] = { "src", "dim", "rtype", "dst", "dtype", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OO:reduce", (char**)keywords, &jsobj_src, &jsobj_dim, &jsobj_rtype, &jsobj_dst, &jsobj_dtype) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_dim, dim, ArgInfo("dim", 0)) &&
        jsopencv_to_safe(jsobj_rtype, rtype, ArgInfo("rtype", 0)) &&
        jsopencv_to_safe(jsobj_dtype, dtype, ArgInfo("dtype", 0)))
    {
        ERRWRAP2_NAPI(info, cv::reduce(src, dst, dim, rtype, dtype));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "reduce");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_reduceArgMax(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_axis = NULL;
    int axis=0;
    Napi::Value* jsobj_lastIndex = NULL;
    bool lastIndex=false;

    const char* keywords[] = { "src", "axis", "dst", "lastIndex", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:reduceArgMax", (char**)keywords, &jsobj_src, &jsobj_axis, &jsobj_dst, &jsobj_lastIndex) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_axis, axis, ArgInfo("axis", 0)) &&
        jsopencv_to_safe(jsobj_lastIndex, lastIndex, ArgInfo("lastIndex", 0)))
    {
        ERRWRAP2_NAPI(info, cv::reduceArgMax(src, dst, axis, lastIndex));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_axis = NULL;
    int axis=0;
    Napi::Value* jsobj_lastIndex = NULL;
    bool lastIndex=false;

    const char* keywords[] = { "src", "axis", "dst", "lastIndex", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:reduceArgMax", (char**)keywords, &jsobj_src, &jsobj_axis, &jsobj_dst, &jsobj_lastIndex) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_axis, axis, ArgInfo("axis", 0)) &&
        jsopencv_to_safe(jsobj_lastIndex, lastIndex, ArgInfo("lastIndex", 0)))
    {
        ERRWRAP2_NAPI(info, cv::reduceArgMax(src, dst, axis, lastIndex));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "reduceArgMax");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_reduceArgMin(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_axis = NULL;
    int axis=0;
    Napi::Value* jsobj_lastIndex = NULL;
    bool lastIndex=false;

    const char* keywords[] = { "src", "axis", "dst", "lastIndex", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:reduceArgMin", (char**)keywords, &jsobj_src, &jsobj_axis, &jsobj_dst, &jsobj_lastIndex) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_axis, axis, ArgInfo("axis", 0)) &&
        jsopencv_to_safe(jsobj_lastIndex, lastIndex, ArgInfo("lastIndex", 0)))
    {
        ERRWRAP2_NAPI(info, cv::reduceArgMin(src, dst, axis, lastIndex));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_axis = NULL;
    int axis=0;
    Napi::Value* jsobj_lastIndex = NULL;
    bool lastIndex=false;

    const char* keywords[] = { "src", "axis", "dst", "lastIndex", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:reduceArgMin", (char**)keywords, &jsobj_src, &jsobj_axis, &jsobj_dst, &jsobj_lastIndex) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_axis, axis, ArgInfo("axis", 0)) &&
        jsopencv_to_safe(jsobj_lastIndex, lastIndex, ArgInfo("lastIndex", 0)))
    {
        ERRWRAP2_NAPI(info, cv::reduceArgMin(src, dst, axis, lastIndex));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "reduceArgMin");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_remap(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_map1 = NULL;
    Mat map1;
    Napi::Value* jsobj_map2 = NULL;
    Mat map2;
    Napi::Value* jsobj_interpolation = NULL;
    int interpolation=0;
    Napi::Value* jsobj_borderMode = NULL;
    int borderMode=BORDER_CONSTANT;
    Napi::Value* jsobj_borderValue = NULL;
    Scalar borderValue;

    const char* keywords[] = { "src", "map1", "map2", "interpolation", "dst", "borderMode", "borderValue", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOO:remap", (char**)keywords, &jsobj_src, &jsobj_map1, &jsobj_map2, &jsobj_interpolation, &jsobj_dst, &jsobj_borderMode, &jsobj_borderValue) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_map1, map1, ArgInfo("map1", 0)) &&
        jsopencv_to_safe(jsobj_map2, map2, ArgInfo("map2", 0)) &&
        jsopencv_to_safe(jsobj_interpolation, interpolation, ArgInfo("interpolation", 0)) &&
        jsopencv_to_safe(jsobj_borderMode, borderMode, ArgInfo("borderMode", 0)) &&
        jsopencv_to_safe(jsobj_borderValue, borderValue, ArgInfo("borderValue", 0)))
    {
        ERRWRAP2_NAPI(info, cv::remap(src, dst, map1, map2, interpolation, borderMode, borderValue));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_map1 = NULL;
    UMat map1;
    Napi::Value* jsobj_map2 = NULL;
    UMat map2;
    Napi::Value* jsobj_interpolation = NULL;
    int interpolation=0;
    Napi::Value* jsobj_borderMode = NULL;
    int borderMode=BORDER_CONSTANT;
    Napi::Value* jsobj_borderValue = NULL;
    Scalar borderValue;

    const char* keywords[] = { "src", "map1", "map2", "interpolation", "dst", "borderMode", "borderValue", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOO:remap", (char**)keywords, &jsobj_src, &jsobj_map1, &jsobj_map2, &jsobj_interpolation, &jsobj_dst, &jsobj_borderMode, &jsobj_borderValue) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_map1, map1, ArgInfo("map1", 0)) &&
        jsopencv_to_safe(jsobj_map2, map2, ArgInfo("map2", 0)) &&
        jsopencv_to_safe(jsobj_interpolation, interpolation, ArgInfo("interpolation", 0)) &&
        jsopencv_to_safe(jsobj_borderMode, borderMode, ArgInfo("borderMode", 0)) &&
        jsopencv_to_safe(jsobj_borderValue, borderValue, ArgInfo("borderValue", 0)))
    {
        ERRWRAP2_NAPI(info, cv::remap(src, dst, map1, map2, interpolation, borderMode, borderValue));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "remap");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_repeat(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_ny = NULL;
    int ny=0;
    Napi::Value* jsobj_nx = NULL;
    int nx=0;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;

    const char* keywords[] = { "src", "ny", "nx", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:repeat", (char**)keywords, &jsobj_src, &jsobj_ny, &jsobj_nx, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_ny, ny, ArgInfo("ny", 0)) &&
        jsopencv_to_safe(jsobj_nx, nx, ArgInfo("nx", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)))
    {
        ERRWRAP2_NAPI(info, cv::repeat(src, ny, nx, dst));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_ny = NULL;
    int ny=0;
    Napi::Value* jsobj_nx = NULL;
    int nx=0;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;

    const char* keywords[] = { "src", "ny", "nx", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:repeat", (char**)keywords, &jsobj_src, &jsobj_ny, &jsobj_nx, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_ny, ny, ArgInfo("ny", 0)) &&
        jsopencv_to_safe(jsobj_nx, nx, ArgInfo("nx", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)))
    {
        ERRWRAP2_NAPI(info, cv::repeat(src, ny, nx, dst));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "repeat");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_reprojectImageTo3D(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_disparity = NULL;
    Mat disparity;
    Napi::Value* jsobj__3dImage = NULL;
    Mat _3dImage;
    Napi::Value* jsobj_Q = NULL;
    Mat Q;
    Napi::Value* jsobj_handleMissingValues = NULL;
    bool handleMissingValues=false;
    Napi::Value* jsobj_ddepth = NULL;
    int ddepth=-1;

    const char* keywords[] = { "disparity", "Q", "_3dImage", "handleMissingValues", "ddepth", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOO:reprojectImageTo3D", (char**)keywords, &jsobj_disparity, &jsobj_Q, &jsobj__3dImage, &jsobj_handleMissingValues, &jsobj_ddepth) &&
        jsopencv_to_safe(jsobj_disparity, disparity, ArgInfo("disparity", 0)) &&
        jsopencv_to_safe(jsobj__3dImage, _3dImage, ArgInfo("_3dImage", 1)) &&
        jsopencv_to_safe(jsobj_Q, Q, ArgInfo("Q", 0)) &&
        jsopencv_to_safe(jsobj_handleMissingValues, handleMissingValues, ArgInfo("handleMissingValues", 0)) &&
        jsopencv_to_safe(jsobj_ddepth, ddepth, ArgInfo("ddepth", 0)))
    {
        ERRWRAP2_NAPI(info, cv::reprojectImageTo3D(disparity, _3dImage, Q, handleMissingValues, ddepth));
        return jsopencv_from(info, _3dImage);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_disparity = NULL;
    UMat disparity;
    Napi::Value* jsobj__3dImage = NULL;
    UMat _3dImage;
    Napi::Value* jsobj_Q = NULL;
    UMat Q;
    Napi::Value* jsobj_handleMissingValues = NULL;
    bool handleMissingValues=false;
    Napi::Value* jsobj_ddepth = NULL;
    int ddepth=-1;

    const char* keywords[] = { "disparity", "Q", "_3dImage", "handleMissingValues", "ddepth", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOO:reprojectImageTo3D", (char**)keywords, &jsobj_disparity, &jsobj_Q, &jsobj__3dImage, &jsobj_handleMissingValues, &jsobj_ddepth) &&
        jsopencv_to_safe(jsobj_disparity, disparity, ArgInfo("disparity", 0)) &&
        jsopencv_to_safe(jsobj__3dImage, _3dImage, ArgInfo("_3dImage", 1)) &&
        jsopencv_to_safe(jsobj_Q, Q, ArgInfo("Q", 0)) &&
        jsopencv_to_safe(jsobj_handleMissingValues, handleMissingValues, ArgInfo("handleMissingValues", 0)) &&
        jsopencv_to_safe(jsobj_ddepth, ddepth, ArgInfo("ddepth", 0)))
    {
        ERRWRAP2_NAPI(info, cv::reprojectImageTo3D(disparity, _3dImage, Q, handleMissingValues, ddepth));
        return jsopencv_from(info, _3dImage);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "reprojectImageTo3D");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_resize(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_dsize = NULL;
    Size dsize;
    Napi::Value* jsobj_fx = NULL;
    double fx=0;
    Napi::Value* jsobj_fy = NULL;
    double fy=0;
    Napi::Value* jsobj_interpolation = NULL;
    int interpolation=INTER_LINEAR;

    const char* keywords[] = { "src", "dsize", "dst", "fx", "fy", "interpolation", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOOO:resize", (char**)keywords, &jsobj_src, &jsobj_dsize, &jsobj_dst, &jsobj_fx, &jsobj_fy, &jsobj_interpolation) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_dsize, dsize, ArgInfo("dsize", 0)) &&
        jsopencv_to_safe(jsobj_fx, fx, ArgInfo("fx", 0)) &&
        jsopencv_to_safe(jsobj_fy, fy, ArgInfo("fy", 0)) &&
        jsopencv_to_safe(jsobj_interpolation, interpolation, ArgInfo("interpolation", 0)))
    {
        ERRWRAP2_NAPI(info, cv::resize(src, dst, dsize, fx, fy, interpolation));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_dsize = NULL;
    Size dsize;
    Napi::Value* jsobj_fx = NULL;
    double fx=0;
    Napi::Value* jsobj_fy = NULL;
    double fy=0;
    Napi::Value* jsobj_interpolation = NULL;
    int interpolation=INTER_LINEAR;

    const char* keywords[] = { "src", "dsize", "dst", "fx", "fy", "interpolation", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOOO:resize", (char**)keywords, &jsobj_src, &jsobj_dsize, &jsobj_dst, &jsobj_fx, &jsobj_fy, &jsobj_interpolation) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_dsize, dsize, ArgInfo("dsize", 0)) &&
        jsopencv_to_safe(jsobj_fx, fx, ArgInfo("fx", 0)) &&
        jsopencv_to_safe(jsobj_fy, fy, ArgInfo("fy", 0)) &&
        jsopencv_to_safe(jsobj_interpolation, interpolation, ArgInfo("interpolation", 0)))
    {
        ERRWRAP2_NAPI(info, cv::resize(src, dst, dsize, fx, fy, interpolation));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "resize");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_resizeWindow(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_winname = NULL;
    String winname;
    Napi::Value* jsobj_width = NULL;
    int width=0;
    Napi::Value* jsobj_height = NULL;
    int height=0;

    const char* keywords[] = { "winname", "width", "height", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:resizeWindow", (char**)keywords, &jsobj_winname, &jsobj_width, &jsobj_height) &&
        jsopencv_to_safe(jsobj_winname, winname, ArgInfo("winname", 0)) &&
        jsopencv_to_safe(jsobj_width, width, ArgInfo("width", 0)) &&
        jsopencv_to_safe(jsobj_height, height, ArgInfo("height", 0)))
    {
        ERRWRAP2_NAPI(info, cv::resizeWindow(winname, width, height));
        return info.Env().Null();;
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_winname = NULL;
    String winname;
    Napi::Value* jsobj_size = NULL;
    Size size;

    const char* keywords[] = { "winname", "size", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:resizeWindow", (char**)keywords, &jsobj_winname, &jsobj_size) &&
        jsopencv_to_safe(jsobj_winname, winname, ArgInfo("winname", 0)) &&
        jsopencv_to_safe(jsobj_size, size, ArgInfo("size", 0)))
    {
        ERRWRAP2_NAPI(info, cv::resizeWindow(winname, size));
        return info.Env().Null();;
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "resizeWindow");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_rotate(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_rotateCode = NULL;
    int rotateCode=0;

    const char* keywords[] = { "src", "rotateCode", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:rotate", (char**)keywords, &jsobj_src, &jsobj_rotateCode, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_rotateCode, rotateCode, ArgInfo("rotateCode", 0)))
    {
        ERRWRAP2_NAPI(info, cv::rotate(src, dst, rotateCode));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_rotateCode = NULL;
    int rotateCode=0;

    const char* keywords[] = { "src", "rotateCode", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:rotate", (char**)keywords, &jsobj_src, &jsobj_rotateCode, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_rotateCode, rotateCode, ArgInfo("rotateCode", 0)))
    {
        ERRWRAP2_NAPI(info, cv::rotate(src, dst, rotateCode));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "rotate");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_rotatedRectangleIntersection(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_rect1 = NULL;
    RotatedRect rect1;
    Napi::Value* jsobj_rect2 = NULL;
    RotatedRect rect2;
    Napi::Value* jsobj_intersectingRegion = NULL;
    Mat intersectingRegion;
    int retval;

    const char* keywords[] = { "rect1", "rect2", "intersectingRegion", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:rotatedRectangleIntersection", (char**)keywords, &jsobj_rect1, &jsobj_rect2, &jsobj_intersectingRegion) &&
        jsopencv_to_safe(jsobj_rect1, rect1, ArgInfo("rect1", 0)) &&
        jsopencv_to_safe(jsobj_rect2, rect2, ArgInfo("rect2", 0)) &&
        jsopencv_to_safe(jsobj_intersectingRegion, intersectingRegion, ArgInfo("intersectingRegion", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::rotatedRectangleIntersection(rect1, rect2, intersectingRegion));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, intersectingRegion));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_rect1 = NULL;
    RotatedRect rect1;
    Napi::Value* jsobj_rect2 = NULL;
    RotatedRect rect2;
    Napi::Value* jsobj_intersectingRegion = NULL;
    UMat intersectingRegion;
    int retval;

    const char* keywords[] = { "rect1", "rect2", "intersectingRegion", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:rotatedRectangleIntersection", (char**)keywords, &jsobj_rect1, &jsobj_rect2, &jsobj_intersectingRegion) &&
        jsopencv_to_safe(jsobj_rect1, rect1, ArgInfo("rect1", 0)) &&
        jsopencv_to_safe(jsobj_rect2, rect2, ArgInfo("rect2", 0)) &&
        jsopencv_to_safe(jsobj_intersectingRegion, intersectingRegion, ArgInfo("intersectingRegion", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::rotatedRectangleIntersection(rect1, rect2, intersectingRegion));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, intersectingRegion));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "rotatedRectangleIntersection");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_sampsonDistance(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_pt1 = NULL;
    Mat pt1;
    Napi::Value* jsobj_pt2 = NULL;
    Mat pt2;
    Napi::Value* jsobj_F = NULL;
    Mat F;
    double retval;

    const char* keywords[] = { "pt1", "pt2", "F", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:sampsonDistance", (char**)keywords, &jsobj_pt1, &jsobj_pt2, &jsobj_F) &&
        jsopencv_to_safe(jsobj_pt1, pt1, ArgInfo("pt1", 0)) &&
        jsopencv_to_safe(jsobj_pt2, pt2, ArgInfo("pt2", 0)) &&
        jsopencv_to_safe(jsobj_F, F, ArgInfo("F", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::sampsonDistance(pt1, pt2, F));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_pt1 = NULL;
    UMat pt1;
    Napi::Value* jsobj_pt2 = NULL;
    UMat pt2;
    Napi::Value* jsobj_F = NULL;
    UMat F;
    double retval;

    const char* keywords[] = { "pt1", "pt2", "F", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:sampsonDistance", (char**)keywords, &jsobj_pt1, &jsobj_pt2, &jsobj_F) &&
        jsopencv_to_safe(jsobj_pt1, pt1, ArgInfo("pt1", 0)) &&
        jsopencv_to_safe(jsobj_pt2, pt2, ArgInfo("pt2", 0)) &&
        jsopencv_to_safe(jsobj_F, F, ArgInfo("F", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::sampsonDistance(pt1, pt2, F));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "sampsonDistance");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_scaleAdd(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src1 = NULL;
    Mat src1;
    Napi::Value* jsobj_alpha = NULL;
    double alpha=0;
    Napi::Value* jsobj_src2 = NULL;
    Mat src2;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;

    const char* keywords[] = { "src1", "alpha", "src2", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:scaleAdd", (char**)keywords, &jsobj_src1, &jsobj_alpha, &jsobj_src2, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_alpha, alpha, ArgInfo("alpha", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)))
    {
        ERRWRAP2_NAPI(info, cv::scaleAdd(src1, alpha, src2, dst));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src1 = NULL;
    UMat src1;
    Napi::Value* jsobj_alpha = NULL;
    double alpha=0;
    Napi::Value* jsobj_src2 = NULL;
    UMat src2;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;

    const char* keywords[] = { "src1", "alpha", "src2", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:scaleAdd", (char**)keywords, &jsobj_src1, &jsobj_alpha, &jsobj_src2, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_alpha, alpha, ArgInfo("alpha", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)))
    {
        ERRWRAP2_NAPI(info, cv::scaleAdd(src1, alpha, src2, dst));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "scaleAdd");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_seamlessClone(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_mask = NULL;
    Mat mask;
    Napi::Value* jsobj_p = NULL;
    Point p;
    Napi::Value* jsobj_blend = NULL;
    Mat blend;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;

    const char* keywords[] = { "src", "dst", "mask", "p", "flags", "blend", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOO|O:seamlessClone", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_mask, &jsobj_p, &jsobj_flags, &jsobj_blend) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)) &&
        jsopencv_to_safe(jsobj_p, p, ArgInfo("p", 0)) &&
        jsopencv_to_safe(jsobj_blend, blend, ArgInfo("blend", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, cv::seamlessClone(src, dst, mask, p, blend, flags));
        return jsopencv_from(info, blend);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_mask = NULL;
    UMat mask;
    Napi::Value* jsobj_p = NULL;
    Point p;
    Napi::Value* jsobj_blend = NULL;
    UMat blend;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;

    const char* keywords[] = { "src", "dst", "mask", "p", "flags", "blend", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOO|O:seamlessClone", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_mask, &jsobj_p, &jsobj_flags, &jsobj_blend) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)) &&
        jsopencv_to_safe(jsobj_p, p, ArgInfo("p", 0)) &&
        jsopencv_to_safe(jsobj_blend, blend, ArgInfo("blend", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, cv::seamlessClone(src, dst, mask, p, blend, flags));
        return jsopencv_from(info, blend);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "seamlessClone");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_selectROI(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(4);

    {
    Napi::Value* jsobj_windowName = NULL;
    String windowName;
    Napi::Value* jsobj_img = NULL;
    Mat img;
    Napi::Value* jsobj_showCrosshair = NULL;
    bool showCrosshair=true;
    Napi::Value* jsobj_fromCenter = NULL;
    bool fromCenter=false;
    Rect retval;

    const char* keywords[] = { "windowName", "img", "showCrosshair", "fromCenter", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:selectROI", (char**)keywords, &jsobj_windowName, &jsobj_img, &jsobj_showCrosshair, &jsobj_fromCenter) &&
        jsopencv_to_safe(jsobj_windowName, windowName, ArgInfo("windowName", 0)) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 0)) &&
        jsopencv_to_safe(jsobj_showCrosshair, showCrosshair, ArgInfo("showCrosshair", 0)) &&
        jsopencv_to_safe(jsobj_fromCenter, fromCenter, ArgInfo("fromCenter", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::selectROI(windowName, img, showCrosshair, fromCenter));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_windowName = NULL;
    String windowName;
    Napi::Value* jsobj_img = NULL;
    UMat img;
    Napi::Value* jsobj_showCrosshair = NULL;
    bool showCrosshair=true;
    Napi::Value* jsobj_fromCenter = NULL;
    bool fromCenter=false;
    Rect retval;

    const char* keywords[] = { "windowName", "img", "showCrosshair", "fromCenter", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:selectROI", (char**)keywords, &jsobj_windowName, &jsobj_img, &jsobj_showCrosshair, &jsobj_fromCenter) &&
        jsopencv_to_safe(jsobj_windowName, windowName, ArgInfo("windowName", 0)) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 0)) &&
        jsopencv_to_safe(jsobj_showCrosshair, showCrosshair, ArgInfo("showCrosshair", 0)) &&
        jsopencv_to_safe(jsobj_fromCenter, fromCenter, ArgInfo("fromCenter", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::selectROI(windowName, img, showCrosshair, fromCenter));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_img = NULL;
    Mat img;
    Napi::Value* jsobj_showCrosshair = NULL;
    bool showCrosshair=true;
    Napi::Value* jsobj_fromCenter = NULL;
    bool fromCenter=false;
    Rect retval;

    const char* keywords[] = { "img", "showCrosshair", "fromCenter", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OO:selectROI", (char**)keywords, &jsobj_img, &jsobj_showCrosshair, &jsobj_fromCenter) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 0)) &&
        jsopencv_to_safe(jsobj_showCrosshair, showCrosshair, ArgInfo("showCrosshair", 0)) &&
        jsopencv_to_safe(jsobj_fromCenter, fromCenter, ArgInfo("fromCenter", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::selectROI(img, showCrosshair, fromCenter));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_img = NULL;
    UMat img;
    Napi::Value* jsobj_showCrosshair = NULL;
    bool showCrosshair=true;
    Napi::Value* jsobj_fromCenter = NULL;
    bool fromCenter=false;
    Rect retval;

    const char* keywords[] = { "img", "showCrosshair", "fromCenter", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OO:selectROI", (char**)keywords, &jsobj_img, &jsobj_showCrosshair, &jsobj_fromCenter) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 0)) &&
        jsopencv_to_safe(jsobj_showCrosshair, showCrosshair, ArgInfo("showCrosshair", 0)) &&
        jsopencv_to_safe(jsobj_fromCenter, fromCenter, ArgInfo("fromCenter", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::selectROI(img, showCrosshair, fromCenter));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "selectROI");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_selectROIs(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_windowName = NULL;
    String windowName;
    Napi::Value* jsobj_img = NULL;
    Mat img;
    vector_Rect boundingBoxes;
    Napi::Value* jsobj_showCrosshair = NULL;
    bool showCrosshair=true;
    Napi::Value* jsobj_fromCenter = NULL;
    bool fromCenter=false;

    const char* keywords[] = { "windowName", "img", "showCrosshair", "fromCenter", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:selectROIs", (char**)keywords, &jsobj_windowName, &jsobj_img, &jsobj_showCrosshair, &jsobj_fromCenter) &&
        jsopencv_to_safe(jsobj_windowName, windowName, ArgInfo("windowName", 0)) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 0)) &&
        jsopencv_to_safe(jsobj_showCrosshair, showCrosshair, ArgInfo("showCrosshair", 0)) &&
        jsopencv_to_safe(jsobj_fromCenter, fromCenter, ArgInfo("fromCenter", 0)))
    {
        ERRWRAP2_NAPI(info, cv::selectROIs(windowName, img, boundingBoxes, showCrosshair, fromCenter));
        return jsopencv_from(info, boundingBoxes);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_windowName = NULL;
    String windowName;
    Napi::Value* jsobj_img = NULL;
    UMat img;
    vector_Rect boundingBoxes;
    Napi::Value* jsobj_showCrosshair = NULL;
    bool showCrosshair=true;
    Napi::Value* jsobj_fromCenter = NULL;
    bool fromCenter=false;

    const char* keywords[] = { "windowName", "img", "showCrosshair", "fromCenter", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:selectROIs", (char**)keywords, &jsobj_windowName, &jsobj_img, &jsobj_showCrosshair, &jsobj_fromCenter) &&
        jsopencv_to_safe(jsobj_windowName, windowName, ArgInfo("windowName", 0)) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 0)) &&
        jsopencv_to_safe(jsobj_showCrosshair, showCrosshair, ArgInfo("showCrosshair", 0)) &&
        jsopencv_to_safe(jsobj_fromCenter, fromCenter, ArgInfo("fromCenter", 0)))
    {
        ERRWRAP2_NAPI(info, cv::selectROIs(windowName, img, boundingBoxes, showCrosshair, fromCenter));
        return jsopencv_from(info, boundingBoxes);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "selectROIs");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_sepFilter2D(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_ddepth = NULL;
    int ddepth=0;
    Napi::Value* jsobj_kernelX = NULL;
    Mat kernelX;
    Napi::Value* jsobj_kernelY = NULL;
    Mat kernelY;
    Napi::Value* jsobj_anchor = NULL;
    Point anchor=Point(-1,-1);
    Napi::Value* jsobj_delta = NULL;
    double delta=0;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_DEFAULT;

    const char* keywords[] = { "src", "ddepth", "kernelX", "kernelY", "dst", "anchor", "delta", "borderType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOOO:sepFilter2D", (char**)keywords, &jsobj_src, &jsobj_ddepth, &jsobj_kernelX, &jsobj_kernelY, &jsobj_dst, &jsobj_anchor, &jsobj_delta, &jsobj_borderType) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_ddepth, ddepth, ArgInfo("ddepth", 0)) &&
        jsopencv_to_safe(jsobj_kernelX, kernelX, ArgInfo("kernelX", 0)) &&
        jsopencv_to_safe(jsobj_kernelY, kernelY, ArgInfo("kernelY", 0)) &&
        jsopencv_to_safe(jsobj_anchor, anchor, ArgInfo("anchor", 0)) &&
        jsopencv_to_safe(jsobj_delta, delta, ArgInfo("delta", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)))
    {
        ERRWRAP2_NAPI(info, cv::sepFilter2D(src, dst, ddepth, kernelX, kernelY, anchor, delta, borderType));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_ddepth = NULL;
    int ddepth=0;
    Napi::Value* jsobj_kernelX = NULL;
    UMat kernelX;
    Napi::Value* jsobj_kernelY = NULL;
    UMat kernelY;
    Napi::Value* jsobj_anchor = NULL;
    Point anchor=Point(-1,-1);
    Napi::Value* jsobj_delta = NULL;
    double delta=0;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_DEFAULT;

    const char* keywords[] = { "src", "ddepth", "kernelX", "kernelY", "dst", "anchor", "delta", "borderType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOOO:sepFilter2D", (char**)keywords, &jsobj_src, &jsobj_ddepth, &jsobj_kernelX, &jsobj_kernelY, &jsobj_dst, &jsobj_anchor, &jsobj_delta, &jsobj_borderType) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_ddepth, ddepth, ArgInfo("ddepth", 0)) &&
        jsopencv_to_safe(jsobj_kernelX, kernelX, ArgInfo("kernelX", 0)) &&
        jsopencv_to_safe(jsobj_kernelY, kernelY, ArgInfo("kernelY", 0)) &&
        jsopencv_to_safe(jsobj_anchor, anchor, ArgInfo("anchor", 0)) &&
        jsopencv_to_safe(jsobj_delta, delta, ArgInfo("delta", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)))
    {
        ERRWRAP2_NAPI(info, cv::sepFilter2D(src, dst, ddepth, kernelX, kernelY, anchor, delta, borderType));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "sepFilter2D");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_setIdentity(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_mtx = NULL;
    Mat mtx;
    Napi::Value* jsobj_s = NULL;
    Scalar s=Scalar(1);

    const char* keywords[] = { "mtx", "s", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:setIdentity", (char**)keywords, &jsobj_mtx, &jsobj_s) &&
        jsopencv_to_safe(jsobj_mtx, mtx, ArgInfo("mtx", 1)) &&
        jsopencv_to_safe(jsobj_s, s, ArgInfo("s", 0)))
    {
        ERRWRAP2_NAPI(info, cv::setIdentity(mtx, s));
        return jsopencv_from(info, mtx);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_mtx = NULL;
    UMat mtx;
    Napi::Value* jsobj_s = NULL;
    Scalar s=Scalar(1);

    const char* keywords[] = { "mtx", "s", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:setIdentity", (char**)keywords, &jsobj_mtx, &jsobj_s) &&
        jsopencv_to_safe(jsobj_mtx, mtx, ArgInfo("mtx", 1)) &&
        jsopencv_to_safe(jsobj_s, s, ArgInfo("s", 0)))
    {
        ERRWRAP2_NAPI(info, cv::setIdentity(mtx, s));
        return jsopencv_from(info, mtx);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "setIdentity");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_setLogLevel(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_level = NULL;
    int level=0;
    int retval;

    const char* keywords[] = { "level", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:setLogLevel", (char**)keywords, &jsobj_level) &&
        jsopencv_to_safe(jsobj_level, level, ArgInfo("level", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::setLogLevel(level));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_setNumThreads(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_nthreads = NULL;
    int nthreads=0;

    const char* keywords[] = { "nthreads", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:setNumThreads", (char**)keywords, &jsobj_nthreads) &&
        jsopencv_to_safe(jsobj_nthreads, nthreads, ArgInfo("nthreads", 0)))
    {
        ERRWRAP2_NAPI(info, cv::setNumThreads(nthreads));
        return info.Env().Null();;
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_setRNGSeed(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_seed = NULL;
    int seed=0;

    const char* keywords[] = { "seed", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:setRNGSeed", (char**)keywords, &jsobj_seed) &&
        jsopencv_to_safe(jsobj_seed, seed, ArgInfo("seed", 0)))
    {
        ERRWRAP2_NAPI(info, cv::setRNGSeed(seed));
        return info.Env().Null();;
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_setTrackbarMax(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_trackbarname = NULL;
    String trackbarname;
    Napi::Value* jsobj_winname = NULL;
    String winname;
    Napi::Value* jsobj_maxval = NULL;
    int maxval=0;

    const char* keywords[] = { "trackbarname", "winname", "maxval", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:setTrackbarMax", (char**)keywords, &jsobj_trackbarname, &jsobj_winname, &jsobj_maxval) &&
        jsopencv_to_safe(jsobj_trackbarname, trackbarname, ArgInfo("trackbarname", 0)) &&
        jsopencv_to_safe(jsobj_winname, winname, ArgInfo("winname", 0)) &&
        jsopencv_to_safe(jsobj_maxval, maxval, ArgInfo("maxval", 0)))
    {
        ERRWRAP2_NAPI(info, cv::setTrackbarMax(trackbarname, winname, maxval));
        return info.Env().Null();;
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_setTrackbarMin(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_trackbarname = NULL;
    String trackbarname;
    Napi::Value* jsobj_winname = NULL;
    String winname;
    Napi::Value* jsobj_minval = NULL;
    int minval=0;

    const char* keywords[] = { "trackbarname", "winname", "minval", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:setTrackbarMin", (char**)keywords, &jsobj_trackbarname, &jsobj_winname, &jsobj_minval) &&
        jsopencv_to_safe(jsobj_trackbarname, trackbarname, ArgInfo("trackbarname", 0)) &&
        jsopencv_to_safe(jsobj_winname, winname, ArgInfo("winname", 0)) &&
        jsopencv_to_safe(jsobj_minval, minval, ArgInfo("minval", 0)))
    {
        ERRWRAP2_NAPI(info, cv::setTrackbarMin(trackbarname, winname, minval));
        return info.Env().Null();;
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_setTrackbarPos(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_trackbarname = NULL;
    String trackbarname;
    Napi::Value* jsobj_winname = NULL;
    String winname;
    Napi::Value* jsobj_pos = NULL;
    int pos=0;

    const char* keywords[] = { "trackbarname", "winname", "pos", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:setTrackbarPos", (char**)keywords, &jsobj_trackbarname, &jsobj_winname, &jsobj_pos) &&
        jsopencv_to_safe(jsobj_trackbarname, trackbarname, ArgInfo("trackbarname", 0)) &&
        jsopencv_to_safe(jsobj_winname, winname, ArgInfo("winname", 0)) &&
        jsopencv_to_safe(jsobj_pos, pos, ArgInfo("pos", 0)))
    {
        ERRWRAP2_NAPI(info, cv::setTrackbarPos(trackbarname, winname, pos));
        return info.Env().Null();;
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_setUseOpenVX(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_flag = NULL;
    bool flag=0;

    const char* keywords[] = { "flag", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:setUseOpenVX", (char**)keywords, &jsobj_flag) &&
        jsopencv_to_safe(jsobj_flag, flag, ArgInfo("flag", 0)))
    {
        ERRWRAP2_NAPI(info, cv::setUseOpenVX(flag));
        return info.Env().Null();;
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_setUseOptimized(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_onoff = NULL;
    bool onoff=0;

    const char* keywords[] = { "onoff", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:setUseOptimized", (char**)keywords, &jsobj_onoff) &&
        jsopencv_to_safe(jsobj_onoff, onoff, ArgInfo("onoff", 0)))
    {
        ERRWRAP2_NAPI(info, cv::setUseOptimized(onoff));
        return info.Env().Null();;
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_setWindowProperty(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_winname = NULL;
    String winname;
    Napi::Value* jsobj_prop_id = NULL;
    int prop_id=0;
    Napi::Value* jsobj_prop_value = NULL;
    double prop_value=0;

    const char* keywords[] = { "winname", "prop_id", "prop_value", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:setWindowProperty", (char**)keywords, &jsobj_winname, &jsobj_prop_id, &jsobj_prop_value) &&
        jsopencv_to_safe(jsobj_winname, winname, ArgInfo("winname", 0)) &&
        jsopencv_to_safe(jsobj_prop_id, prop_id, ArgInfo("prop_id", 0)) &&
        jsopencv_to_safe(jsobj_prop_value, prop_value, ArgInfo("prop_value", 0)))
    {
        ERRWRAP2_NAPI(info, cv::setWindowProperty(winname, prop_id, prop_value));
        return info.Env().Null();;
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_setWindowTitle(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_winname = NULL;
    String winname;
    Napi::Value* jsobj_title = NULL;
    String title;

    const char* keywords[] = { "winname", "title", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:setWindowTitle", (char**)keywords, &jsobj_winname, &jsobj_title) &&
        jsopencv_to_safe(jsobj_winname, winname, ArgInfo("winname", 0)) &&
        jsopencv_to_safe(jsobj_title, title, ArgInfo("title", 0)))
    {
        ERRWRAP2_NAPI(info, cv::setWindowTitle(winname, title));
        return info.Env().Null();;
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_solve(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src1 = NULL;
    Mat src1;
    Napi::Value* jsobj_src2 = NULL;
    Mat src2;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_flags = NULL;
    int flags=DECOMP_LU;
    bool retval;

    const char* keywords[] = { "src1", "src2", "dst", "flags", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:solve", (char**)keywords, &jsobj_src1, &jsobj_src2, &jsobj_dst, &jsobj_flags) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::solve(src1, src2, dst, flags));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, dst));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src1 = NULL;
    UMat src1;
    Napi::Value* jsobj_src2 = NULL;
    UMat src2;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_flags = NULL;
    int flags=DECOMP_LU;
    bool retval;

    const char* keywords[] = { "src1", "src2", "dst", "flags", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:solve", (char**)keywords, &jsobj_src1, &jsobj_src2, &jsobj_dst, &jsobj_flags) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::solve(src1, src2, dst, flags));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, dst));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "solve");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_solveCubic(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_coeffs = NULL;
    Mat coeffs;
    Napi::Value* jsobj_roots = NULL;
    Mat roots;
    int retval;

    const char* keywords[] = { "coeffs", "roots", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:solveCubic", (char**)keywords, &jsobj_coeffs, &jsobj_roots) &&
        jsopencv_to_safe(jsobj_coeffs, coeffs, ArgInfo("coeffs", 0)) &&
        jsopencv_to_safe(jsobj_roots, roots, ArgInfo("roots", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::solveCubic(coeffs, roots));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, roots));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_coeffs = NULL;
    UMat coeffs;
    Napi::Value* jsobj_roots = NULL;
    UMat roots;
    int retval;

    const char* keywords[] = { "coeffs", "roots", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:solveCubic", (char**)keywords, &jsobj_coeffs, &jsobj_roots) &&
        jsopencv_to_safe(jsobj_coeffs, coeffs, ArgInfo("coeffs", 0)) &&
        jsopencv_to_safe(jsobj_roots, roots, ArgInfo("roots", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::solveCubic(coeffs, roots));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, roots));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "solveCubic");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_solveLP(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_Func = NULL;
    Mat Func;
    Napi::Value* jsobj_Constr = NULL;
    Mat Constr;
    Napi::Value* jsobj_z = NULL;
    Mat z;
    int retval;

    const char* keywords[] = { "Func", "Constr", "z", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:solveLP", (char**)keywords, &jsobj_Func, &jsobj_Constr, &jsobj_z) &&
        jsopencv_to_safe(jsobj_Func, Func, ArgInfo("Func", 0)) &&
        jsopencv_to_safe(jsobj_Constr, Constr, ArgInfo("Constr", 0)) &&
        jsopencv_to_safe(jsobj_z, z, ArgInfo("z", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::solveLP(Func, Constr, z));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, z));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_Func = NULL;
    UMat Func;
    Napi::Value* jsobj_Constr = NULL;
    UMat Constr;
    Napi::Value* jsobj_z = NULL;
    UMat z;
    int retval;

    const char* keywords[] = { "Func", "Constr", "z", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:solveLP", (char**)keywords, &jsobj_Func, &jsobj_Constr, &jsobj_z) &&
        jsopencv_to_safe(jsobj_Func, Func, ArgInfo("Func", 0)) &&
        jsopencv_to_safe(jsobj_Constr, Constr, ArgInfo("Constr", 0)) &&
        jsopencv_to_safe(jsobj_z, z, ArgInfo("z", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::solveLP(Func, Constr, z));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, z));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "solveLP");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_solveP3P(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_objectPoints = NULL;
    Mat objectPoints;
    Napi::Value* jsobj_imagePoints = NULL;
    Mat imagePoints;
    Napi::Value* jsobj_cameraMatrix = NULL;
    Mat cameraMatrix;
    Napi::Value* jsobj_distCoeffs = NULL;
    Mat distCoeffs;
    Napi::Value* jsobj_rvecs = NULL;
    vector_Mat rvecs;
    Napi::Value* jsobj_tvecs = NULL;
    vector_Mat tvecs;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;
    int retval;

    const char* keywords[] = { "objectPoints", "imagePoints", "cameraMatrix", "distCoeffs", "flags", "rvecs", "tvecs", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOO|OO:solveP3P", (char**)keywords, &jsobj_objectPoints, &jsobj_imagePoints, &jsobj_cameraMatrix, &jsobj_distCoeffs, &jsobj_flags, &jsobj_rvecs, &jsobj_tvecs) &&
        jsopencv_to_safe(jsobj_objectPoints, objectPoints, ArgInfo("objectPoints", 0)) &&
        jsopencv_to_safe(jsobj_imagePoints, imagePoints, ArgInfo("imagePoints", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 0)) &&
        jsopencv_to_safe(jsobj_distCoeffs, distCoeffs, ArgInfo("distCoeffs", 0)) &&
        jsopencv_to_safe(jsobj_rvecs, rvecs, ArgInfo("rvecs", 1)) &&
        jsopencv_to_safe(jsobj_tvecs, tvecs, ArgInfo("tvecs", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::solveP3P(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvecs, tvecs, flags));
        return Js_BuildValue(info, "(NNN)", jsopencv_from(info, retval), jsopencv_from(info, rvecs), jsopencv_from(info, tvecs));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_objectPoints = NULL;
    UMat objectPoints;
    Napi::Value* jsobj_imagePoints = NULL;
    UMat imagePoints;
    Napi::Value* jsobj_cameraMatrix = NULL;
    UMat cameraMatrix;
    Napi::Value* jsobj_distCoeffs = NULL;
    UMat distCoeffs;
    Napi::Value* jsobj_rvecs = NULL;
    vector_UMat rvecs;
    Napi::Value* jsobj_tvecs = NULL;
    vector_UMat tvecs;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;
    int retval;

    const char* keywords[] = { "objectPoints", "imagePoints", "cameraMatrix", "distCoeffs", "flags", "rvecs", "tvecs", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOO|OO:solveP3P", (char**)keywords, &jsobj_objectPoints, &jsobj_imagePoints, &jsobj_cameraMatrix, &jsobj_distCoeffs, &jsobj_flags, &jsobj_rvecs, &jsobj_tvecs) &&
        jsopencv_to_safe(jsobj_objectPoints, objectPoints, ArgInfo("objectPoints", 0)) &&
        jsopencv_to_safe(jsobj_imagePoints, imagePoints, ArgInfo("imagePoints", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 0)) &&
        jsopencv_to_safe(jsobj_distCoeffs, distCoeffs, ArgInfo("distCoeffs", 0)) &&
        jsopencv_to_safe(jsobj_rvecs, rvecs, ArgInfo("rvecs", 1)) &&
        jsopencv_to_safe(jsobj_tvecs, tvecs, ArgInfo("tvecs", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::solveP3P(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvecs, tvecs, flags));
        return Js_BuildValue(info, "(NNN)", jsopencv_from(info, retval), jsopencv_from(info, rvecs), jsopencv_from(info, tvecs));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "solveP3P");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_solvePnP(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_objectPoints = NULL;
    Mat objectPoints;
    Napi::Value* jsobj_imagePoints = NULL;
    Mat imagePoints;
    Napi::Value* jsobj_cameraMatrix = NULL;
    Mat cameraMatrix;
    Napi::Value* jsobj_distCoeffs = NULL;
    Mat distCoeffs;
    Napi::Value* jsobj_rvec = NULL;
    Mat rvec;
    Napi::Value* jsobj_tvec = NULL;
    Mat tvec;
    Napi::Value* jsobj_useExtrinsicGuess = NULL;
    bool useExtrinsicGuess=false;
    Napi::Value* jsobj_flags = NULL;
    int flags=SOLVEPNP_ITERATIVE;
    bool retval;

    const char* keywords[] = { "objectPoints", "imagePoints", "cameraMatrix", "distCoeffs", "rvec", "tvec", "useExtrinsicGuess", "flags", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOOO:solvePnP", (char**)keywords, &jsobj_objectPoints, &jsobj_imagePoints, &jsobj_cameraMatrix, &jsobj_distCoeffs, &jsobj_rvec, &jsobj_tvec, &jsobj_useExtrinsicGuess, &jsobj_flags) &&
        jsopencv_to_safe(jsobj_objectPoints, objectPoints, ArgInfo("objectPoints", 0)) &&
        jsopencv_to_safe(jsobj_imagePoints, imagePoints, ArgInfo("imagePoints", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 0)) &&
        jsopencv_to_safe(jsobj_distCoeffs, distCoeffs, ArgInfo("distCoeffs", 0)) &&
        jsopencv_to_safe(jsobj_rvec, rvec, ArgInfo("rvec", 1)) &&
        jsopencv_to_safe(jsobj_tvec, tvec, ArgInfo("tvec", 1)) &&
        jsopencv_to_safe(jsobj_useExtrinsicGuess, useExtrinsicGuess, ArgInfo("useExtrinsicGuess", 0)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::solvePnP(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvec, tvec, useExtrinsicGuess, flags));
        return Js_BuildValue(info, "(NNN)", jsopencv_from(info, retval), jsopencv_from(info, rvec), jsopencv_from(info, tvec));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_objectPoints = NULL;
    UMat objectPoints;
    Napi::Value* jsobj_imagePoints = NULL;
    UMat imagePoints;
    Napi::Value* jsobj_cameraMatrix = NULL;
    UMat cameraMatrix;
    Napi::Value* jsobj_distCoeffs = NULL;
    UMat distCoeffs;
    Napi::Value* jsobj_rvec = NULL;
    UMat rvec;
    Napi::Value* jsobj_tvec = NULL;
    UMat tvec;
    Napi::Value* jsobj_useExtrinsicGuess = NULL;
    bool useExtrinsicGuess=false;
    Napi::Value* jsobj_flags = NULL;
    int flags=SOLVEPNP_ITERATIVE;
    bool retval;

    const char* keywords[] = { "objectPoints", "imagePoints", "cameraMatrix", "distCoeffs", "rvec", "tvec", "useExtrinsicGuess", "flags", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOOO:solvePnP", (char**)keywords, &jsobj_objectPoints, &jsobj_imagePoints, &jsobj_cameraMatrix, &jsobj_distCoeffs, &jsobj_rvec, &jsobj_tvec, &jsobj_useExtrinsicGuess, &jsobj_flags) &&
        jsopencv_to_safe(jsobj_objectPoints, objectPoints, ArgInfo("objectPoints", 0)) &&
        jsopencv_to_safe(jsobj_imagePoints, imagePoints, ArgInfo("imagePoints", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 0)) &&
        jsopencv_to_safe(jsobj_distCoeffs, distCoeffs, ArgInfo("distCoeffs", 0)) &&
        jsopencv_to_safe(jsobj_rvec, rvec, ArgInfo("rvec", 1)) &&
        jsopencv_to_safe(jsobj_tvec, tvec, ArgInfo("tvec", 1)) &&
        jsopencv_to_safe(jsobj_useExtrinsicGuess, useExtrinsicGuess, ArgInfo("useExtrinsicGuess", 0)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::solvePnP(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvec, tvec, useExtrinsicGuess, flags));
        return Js_BuildValue(info, "(NNN)", jsopencv_from(info, retval), jsopencv_from(info, rvec), jsopencv_from(info, tvec));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "solvePnP");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_solvePnPGeneric(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_objectPoints = NULL;
    Mat objectPoints;
    Napi::Value* jsobj_imagePoints = NULL;
    Mat imagePoints;
    Napi::Value* jsobj_cameraMatrix = NULL;
    Mat cameraMatrix;
    Napi::Value* jsobj_distCoeffs = NULL;
    Mat distCoeffs;
    Napi::Value* jsobj_rvecs = NULL;
    vector_Mat rvecs;
    Napi::Value* jsobj_tvecs = NULL;
    vector_Mat tvecs;
    Napi::Value* jsobj_useExtrinsicGuess = NULL;
    bool useExtrinsicGuess=false;
    Napi::Value* jsobj_flags = NULL;
    SolvePnPMethod flags=SOLVEPNP_ITERATIVE;
    Napi::Value* jsobj_rvec = NULL;
    Mat rvec;
    Napi::Value* jsobj_tvec = NULL;
    Mat tvec;
    Napi::Value* jsobj_reprojectionError = NULL;
    Mat reprojectionError;
    int retval;

    const char* keywords[] = { "objectPoints", "imagePoints", "cameraMatrix", "distCoeffs", "rvecs", "tvecs", "useExtrinsicGuess", "flags", "rvec", "tvec", "reprojectionError", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOOOOOO:solvePnPGeneric", (char**)keywords, &jsobj_objectPoints, &jsobj_imagePoints, &jsobj_cameraMatrix, &jsobj_distCoeffs, &jsobj_rvecs, &jsobj_tvecs, &jsobj_useExtrinsicGuess, &jsobj_flags, &jsobj_rvec, &jsobj_tvec, &jsobj_reprojectionError) &&
        jsopencv_to_safe(jsobj_objectPoints, objectPoints, ArgInfo("objectPoints", 0)) &&
        jsopencv_to_safe(jsobj_imagePoints, imagePoints, ArgInfo("imagePoints", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 0)) &&
        jsopencv_to_safe(jsobj_distCoeffs, distCoeffs, ArgInfo("distCoeffs", 0)) &&
        jsopencv_to_safe(jsobj_rvecs, rvecs, ArgInfo("rvecs", 1)) &&
        jsopencv_to_safe(jsobj_tvecs, tvecs, ArgInfo("tvecs", 1)) &&
        jsopencv_to_safe(jsobj_useExtrinsicGuess, useExtrinsicGuess, ArgInfo("useExtrinsicGuess", 0)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_rvec, rvec, ArgInfo("rvec", 0)) &&
        jsopencv_to_safe(jsobj_tvec, tvec, ArgInfo("tvec", 0)) &&
        jsopencv_to_safe(jsobj_reprojectionError, reprojectionError, ArgInfo("reprojectionError", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::solvePnPGeneric(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvecs, tvecs, useExtrinsicGuess, flags, rvec, tvec, reprojectionError));
        return Js_BuildValue(info, "(NNNN)", jsopencv_from(info, retval), jsopencv_from(info, rvecs), jsopencv_from(info, tvecs), jsopencv_from(info, reprojectionError));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_objectPoints = NULL;
    UMat objectPoints;
    Napi::Value* jsobj_imagePoints = NULL;
    UMat imagePoints;
    Napi::Value* jsobj_cameraMatrix = NULL;
    UMat cameraMatrix;
    Napi::Value* jsobj_distCoeffs = NULL;
    UMat distCoeffs;
    Napi::Value* jsobj_rvecs = NULL;
    vector_UMat rvecs;
    Napi::Value* jsobj_tvecs = NULL;
    vector_UMat tvecs;
    Napi::Value* jsobj_useExtrinsicGuess = NULL;
    bool useExtrinsicGuess=false;
    Napi::Value* jsobj_flags = NULL;
    SolvePnPMethod flags=SOLVEPNP_ITERATIVE;
    Napi::Value* jsobj_rvec = NULL;
    UMat rvec;
    Napi::Value* jsobj_tvec = NULL;
    UMat tvec;
    Napi::Value* jsobj_reprojectionError = NULL;
    UMat reprojectionError;
    int retval;

    const char* keywords[] = { "objectPoints", "imagePoints", "cameraMatrix", "distCoeffs", "rvecs", "tvecs", "useExtrinsicGuess", "flags", "rvec", "tvec", "reprojectionError", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOOOOOO:solvePnPGeneric", (char**)keywords, &jsobj_objectPoints, &jsobj_imagePoints, &jsobj_cameraMatrix, &jsobj_distCoeffs, &jsobj_rvecs, &jsobj_tvecs, &jsobj_useExtrinsicGuess, &jsobj_flags, &jsobj_rvec, &jsobj_tvec, &jsobj_reprojectionError) &&
        jsopencv_to_safe(jsobj_objectPoints, objectPoints, ArgInfo("objectPoints", 0)) &&
        jsopencv_to_safe(jsobj_imagePoints, imagePoints, ArgInfo("imagePoints", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 0)) &&
        jsopencv_to_safe(jsobj_distCoeffs, distCoeffs, ArgInfo("distCoeffs", 0)) &&
        jsopencv_to_safe(jsobj_rvecs, rvecs, ArgInfo("rvecs", 1)) &&
        jsopencv_to_safe(jsobj_tvecs, tvecs, ArgInfo("tvecs", 1)) &&
        jsopencv_to_safe(jsobj_useExtrinsicGuess, useExtrinsicGuess, ArgInfo("useExtrinsicGuess", 0)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_rvec, rvec, ArgInfo("rvec", 0)) &&
        jsopencv_to_safe(jsobj_tvec, tvec, ArgInfo("tvec", 0)) &&
        jsopencv_to_safe(jsobj_reprojectionError, reprojectionError, ArgInfo("reprojectionError", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::solvePnPGeneric(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvecs, tvecs, useExtrinsicGuess, flags, rvec, tvec, reprojectionError));
        return Js_BuildValue(info, "(NNNN)", jsopencv_from(info, retval), jsopencv_from(info, rvecs), jsopencv_from(info, tvecs), jsopencv_from(info, reprojectionError));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "solvePnPGeneric");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_solvePnPRansac(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(4);

    {
    Napi::Value* jsobj_objectPoints = NULL;
    Mat objectPoints;
    Napi::Value* jsobj_imagePoints = NULL;
    Mat imagePoints;
    Napi::Value* jsobj_cameraMatrix = NULL;
    Mat cameraMatrix;
    Napi::Value* jsobj_distCoeffs = NULL;
    Mat distCoeffs;
    Napi::Value* jsobj_rvec = NULL;
    Mat rvec;
    Napi::Value* jsobj_tvec = NULL;
    Mat tvec;
    Napi::Value* jsobj_useExtrinsicGuess = NULL;
    bool useExtrinsicGuess=false;
    Napi::Value* jsobj_iterationsCount = NULL;
    int iterationsCount=100;
    Napi::Value* jsobj_reprojectionError = NULL;
    float reprojectionError=8.0;
    Napi::Value* jsobj_confidence = NULL;
    double confidence=0.99;
    Napi::Value* jsobj_inliers = NULL;
    Mat inliers;
    Napi::Value* jsobj_flags = NULL;
    int flags=SOLVEPNP_ITERATIVE;
    bool retval;

    const char* keywords[] = { "objectPoints", "imagePoints", "cameraMatrix", "distCoeffs", "rvec", "tvec", "useExtrinsicGuess", "iterationsCount", "reprojectionError", "confidence", "inliers", "flags", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOOOOOOO:solvePnPRansac", (char**)keywords, &jsobj_objectPoints, &jsobj_imagePoints, &jsobj_cameraMatrix, &jsobj_distCoeffs, &jsobj_rvec, &jsobj_tvec, &jsobj_useExtrinsicGuess, &jsobj_iterationsCount, &jsobj_reprojectionError, &jsobj_confidence, &jsobj_inliers, &jsobj_flags) &&
        jsopencv_to_safe(jsobj_objectPoints, objectPoints, ArgInfo("objectPoints", 0)) &&
        jsopencv_to_safe(jsobj_imagePoints, imagePoints, ArgInfo("imagePoints", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 0)) &&
        jsopencv_to_safe(jsobj_distCoeffs, distCoeffs, ArgInfo("distCoeffs", 0)) &&
        jsopencv_to_safe(jsobj_rvec, rvec, ArgInfo("rvec", 1)) &&
        jsopencv_to_safe(jsobj_tvec, tvec, ArgInfo("tvec", 1)) &&
        jsopencv_to_safe(jsobj_useExtrinsicGuess, useExtrinsicGuess, ArgInfo("useExtrinsicGuess", 0)) &&
        jsopencv_to_safe(jsobj_iterationsCount, iterationsCount, ArgInfo("iterationsCount", 0)) &&
        jsopencv_to_safe(jsobj_reprojectionError, reprojectionError, ArgInfo("reprojectionError", 0)) &&
        jsopencv_to_safe(jsobj_confidence, confidence, ArgInfo("confidence", 0)) &&
        jsopencv_to_safe(jsobj_inliers, inliers, ArgInfo("inliers", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::solvePnPRansac(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvec, tvec, useExtrinsicGuess, iterationsCount, reprojectionError, confidence, inliers, flags));
        return Js_BuildValue(info, "(NNNN)", jsopencv_from(info, retval), jsopencv_from(info, rvec), jsopencv_from(info, tvec), jsopencv_from(info, inliers));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_objectPoints = NULL;
    UMat objectPoints;
    Napi::Value* jsobj_imagePoints = NULL;
    UMat imagePoints;
    Napi::Value* jsobj_cameraMatrix = NULL;
    UMat cameraMatrix;
    Napi::Value* jsobj_distCoeffs = NULL;
    UMat distCoeffs;
    Napi::Value* jsobj_rvec = NULL;
    UMat rvec;
    Napi::Value* jsobj_tvec = NULL;
    UMat tvec;
    Napi::Value* jsobj_useExtrinsicGuess = NULL;
    bool useExtrinsicGuess=false;
    Napi::Value* jsobj_iterationsCount = NULL;
    int iterationsCount=100;
    Napi::Value* jsobj_reprojectionError = NULL;
    float reprojectionError=8.0;
    Napi::Value* jsobj_confidence = NULL;
    double confidence=0.99;
    Napi::Value* jsobj_inliers = NULL;
    UMat inliers;
    Napi::Value* jsobj_flags = NULL;
    int flags=SOLVEPNP_ITERATIVE;
    bool retval;

    const char* keywords[] = { "objectPoints", "imagePoints", "cameraMatrix", "distCoeffs", "rvec", "tvec", "useExtrinsicGuess", "iterationsCount", "reprojectionError", "confidence", "inliers", "flags", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOOOOOOO:solvePnPRansac", (char**)keywords, &jsobj_objectPoints, &jsobj_imagePoints, &jsobj_cameraMatrix, &jsobj_distCoeffs, &jsobj_rvec, &jsobj_tvec, &jsobj_useExtrinsicGuess, &jsobj_iterationsCount, &jsobj_reprojectionError, &jsobj_confidence, &jsobj_inliers, &jsobj_flags) &&
        jsopencv_to_safe(jsobj_objectPoints, objectPoints, ArgInfo("objectPoints", 0)) &&
        jsopencv_to_safe(jsobj_imagePoints, imagePoints, ArgInfo("imagePoints", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 0)) &&
        jsopencv_to_safe(jsobj_distCoeffs, distCoeffs, ArgInfo("distCoeffs", 0)) &&
        jsopencv_to_safe(jsobj_rvec, rvec, ArgInfo("rvec", 1)) &&
        jsopencv_to_safe(jsobj_tvec, tvec, ArgInfo("tvec", 1)) &&
        jsopencv_to_safe(jsobj_useExtrinsicGuess, useExtrinsicGuess, ArgInfo("useExtrinsicGuess", 0)) &&
        jsopencv_to_safe(jsobj_iterationsCount, iterationsCount, ArgInfo("iterationsCount", 0)) &&
        jsopencv_to_safe(jsobj_reprojectionError, reprojectionError, ArgInfo("reprojectionError", 0)) &&
        jsopencv_to_safe(jsobj_confidence, confidence, ArgInfo("confidence", 0)) &&
        jsopencv_to_safe(jsobj_inliers, inliers, ArgInfo("inliers", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::solvePnPRansac(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvec, tvec, useExtrinsicGuess, iterationsCount, reprojectionError, confidence, inliers, flags));
        return Js_BuildValue(info, "(NNNN)", jsopencv_from(info, retval), jsopencv_from(info, rvec), jsopencv_from(info, tvec), jsopencv_from(info, inliers));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_objectPoints = NULL;
    Mat objectPoints;
    Napi::Value* jsobj_imagePoints = NULL;
    Mat imagePoints;
    Napi::Value* jsobj_cameraMatrix = NULL;
    Mat cameraMatrix;
    Napi::Value* jsobj_distCoeffs = NULL;
    Mat distCoeffs;
    Napi::Value* jsobj_rvec = NULL;
    Mat rvec;
    Napi::Value* jsobj_tvec = NULL;
    Mat tvec;
    Napi::Value* jsobj_inliers = NULL;
    Mat inliers;
    Napi::Value* jsobj_params = NULL;
    cv::UsacParams params;
    bool retval;

    const char* keywords[] = { "objectPoints", "imagePoints", "cameraMatrix", "distCoeffs", "rvec", "tvec", "inliers", "params", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOOO:solvePnPRansac", (char**)keywords, &jsobj_objectPoints, &jsobj_imagePoints, &jsobj_cameraMatrix, &jsobj_distCoeffs, &jsobj_rvec, &jsobj_tvec, &jsobj_inliers, &jsobj_params) &&
        jsopencv_to_safe(jsobj_objectPoints, objectPoints, ArgInfo("objectPoints", 0)) &&
        jsopencv_to_safe(jsobj_imagePoints, imagePoints, ArgInfo("imagePoints", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 1)) &&
        jsopencv_to_safe(jsobj_distCoeffs, distCoeffs, ArgInfo("distCoeffs", 0)) &&
        jsopencv_to_safe(jsobj_rvec, rvec, ArgInfo("rvec", 1)) &&
        jsopencv_to_safe(jsobj_tvec, tvec, ArgInfo("tvec", 1)) &&
        jsopencv_to_safe(jsobj_inliers, inliers, ArgInfo("inliers", 1)) &&
        jsopencv_to_safe(jsobj_params, params, ArgInfo("params", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::solvePnPRansac(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvec, tvec, inliers, params));
        return Js_BuildValue(info, "(NNNNN)", jsopencv_from(info, retval), jsopencv_from(info, cameraMatrix), jsopencv_from(info, rvec), jsopencv_from(info, tvec), jsopencv_from(info, inliers));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_objectPoints = NULL;
    UMat objectPoints;
    Napi::Value* jsobj_imagePoints = NULL;
    UMat imagePoints;
    Napi::Value* jsobj_cameraMatrix = NULL;
    UMat cameraMatrix;
    Napi::Value* jsobj_distCoeffs = NULL;
    UMat distCoeffs;
    Napi::Value* jsobj_rvec = NULL;
    UMat rvec;
    Napi::Value* jsobj_tvec = NULL;
    UMat tvec;
    Napi::Value* jsobj_inliers = NULL;
    UMat inliers;
    Napi::Value* jsobj_params = NULL;
    cv::UsacParams params;
    bool retval;

    const char* keywords[] = { "objectPoints", "imagePoints", "cameraMatrix", "distCoeffs", "rvec", "tvec", "inliers", "params", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOOO:solvePnPRansac", (char**)keywords, &jsobj_objectPoints, &jsobj_imagePoints, &jsobj_cameraMatrix, &jsobj_distCoeffs, &jsobj_rvec, &jsobj_tvec, &jsobj_inliers, &jsobj_params) &&
        jsopencv_to_safe(jsobj_objectPoints, objectPoints, ArgInfo("objectPoints", 0)) &&
        jsopencv_to_safe(jsobj_imagePoints, imagePoints, ArgInfo("imagePoints", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 1)) &&
        jsopencv_to_safe(jsobj_distCoeffs, distCoeffs, ArgInfo("distCoeffs", 0)) &&
        jsopencv_to_safe(jsobj_rvec, rvec, ArgInfo("rvec", 1)) &&
        jsopencv_to_safe(jsobj_tvec, tvec, ArgInfo("tvec", 1)) &&
        jsopencv_to_safe(jsobj_inliers, inliers, ArgInfo("inliers", 1)) &&
        jsopencv_to_safe(jsobj_params, params, ArgInfo("params", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::solvePnPRansac(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvec, tvec, inliers, params));
        return Js_BuildValue(info, "(NNNNN)", jsopencv_from(info, retval), jsopencv_from(info, cameraMatrix), jsopencv_from(info, rvec), jsopencv_from(info, tvec), jsopencv_from(info, inliers));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "solvePnPRansac");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_solvePnPRefineLM(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_objectPoints = NULL;
    Mat objectPoints;
    Napi::Value* jsobj_imagePoints = NULL;
    Mat imagePoints;
    Napi::Value* jsobj_cameraMatrix = NULL;
    Mat cameraMatrix;
    Napi::Value* jsobj_distCoeffs = NULL;
    Mat distCoeffs;
    Napi::Value* jsobj_rvec = NULL;
    Mat rvec;
    Napi::Value* jsobj_tvec = NULL;
    Mat tvec;
    Napi::Value* jsobj_criteria = NULL;
    TermCriteria criteria=TermCriteria(TermCriteria::EPS + TermCriteria::COUNT, 20, FLT_EPSILON);

    const char* keywords[] = { "objectPoints", "imagePoints", "cameraMatrix", "distCoeffs", "rvec", "tvec", "criteria", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOO|O:solvePnPRefineLM", (char**)keywords, &jsobj_objectPoints, &jsobj_imagePoints, &jsobj_cameraMatrix, &jsobj_distCoeffs, &jsobj_rvec, &jsobj_tvec, &jsobj_criteria) &&
        jsopencv_to_safe(jsobj_objectPoints, objectPoints, ArgInfo("objectPoints", 0)) &&
        jsopencv_to_safe(jsobj_imagePoints, imagePoints, ArgInfo("imagePoints", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 0)) &&
        jsopencv_to_safe(jsobj_distCoeffs, distCoeffs, ArgInfo("distCoeffs", 0)) &&
        jsopencv_to_safe(jsobj_rvec, rvec, ArgInfo("rvec", 1)) &&
        jsopencv_to_safe(jsobj_tvec, tvec, ArgInfo("tvec", 1)) &&
        jsopencv_to_safe(jsobj_criteria, criteria, ArgInfo("criteria", 0)))
    {
        ERRWRAP2_NAPI(info, cv::solvePnPRefineLM(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvec, tvec, criteria));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, rvec), jsopencv_from(info, tvec));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_objectPoints = NULL;
    UMat objectPoints;
    Napi::Value* jsobj_imagePoints = NULL;
    UMat imagePoints;
    Napi::Value* jsobj_cameraMatrix = NULL;
    UMat cameraMatrix;
    Napi::Value* jsobj_distCoeffs = NULL;
    UMat distCoeffs;
    Napi::Value* jsobj_rvec = NULL;
    UMat rvec;
    Napi::Value* jsobj_tvec = NULL;
    UMat tvec;
    Napi::Value* jsobj_criteria = NULL;
    TermCriteria criteria=TermCriteria(TermCriteria::EPS + TermCriteria::COUNT, 20, FLT_EPSILON);

    const char* keywords[] = { "objectPoints", "imagePoints", "cameraMatrix", "distCoeffs", "rvec", "tvec", "criteria", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOO|O:solvePnPRefineLM", (char**)keywords, &jsobj_objectPoints, &jsobj_imagePoints, &jsobj_cameraMatrix, &jsobj_distCoeffs, &jsobj_rvec, &jsobj_tvec, &jsobj_criteria) &&
        jsopencv_to_safe(jsobj_objectPoints, objectPoints, ArgInfo("objectPoints", 0)) &&
        jsopencv_to_safe(jsobj_imagePoints, imagePoints, ArgInfo("imagePoints", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 0)) &&
        jsopencv_to_safe(jsobj_distCoeffs, distCoeffs, ArgInfo("distCoeffs", 0)) &&
        jsopencv_to_safe(jsobj_rvec, rvec, ArgInfo("rvec", 1)) &&
        jsopencv_to_safe(jsobj_tvec, tvec, ArgInfo("tvec", 1)) &&
        jsopencv_to_safe(jsobj_criteria, criteria, ArgInfo("criteria", 0)))
    {
        ERRWRAP2_NAPI(info, cv::solvePnPRefineLM(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvec, tvec, criteria));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, rvec), jsopencv_from(info, tvec));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "solvePnPRefineLM");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_solvePnPRefineVVS(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_objectPoints = NULL;
    Mat objectPoints;
    Napi::Value* jsobj_imagePoints = NULL;
    Mat imagePoints;
    Napi::Value* jsobj_cameraMatrix = NULL;
    Mat cameraMatrix;
    Napi::Value* jsobj_distCoeffs = NULL;
    Mat distCoeffs;
    Napi::Value* jsobj_rvec = NULL;
    Mat rvec;
    Napi::Value* jsobj_tvec = NULL;
    Mat tvec;
    Napi::Value* jsobj_criteria = NULL;
    TermCriteria criteria=TermCriteria(TermCriteria::EPS + TermCriteria::COUNT, 20, FLT_EPSILON);
    Napi::Value* jsobj_VVSlambda = NULL;
    double VVSlambda=1;

    const char* keywords[] = { "objectPoints", "imagePoints", "cameraMatrix", "distCoeffs", "rvec", "tvec", "criteria", "VVSlambda", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOO|OO:solvePnPRefineVVS", (char**)keywords, &jsobj_objectPoints, &jsobj_imagePoints, &jsobj_cameraMatrix, &jsobj_distCoeffs, &jsobj_rvec, &jsobj_tvec, &jsobj_criteria, &jsobj_VVSlambda) &&
        jsopencv_to_safe(jsobj_objectPoints, objectPoints, ArgInfo("objectPoints", 0)) &&
        jsopencv_to_safe(jsobj_imagePoints, imagePoints, ArgInfo("imagePoints", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 0)) &&
        jsopencv_to_safe(jsobj_distCoeffs, distCoeffs, ArgInfo("distCoeffs", 0)) &&
        jsopencv_to_safe(jsobj_rvec, rvec, ArgInfo("rvec", 1)) &&
        jsopencv_to_safe(jsobj_tvec, tvec, ArgInfo("tvec", 1)) &&
        jsopencv_to_safe(jsobj_criteria, criteria, ArgInfo("criteria", 0)) &&
        jsopencv_to_safe(jsobj_VVSlambda, VVSlambda, ArgInfo("VVSlambda", 0)))
    {
        ERRWRAP2_NAPI(info, cv::solvePnPRefineVVS(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvec, tvec, criteria, VVSlambda));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, rvec), jsopencv_from(info, tvec));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_objectPoints = NULL;
    UMat objectPoints;
    Napi::Value* jsobj_imagePoints = NULL;
    UMat imagePoints;
    Napi::Value* jsobj_cameraMatrix = NULL;
    UMat cameraMatrix;
    Napi::Value* jsobj_distCoeffs = NULL;
    UMat distCoeffs;
    Napi::Value* jsobj_rvec = NULL;
    UMat rvec;
    Napi::Value* jsobj_tvec = NULL;
    UMat tvec;
    Napi::Value* jsobj_criteria = NULL;
    TermCriteria criteria=TermCriteria(TermCriteria::EPS + TermCriteria::COUNT, 20, FLT_EPSILON);
    Napi::Value* jsobj_VVSlambda = NULL;
    double VVSlambda=1;

    const char* keywords[] = { "objectPoints", "imagePoints", "cameraMatrix", "distCoeffs", "rvec", "tvec", "criteria", "VVSlambda", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOO|OO:solvePnPRefineVVS", (char**)keywords, &jsobj_objectPoints, &jsobj_imagePoints, &jsobj_cameraMatrix, &jsobj_distCoeffs, &jsobj_rvec, &jsobj_tvec, &jsobj_criteria, &jsobj_VVSlambda) &&
        jsopencv_to_safe(jsobj_objectPoints, objectPoints, ArgInfo("objectPoints", 0)) &&
        jsopencv_to_safe(jsobj_imagePoints, imagePoints, ArgInfo("imagePoints", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 0)) &&
        jsopencv_to_safe(jsobj_distCoeffs, distCoeffs, ArgInfo("distCoeffs", 0)) &&
        jsopencv_to_safe(jsobj_rvec, rvec, ArgInfo("rvec", 1)) &&
        jsopencv_to_safe(jsobj_tvec, tvec, ArgInfo("tvec", 1)) &&
        jsopencv_to_safe(jsobj_criteria, criteria, ArgInfo("criteria", 0)) &&
        jsopencv_to_safe(jsobj_VVSlambda, VVSlambda, ArgInfo("VVSlambda", 0)))
    {
        ERRWRAP2_NAPI(info, cv::solvePnPRefineVVS(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvec, tvec, criteria, VVSlambda));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, rvec), jsopencv_from(info, tvec));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "solvePnPRefineVVS");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_solvePoly(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_coeffs = NULL;
    Mat coeffs;
    Napi::Value* jsobj_roots = NULL;
    Mat roots;
    Napi::Value* jsobj_maxIters = NULL;
    int maxIters=300;
    double retval;

    const char* keywords[] = { "coeffs", "roots", "maxIters", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OO:solvePoly", (char**)keywords, &jsobj_coeffs, &jsobj_roots, &jsobj_maxIters) &&
        jsopencv_to_safe(jsobj_coeffs, coeffs, ArgInfo("coeffs", 0)) &&
        jsopencv_to_safe(jsobj_roots, roots, ArgInfo("roots", 1)) &&
        jsopencv_to_safe(jsobj_maxIters, maxIters, ArgInfo("maxIters", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::solvePoly(coeffs, roots, maxIters));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, roots));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_coeffs = NULL;
    UMat coeffs;
    Napi::Value* jsobj_roots = NULL;
    UMat roots;
    Napi::Value* jsobj_maxIters = NULL;
    int maxIters=300;
    double retval;

    const char* keywords[] = { "coeffs", "roots", "maxIters", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OO:solvePoly", (char**)keywords, &jsobj_coeffs, &jsobj_roots, &jsobj_maxIters) &&
        jsopencv_to_safe(jsobj_coeffs, coeffs, ArgInfo("coeffs", 0)) &&
        jsopencv_to_safe(jsobj_roots, roots, ArgInfo("roots", 1)) &&
        jsopencv_to_safe(jsobj_maxIters, maxIters, ArgInfo("maxIters", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::solvePoly(coeffs, roots, maxIters));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, roots));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "solvePoly");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_sort(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;

    const char* keywords[] = { "src", "flags", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:sort", (char**)keywords, &jsobj_src, &jsobj_flags, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, cv::sort(src, dst, flags));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;

    const char* keywords[] = { "src", "flags", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:sort", (char**)keywords, &jsobj_src, &jsobj_flags, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, cv::sort(src, dst, flags));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "sort");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_sortIdx(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;

    const char* keywords[] = { "src", "flags", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:sortIdx", (char**)keywords, &jsobj_src, &jsobj_flags, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, cv::sortIdx(src, dst, flags));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;

    const char* keywords[] = { "src", "flags", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:sortIdx", (char**)keywords, &jsobj_src, &jsobj_flags, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, cv::sortIdx(src, dst, flags));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "sortIdx");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_spatialGradient(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dx = NULL;
    Mat dx;
    Napi::Value* jsobj_dy = NULL;
    Mat dy;
    Napi::Value* jsobj_ksize = NULL;
    int ksize=3;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_DEFAULT;

    const char* keywords[] = { "src", "dx", "dy", "ksize", "borderType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOOO:spatialGradient", (char**)keywords, &jsobj_src, &jsobj_dx, &jsobj_dy, &jsobj_ksize, &jsobj_borderType) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dx, dx, ArgInfo("dx", 1)) &&
        jsopencv_to_safe(jsobj_dy, dy, ArgInfo("dy", 1)) &&
        jsopencv_to_safe(jsobj_ksize, ksize, ArgInfo("ksize", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)))
    {
        ERRWRAP2_NAPI(info, cv::spatialGradient(src, dx, dy, ksize, borderType));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, dx), jsopencv_from(info, dy));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dx = NULL;
    UMat dx;
    Napi::Value* jsobj_dy = NULL;
    UMat dy;
    Napi::Value* jsobj_ksize = NULL;
    int ksize=3;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_DEFAULT;

    const char* keywords[] = { "src", "dx", "dy", "ksize", "borderType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOOO:spatialGradient", (char**)keywords, &jsobj_src, &jsobj_dx, &jsobj_dy, &jsobj_ksize, &jsobj_borderType) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dx, dx, ArgInfo("dx", 1)) &&
        jsopencv_to_safe(jsobj_dy, dy, ArgInfo("dy", 1)) &&
        jsopencv_to_safe(jsobj_ksize, ksize, ArgInfo("ksize", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)))
    {
        ERRWRAP2_NAPI(info, cv::spatialGradient(src, dx, dy, ksize, borderType));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, dx), jsopencv_from(info, dy));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "spatialGradient");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_split(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_m = NULL;
    Mat m;
    Napi::Value* jsobj_mv = NULL;
    vector_Mat mv;

    const char* keywords[] = { "m", "mv", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:split", (char**)keywords, &jsobj_m, &jsobj_mv) &&
        jsopencv_to_safe(jsobj_m, m, ArgInfo("m", 0)) &&
        jsopencv_to_safe(jsobj_mv, mv, ArgInfo("mv", 1)))
    {
        ERRWRAP2_NAPI(info, cv::split(m, mv));
        return jsopencv_from(info, mv);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_m = NULL;
    UMat m;
    Napi::Value* jsobj_mv = NULL;
    vector_UMat mv;

    const char* keywords[] = { "m", "mv", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:split", (char**)keywords, &jsobj_m, &jsobj_mv) &&
        jsopencv_to_safe(jsobj_m, m, ArgInfo("m", 0)) &&
        jsopencv_to_safe(jsobj_mv, mv, ArgInfo("mv", 1)))
    {
        ERRWRAP2_NAPI(info, cv::split(m, mv));
        return jsopencv_from(info, mv);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "split");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_sqrBoxFilter(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_ddepth = NULL;
    int ddepth=0;
    Napi::Value* jsobj_ksize = NULL;
    Size ksize;
    Napi::Value* jsobj_anchor = NULL;
    Point anchor=Point(-1, -1);
    Napi::Value* jsobj_normalize = NULL;
    bool normalize=true;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_DEFAULT;

    const char* keywords[] = { "src", "ddepth", "ksize", "dst", "anchor", "normalize", "borderType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOOO:sqrBoxFilter", (char**)keywords, &jsobj_src, &jsobj_ddepth, &jsobj_ksize, &jsobj_dst, &jsobj_anchor, &jsobj_normalize, &jsobj_borderType) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_ddepth, ddepth, ArgInfo("ddepth", 0)) &&
        jsopencv_to_safe(jsobj_ksize, ksize, ArgInfo("ksize", 0)) &&
        jsopencv_to_safe(jsobj_anchor, anchor, ArgInfo("anchor", 0)) &&
        jsopencv_to_safe(jsobj_normalize, normalize, ArgInfo("normalize", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)))
    {
        ERRWRAP2_NAPI(info, cv::sqrBoxFilter(src, dst, ddepth, ksize, anchor, normalize, borderType));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_ddepth = NULL;
    int ddepth=0;
    Napi::Value* jsobj_ksize = NULL;
    Size ksize;
    Napi::Value* jsobj_anchor = NULL;
    Point anchor=Point(-1, -1);
    Napi::Value* jsobj_normalize = NULL;
    bool normalize=true;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_DEFAULT;

    const char* keywords[] = { "src", "ddepth", "ksize", "dst", "anchor", "normalize", "borderType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOOO:sqrBoxFilter", (char**)keywords, &jsobj_src, &jsobj_ddepth, &jsobj_ksize, &jsobj_dst, &jsobj_anchor, &jsobj_normalize, &jsobj_borderType) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_ddepth, ddepth, ArgInfo("ddepth", 0)) &&
        jsopencv_to_safe(jsobj_ksize, ksize, ArgInfo("ksize", 0)) &&
        jsopencv_to_safe(jsobj_anchor, anchor, ArgInfo("anchor", 0)) &&
        jsopencv_to_safe(jsobj_normalize, normalize, ArgInfo("normalize", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)))
    {
        ERRWRAP2_NAPI(info, cv::sqrBoxFilter(src, dst, ddepth, ksize, anchor, normalize, borderType));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "sqrBoxFilter");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_sqrt(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;

    const char* keywords[] = { "src", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:sqrt", (char**)keywords, &jsobj_src, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)))
    {
        ERRWRAP2_NAPI(info, cv::sqrt(src, dst));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;

    const char* keywords[] = { "src", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:sqrt", (char**)keywords, &jsobj_src, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)))
    {
        ERRWRAP2_NAPI(info, cv::sqrt(src, dst));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "sqrt");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_stackBlur(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_ksize = NULL;
    Size ksize;

    const char* keywords[] = { "src", "ksize", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:stackBlur", (char**)keywords, &jsobj_src, &jsobj_ksize, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_ksize, ksize, ArgInfo("ksize", 0)))
    {
        ERRWRAP2_NAPI(info, cv::stackBlur(src, dst, ksize));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_ksize = NULL;
    Size ksize;

    const char* keywords[] = { "src", "ksize", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:stackBlur", (char**)keywords, &jsobj_src, &jsobj_ksize, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_ksize, ksize, ArgInfo("ksize", 0)))
    {
        ERRWRAP2_NAPI(info, cv::stackBlur(src, dst, ksize));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "stackBlur");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_startWindowThread(const Napi::CallbackInfo &info)
{
    using namespace cv;

    int retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::startWindowThread());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_stereoCalibrate(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(4);

    {
    Napi::Value* jsobj_objectPoints = NULL;
    vector_Mat objectPoints;
    Napi::Value* jsobj_imagePoints1 = NULL;
    vector_Mat imagePoints1;
    Napi::Value* jsobj_imagePoints2 = NULL;
    vector_Mat imagePoints2;
    Napi::Value* jsobj_cameraMatrix1 = NULL;
    Mat cameraMatrix1;
    Napi::Value* jsobj_distCoeffs1 = NULL;
    Mat distCoeffs1;
    Napi::Value* jsobj_cameraMatrix2 = NULL;
    Mat cameraMatrix2;
    Napi::Value* jsobj_distCoeffs2 = NULL;
    Mat distCoeffs2;
    Napi::Value* jsobj_imageSize = NULL;
    Size imageSize;
    Napi::Value* jsobj_R = NULL;
    Mat R;
    Napi::Value* jsobj_T = NULL;
    Mat T;
    Napi::Value* jsobj_E = NULL;
    Mat E;
    Napi::Value* jsobj_F = NULL;
    Mat F;
    Napi::Value* jsobj_flags = NULL;
    int flags=CALIB_FIX_INTRINSIC;
    Napi::Value* jsobj_criteria = NULL;
    TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6);
    double retval;

    const char* keywords[] = { "objectPoints", "imagePoints1", "imagePoints2", "cameraMatrix1", "distCoeffs1", "cameraMatrix2", "distCoeffs2", "imageSize", "R", "T", "E", "F", "flags", "criteria", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOOOO|OOOOOO:stereoCalibrate", (char**)keywords, &jsobj_objectPoints, &jsobj_imagePoints1, &jsobj_imagePoints2, &jsobj_cameraMatrix1, &jsobj_distCoeffs1, &jsobj_cameraMatrix2, &jsobj_distCoeffs2, &jsobj_imageSize, &jsobj_R, &jsobj_T, &jsobj_E, &jsobj_F, &jsobj_flags, &jsobj_criteria) &&
        jsopencv_to_safe(jsobj_objectPoints, objectPoints, ArgInfo("objectPoints", 0)) &&
        jsopencv_to_safe(jsobj_imagePoints1, imagePoints1, ArgInfo("imagePoints1", 0)) &&
        jsopencv_to_safe(jsobj_imagePoints2, imagePoints2, ArgInfo("imagePoints2", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix1, cameraMatrix1, ArgInfo("cameraMatrix1", 1)) &&
        jsopencv_to_safe(jsobj_distCoeffs1, distCoeffs1, ArgInfo("distCoeffs1", 1)) &&
        jsopencv_to_safe(jsobj_cameraMatrix2, cameraMatrix2, ArgInfo("cameraMatrix2", 1)) &&
        jsopencv_to_safe(jsobj_distCoeffs2, distCoeffs2, ArgInfo("distCoeffs2", 1)) &&
        jsopencv_to_safe(jsobj_imageSize, imageSize, ArgInfo("imageSize", 0)) &&
        jsopencv_to_safe(jsobj_R, R, ArgInfo("R", 1)) &&
        jsopencv_to_safe(jsobj_T, T, ArgInfo("T", 1)) &&
        jsopencv_to_safe(jsobj_E, E, ArgInfo("E", 1)) &&
        jsopencv_to_safe(jsobj_F, F, ArgInfo("F", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_criteria, criteria, ArgInfo("criteria", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::stereoCalibrate(objectPoints, imagePoints1, imagePoints2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, imageSize, R, T, E, F, flags, criteria));
        return Js_BuildValue(info, "(NNNNNNNNN)", jsopencv_from(info, retval), jsopencv_from(info, cameraMatrix1), jsopencv_from(info, distCoeffs1), jsopencv_from(info, cameraMatrix2), jsopencv_from(info, distCoeffs2), jsopencv_from(info, R), jsopencv_from(info, T), jsopencv_from(info, E), jsopencv_from(info, F));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_objectPoints = NULL;
    vector_UMat objectPoints;
    Napi::Value* jsobj_imagePoints1 = NULL;
    vector_UMat imagePoints1;
    Napi::Value* jsobj_imagePoints2 = NULL;
    vector_UMat imagePoints2;
    Napi::Value* jsobj_cameraMatrix1 = NULL;
    UMat cameraMatrix1;
    Napi::Value* jsobj_distCoeffs1 = NULL;
    UMat distCoeffs1;
    Napi::Value* jsobj_cameraMatrix2 = NULL;
    UMat cameraMatrix2;
    Napi::Value* jsobj_distCoeffs2 = NULL;
    UMat distCoeffs2;
    Napi::Value* jsobj_imageSize = NULL;
    Size imageSize;
    Napi::Value* jsobj_R = NULL;
    UMat R;
    Napi::Value* jsobj_T = NULL;
    UMat T;
    Napi::Value* jsobj_E = NULL;
    UMat E;
    Napi::Value* jsobj_F = NULL;
    UMat F;
    Napi::Value* jsobj_flags = NULL;
    int flags=CALIB_FIX_INTRINSIC;
    Napi::Value* jsobj_criteria = NULL;
    TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6);
    double retval;

    const char* keywords[] = { "objectPoints", "imagePoints1", "imagePoints2", "cameraMatrix1", "distCoeffs1", "cameraMatrix2", "distCoeffs2", "imageSize", "R", "T", "E", "F", "flags", "criteria", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOOOO|OOOOOO:stereoCalibrate", (char**)keywords, &jsobj_objectPoints, &jsobj_imagePoints1, &jsobj_imagePoints2, &jsobj_cameraMatrix1, &jsobj_distCoeffs1, &jsobj_cameraMatrix2, &jsobj_distCoeffs2, &jsobj_imageSize, &jsobj_R, &jsobj_T, &jsobj_E, &jsobj_F, &jsobj_flags, &jsobj_criteria) &&
        jsopencv_to_safe(jsobj_objectPoints, objectPoints, ArgInfo("objectPoints", 0)) &&
        jsopencv_to_safe(jsobj_imagePoints1, imagePoints1, ArgInfo("imagePoints1", 0)) &&
        jsopencv_to_safe(jsobj_imagePoints2, imagePoints2, ArgInfo("imagePoints2", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix1, cameraMatrix1, ArgInfo("cameraMatrix1", 1)) &&
        jsopencv_to_safe(jsobj_distCoeffs1, distCoeffs1, ArgInfo("distCoeffs1", 1)) &&
        jsopencv_to_safe(jsobj_cameraMatrix2, cameraMatrix2, ArgInfo("cameraMatrix2", 1)) &&
        jsopencv_to_safe(jsobj_distCoeffs2, distCoeffs2, ArgInfo("distCoeffs2", 1)) &&
        jsopencv_to_safe(jsobj_imageSize, imageSize, ArgInfo("imageSize", 0)) &&
        jsopencv_to_safe(jsobj_R, R, ArgInfo("R", 1)) &&
        jsopencv_to_safe(jsobj_T, T, ArgInfo("T", 1)) &&
        jsopencv_to_safe(jsobj_E, E, ArgInfo("E", 1)) &&
        jsopencv_to_safe(jsobj_F, F, ArgInfo("F", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_criteria, criteria, ArgInfo("criteria", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::stereoCalibrate(objectPoints, imagePoints1, imagePoints2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, imageSize, R, T, E, F, flags, criteria));
        return Js_BuildValue(info, "(NNNNNNNNN)", jsopencv_from(info, retval), jsopencv_from(info, cameraMatrix1), jsopencv_from(info, distCoeffs1), jsopencv_from(info, cameraMatrix2), jsopencv_from(info, distCoeffs2), jsopencv_from(info, R), jsopencv_from(info, T), jsopencv_from(info, E), jsopencv_from(info, F));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_objectPoints = NULL;
    vector_Mat objectPoints;
    Napi::Value* jsobj_imagePoints1 = NULL;
    vector_Mat imagePoints1;
    Napi::Value* jsobj_imagePoints2 = NULL;
    vector_Mat imagePoints2;
    Napi::Value* jsobj_cameraMatrix1 = NULL;
    Mat cameraMatrix1;
    Napi::Value* jsobj_distCoeffs1 = NULL;
    Mat distCoeffs1;
    Napi::Value* jsobj_cameraMatrix2 = NULL;
    Mat cameraMatrix2;
    Napi::Value* jsobj_distCoeffs2 = NULL;
    Mat distCoeffs2;
    Napi::Value* jsobj_imageSize = NULL;
    Size imageSize;
    Napi::Value* jsobj_R = NULL;
    Mat R;
    Napi::Value* jsobj_T = NULL;
    Mat T;
    Napi::Value* jsobj_E = NULL;
    Mat E;
    Napi::Value* jsobj_F = NULL;
    Mat F;
    Napi::Value* jsobj_perViewErrors = NULL;
    Mat perViewErrors;
    Napi::Value* jsobj_flags = NULL;
    int flags=CALIB_FIX_INTRINSIC;
    Napi::Value* jsobj_criteria = NULL;
    TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6);
    double retval;

    const char* keywords[] = { "objectPoints", "imagePoints1", "imagePoints2", "cameraMatrix1", "distCoeffs1", "cameraMatrix2", "distCoeffs2", "imageSize", "R", "T", "E", "F", "perViewErrors", "flags", "criteria", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOOOOOO|OOOOO:stereoCalibrate", (char**)keywords, &jsobj_objectPoints, &jsobj_imagePoints1, &jsobj_imagePoints2, &jsobj_cameraMatrix1, &jsobj_distCoeffs1, &jsobj_cameraMatrix2, &jsobj_distCoeffs2, &jsobj_imageSize, &jsobj_R, &jsobj_T, &jsobj_E, &jsobj_F, &jsobj_perViewErrors, &jsobj_flags, &jsobj_criteria) &&
        jsopencv_to_safe(jsobj_objectPoints, objectPoints, ArgInfo("objectPoints", 0)) &&
        jsopencv_to_safe(jsobj_imagePoints1, imagePoints1, ArgInfo("imagePoints1", 0)) &&
        jsopencv_to_safe(jsobj_imagePoints2, imagePoints2, ArgInfo("imagePoints2", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix1, cameraMatrix1, ArgInfo("cameraMatrix1", 1)) &&
        jsopencv_to_safe(jsobj_distCoeffs1, distCoeffs1, ArgInfo("distCoeffs1", 1)) &&
        jsopencv_to_safe(jsobj_cameraMatrix2, cameraMatrix2, ArgInfo("cameraMatrix2", 1)) &&
        jsopencv_to_safe(jsobj_distCoeffs2, distCoeffs2, ArgInfo("distCoeffs2", 1)) &&
        jsopencv_to_safe(jsobj_imageSize, imageSize, ArgInfo("imageSize", 0)) &&
        jsopencv_to_safe(jsobj_R, R, ArgInfo("R", 1)) &&
        jsopencv_to_safe(jsobj_T, T, ArgInfo("T", 1)) &&
        jsopencv_to_safe(jsobj_E, E, ArgInfo("E", 1)) &&
        jsopencv_to_safe(jsobj_F, F, ArgInfo("F", 1)) &&
        jsopencv_to_safe(jsobj_perViewErrors, perViewErrors, ArgInfo("perViewErrors", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_criteria, criteria, ArgInfo("criteria", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::stereoCalibrate(objectPoints, imagePoints1, imagePoints2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, imageSize, R, T, E, F, perViewErrors, flags, criteria));
        return Js_BuildValue(info, "(NNNNNNNNNN)", jsopencv_from(info, retval), jsopencv_from(info, cameraMatrix1), jsopencv_from(info, distCoeffs1), jsopencv_from(info, cameraMatrix2), jsopencv_from(info, distCoeffs2), jsopencv_from(info, R), jsopencv_from(info, T), jsopencv_from(info, E), jsopencv_from(info, F), jsopencv_from(info, perViewErrors));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_objectPoints = NULL;
    vector_UMat objectPoints;
    Napi::Value* jsobj_imagePoints1 = NULL;
    vector_UMat imagePoints1;
    Napi::Value* jsobj_imagePoints2 = NULL;
    vector_UMat imagePoints2;
    Napi::Value* jsobj_cameraMatrix1 = NULL;
    UMat cameraMatrix1;
    Napi::Value* jsobj_distCoeffs1 = NULL;
    UMat distCoeffs1;
    Napi::Value* jsobj_cameraMatrix2 = NULL;
    UMat cameraMatrix2;
    Napi::Value* jsobj_distCoeffs2 = NULL;
    UMat distCoeffs2;
    Napi::Value* jsobj_imageSize = NULL;
    Size imageSize;
    Napi::Value* jsobj_R = NULL;
    UMat R;
    Napi::Value* jsobj_T = NULL;
    UMat T;
    Napi::Value* jsobj_E = NULL;
    UMat E;
    Napi::Value* jsobj_F = NULL;
    UMat F;
    Napi::Value* jsobj_perViewErrors = NULL;
    UMat perViewErrors;
    Napi::Value* jsobj_flags = NULL;
    int flags=CALIB_FIX_INTRINSIC;
    Napi::Value* jsobj_criteria = NULL;
    TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6);
    double retval;

    const char* keywords[] = { "objectPoints", "imagePoints1", "imagePoints2", "cameraMatrix1", "distCoeffs1", "cameraMatrix2", "distCoeffs2", "imageSize", "R", "T", "E", "F", "perViewErrors", "flags", "criteria", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOOOOOO|OOOOO:stereoCalibrate", (char**)keywords, &jsobj_objectPoints, &jsobj_imagePoints1, &jsobj_imagePoints2, &jsobj_cameraMatrix1, &jsobj_distCoeffs1, &jsobj_cameraMatrix2, &jsobj_distCoeffs2, &jsobj_imageSize, &jsobj_R, &jsobj_T, &jsobj_E, &jsobj_F, &jsobj_perViewErrors, &jsobj_flags, &jsobj_criteria) &&
        jsopencv_to_safe(jsobj_objectPoints, objectPoints, ArgInfo("objectPoints", 0)) &&
        jsopencv_to_safe(jsobj_imagePoints1, imagePoints1, ArgInfo("imagePoints1", 0)) &&
        jsopencv_to_safe(jsobj_imagePoints2, imagePoints2, ArgInfo("imagePoints2", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix1, cameraMatrix1, ArgInfo("cameraMatrix1", 1)) &&
        jsopencv_to_safe(jsobj_distCoeffs1, distCoeffs1, ArgInfo("distCoeffs1", 1)) &&
        jsopencv_to_safe(jsobj_cameraMatrix2, cameraMatrix2, ArgInfo("cameraMatrix2", 1)) &&
        jsopencv_to_safe(jsobj_distCoeffs2, distCoeffs2, ArgInfo("distCoeffs2", 1)) &&
        jsopencv_to_safe(jsobj_imageSize, imageSize, ArgInfo("imageSize", 0)) &&
        jsopencv_to_safe(jsobj_R, R, ArgInfo("R", 1)) &&
        jsopencv_to_safe(jsobj_T, T, ArgInfo("T", 1)) &&
        jsopencv_to_safe(jsobj_E, E, ArgInfo("E", 1)) &&
        jsopencv_to_safe(jsobj_F, F, ArgInfo("F", 1)) &&
        jsopencv_to_safe(jsobj_perViewErrors, perViewErrors, ArgInfo("perViewErrors", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_criteria, criteria, ArgInfo("criteria", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::stereoCalibrate(objectPoints, imagePoints1, imagePoints2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, imageSize, R, T, E, F, perViewErrors, flags, criteria));
        return Js_BuildValue(info, "(NNNNNNNNNN)", jsopencv_from(info, retval), jsopencv_from(info, cameraMatrix1), jsopencv_from(info, distCoeffs1), jsopencv_from(info, cameraMatrix2), jsopencv_from(info, distCoeffs2), jsopencv_from(info, R), jsopencv_from(info, T), jsopencv_from(info, E), jsopencv_from(info, F), jsopencv_from(info, perViewErrors));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "stereoCalibrate");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_stereoCalibrateExtended(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_objectPoints = NULL;
    vector_Mat objectPoints;
    Napi::Value* jsobj_imagePoints1 = NULL;
    vector_Mat imagePoints1;
    Napi::Value* jsobj_imagePoints2 = NULL;
    vector_Mat imagePoints2;
    Napi::Value* jsobj_cameraMatrix1 = NULL;
    Mat cameraMatrix1;
    Napi::Value* jsobj_distCoeffs1 = NULL;
    Mat distCoeffs1;
    Napi::Value* jsobj_cameraMatrix2 = NULL;
    Mat cameraMatrix2;
    Napi::Value* jsobj_distCoeffs2 = NULL;
    Mat distCoeffs2;
    Napi::Value* jsobj_imageSize = NULL;
    Size imageSize;
    Napi::Value* jsobj_R = NULL;
    Mat R;
    Napi::Value* jsobj_T = NULL;
    Mat T;
    Napi::Value* jsobj_E = NULL;
    Mat E;
    Napi::Value* jsobj_F = NULL;
    Mat F;
    Napi::Value* jsobj_rvecs = NULL;
    vector_Mat rvecs;
    Napi::Value* jsobj_tvecs = NULL;
    vector_Mat tvecs;
    Napi::Value* jsobj_perViewErrors = NULL;
    Mat perViewErrors;
    Napi::Value* jsobj_flags = NULL;
    int flags=CALIB_FIX_INTRINSIC;
    Napi::Value* jsobj_criteria = NULL;
    TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6);
    double retval;

    const char* keywords[] = { "objectPoints", "imagePoints1", "imagePoints2", "cameraMatrix1", "distCoeffs1", "cameraMatrix2", "distCoeffs2", "imageSize", "R", "T", "E", "F", "rvecs", "tvecs", "perViewErrors", "flags", "criteria", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOOOOOO|OOOOOOO:stereoCalibrateExtended", (char**)keywords, &jsobj_objectPoints, &jsobj_imagePoints1, &jsobj_imagePoints2, &jsobj_cameraMatrix1, &jsobj_distCoeffs1, &jsobj_cameraMatrix2, &jsobj_distCoeffs2, &jsobj_imageSize, &jsobj_R, &jsobj_T, &jsobj_E, &jsobj_F, &jsobj_rvecs, &jsobj_tvecs, &jsobj_perViewErrors, &jsobj_flags, &jsobj_criteria) &&
        jsopencv_to_safe(jsobj_objectPoints, objectPoints, ArgInfo("objectPoints", 0)) &&
        jsopencv_to_safe(jsobj_imagePoints1, imagePoints1, ArgInfo("imagePoints1", 0)) &&
        jsopencv_to_safe(jsobj_imagePoints2, imagePoints2, ArgInfo("imagePoints2", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix1, cameraMatrix1, ArgInfo("cameraMatrix1", 1)) &&
        jsopencv_to_safe(jsobj_distCoeffs1, distCoeffs1, ArgInfo("distCoeffs1", 1)) &&
        jsopencv_to_safe(jsobj_cameraMatrix2, cameraMatrix2, ArgInfo("cameraMatrix2", 1)) &&
        jsopencv_to_safe(jsobj_distCoeffs2, distCoeffs2, ArgInfo("distCoeffs2", 1)) &&
        jsopencv_to_safe(jsobj_imageSize, imageSize, ArgInfo("imageSize", 0)) &&
        jsopencv_to_safe(jsobj_R, R, ArgInfo("R", 1)) &&
        jsopencv_to_safe(jsobj_T, T, ArgInfo("T", 1)) &&
        jsopencv_to_safe(jsobj_E, E, ArgInfo("E", 1)) &&
        jsopencv_to_safe(jsobj_F, F, ArgInfo("F", 1)) &&
        jsopencv_to_safe(jsobj_rvecs, rvecs, ArgInfo("rvecs", 1)) &&
        jsopencv_to_safe(jsobj_tvecs, tvecs, ArgInfo("tvecs", 1)) &&
        jsopencv_to_safe(jsobj_perViewErrors, perViewErrors, ArgInfo("perViewErrors", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_criteria, criteria, ArgInfo("criteria", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::stereoCalibrate(objectPoints, imagePoints1, imagePoints2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, imageSize, R, T, E, F, rvecs, tvecs, perViewErrors, flags, criteria));
        return Js_BuildValue(info, "(NNNNNNNNNNNN)", jsopencv_from(info, retval), jsopencv_from(info, cameraMatrix1), jsopencv_from(info, distCoeffs1), jsopencv_from(info, cameraMatrix2), jsopencv_from(info, distCoeffs2), jsopencv_from(info, R), jsopencv_from(info, T), jsopencv_from(info, E), jsopencv_from(info, F), jsopencv_from(info, rvecs), jsopencv_from(info, tvecs), jsopencv_from(info, perViewErrors));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_objectPoints = NULL;
    vector_UMat objectPoints;
    Napi::Value* jsobj_imagePoints1 = NULL;
    vector_UMat imagePoints1;
    Napi::Value* jsobj_imagePoints2 = NULL;
    vector_UMat imagePoints2;
    Napi::Value* jsobj_cameraMatrix1 = NULL;
    UMat cameraMatrix1;
    Napi::Value* jsobj_distCoeffs1 = NULL;
    UMat distCoeffs1;
    Napi::Value* jsobj_cameraMatrix2 = NULL;
    UMat cameraMatrix2;
    Napi::Value* jsobj_distCoeffs2 = NULL;
    UMat distCoeffs2;
    Napi::Value* jsobj_imageSize = NULL;
    Size imageSize;
    Napi::Value* jsobj_R = NULL;
    UMat R;
    Napi::Value* jsobj_T = NULL;
    UMat T;
    Napi::Value* jsobj_E = NULL;
    UMat E;
    Napi::Value* jsobj_F = NULL;
    UMat F;
    Napi::Value* jsobj_rvecs = NULL;
    vector_UMat rvecs;
    Napi::Value* jsobj_tvecs = NULL;
    vector_UMat tvecs;
    Napi::Value* jsobj_perViewErrors = NULL;
    UMat perViewErrors;
    Napi::Value* jsobj_flags = NULL;
    int flags=CALIB_FIX_INTRINSIC;
    Napi::Value* jsobj_criteria = NULL;
    TermCriteria criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6);
    double retval;

    const char* keywords[] = { "objectPoints", "imagePoints1", "imagePoints2", "cameraMatrix1", "distCoeffs1", "cameraMatrix2", "distCoeffs2", "imageSize", "R", "T", "E", "F", "rvecs", "tvecs", "perViewErrors", "flags", "criteria", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOOOOOO|OOOOOOO:stereoCalibrateExtended", (char**)keywords, &jsobj_objectPoints, &jsobj_imagePoints1, &jsobj_imagePoints2, &jsobj_cameraMatrix1, &jsobj_distCoeffs1, &jsobj_cameraMatrix2, &jsobj_distCoeffs2, &jsobj_imageSize, &jsobj_R, &jsobj_T, &jsobj_E, &jsobj_F, &jsobj_rvecs, &jsobj_tvecs, &jsobj_perViewErrors, &jsobj_flags, &jsobj_criteria) &&
        jsopencv_to_safe(jsobj_objectPoints, objectPoints, ArgInfo("objectPoints", 0)) &&
        jsopencv_to_safe(jsobj_imagePoints1, imagePoints1, ArgInfo("imagePoints1", 0)) &&
        jsopencv_to_safe(jsobj_imagePoints2, imagePoints2, ArgInfo("imagePoints2", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix1, cameraMatrix1, ArgInfo("cameraMatrix1", 1)) &&
        jsopencv_to_safe(jsobj_distCoeffs1, distCoeffs1, ArgInfo("distCoeffs1", 1)) &&
        jsopencv_to_safe(jsobj_cameraMatrix2, cameraMatrix2, ArgInfo("cameraMatrix2", 1)) &&
        jsopencv_to_safe(jsobj_distCoeffs2, distCoeffs2, ArgInfo("distCoeffs2", 1)) &&
        jsopencv_to_safe(jsobj_imageSize, imageSize, ArgInfo("imageSize", 0)) &&
        jsopencv_to_safe(jsobj_R, R, ArgInfo("R", 1)) &&
        jsopencv_to_safe(jsobj_T, T, ArgInfo("T", 1)) &&
        jsopencv_to_safe(jsobj_E, E, ArgInfo("E", 1)) &&
        jsopencv_to_safe(jsobj_F, F, ArgInfo("F", 1)) &&
        jsopencv_to_safe(jsobj_rvecs, rvecs, ArgInfo("rvecs", 1)) &&
        jsopencv_to_safe(jsobj_tvecs, tvecs, ArgInfo("tvecs", 1)) &&
        jsopencv_to_safe(jsobj_perViewErrors, perViewErrors, ArgInfo("perViewErrors", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_criteria, criteria, ArgInfo("criteria", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::stereoCalibrate(objectPoints, imagePoints1, imagePoints2, cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, imageSize, R, T, E, F, rvecs, tvecs, perViewErrors, flags, criteria));
        return Js_BuildValue(info, "(NNNNNNNNNNNN)", jsopencv_from(info, retval), jsopencv_from(info, cameraMatrix1), jsopencv_from(info, distCoeffs1), jsopencv_from(info, cameraMatrix2), jsopencv_from(info, distCoeffs2), jsopencv_from(info, R), jsopencv_from(info, T), jsopencv_from(info, E), jsopencv_from(info, F), jsopencv_from(info, rvecs), jsopencv_from(info, tvecs), jsopencv_from(info, perViewErrors));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "stereoCalibrateExtended");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_stereoRectify(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_cameraMatrix1 = NULL;
    Mat cameraMatrix1;
    Napi::Value* jsobj_distCoeffs1 = NULL;
    Mat distCoeffs1;
    Napi::Value* jsobj_cameraMatrix2 = NULL;
    Mat cameraMatrix2;
    Napi::Value* jsobj_distCoeffs2 = NULL;
    Mat distCoeffs2;
    Napi::Value* jsobj_imageSize = NULL;
    Size imageSize;
    Napi::Value* jsobj_R = NULL;
    Mat R;
    Napi::Value* jsobj_T = NULL;
    Mat T;
    Napi::Value* jsobj_R1 = NULL;
    Mat R1;
    Napi::Value* jsobj_R2 = NULL;
    Mat R2;
    Napi::Value* jsobj_P1 = NULL;
    Mat P1;
    Napi::Value* jsobj_P2 = NULL;
    Mat P2;
    Napi::Value* jsobj_Q = NULL;
    Mat Q;
    Napi::Value* jsobj_flags = NULL;
    int flags=CALIB_ZERO_DISPARITY;
    Napi::Value* jsobj_alpha = NULL;
    double alpha=-1;
    Napi::Value* jsobj_newImageSize = NULL;
    Size newImageSize;
    Rect validPixROI1;
    Rect validPixROI2;

    const char* keywords[] = { "cameraMatrix1", "distCoeffs1", "cameraMatrix2", "distCoeffs2", "imageSize", "R", "T", "R1", "R2", "P1", "P2", "Q", "flags", "alpha", "newImageSize", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOOO|OOOOOOOO:stereoRectify", (char**)keywords, &jsobj_cameraMatrix1, &jsobj_distCoeffs1, &jsobj_cameraMatrix2, &jsobj_distCoeffs2, &jsobj_imageSize, &jsobj_R, &jsobj_T, &jsobj_R1, &jsobj_R2, &jsobj_P1, &jsobj_P2, &jsobj_Q, &jsobj_flags, &jsobj_alpha, &jsobj_newImageSize) &&
        jsopencv_to_safe(jsobj_cameraMatrix1, cameraMatrix1, ArgInfo("cameraMatrix1", 0)) &&
        jsopencv_to_safe(jsobj_distCoeffs1, distCoeffs1, ArgInfo("distCoeffs1", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix2, cameraMatrix2, ArgInfo("cameraMatrix2", 0)) &&
        jsopencv_to_safe(jsobj_distCoeffs2, distCoeffs2, ArgInfo("distCoeffs2", 0)) &&
        jsopencv_to_safe(jsobj_imageSize, imageSize, ArgInfo("imageSize", 0)) &&
        jsopencv_to_safe(jsobj_R, R, ArgInfo("R", 0)) &&
        jsopencv_to_safe(jsobj_T, T, ArgInfo("T", 0)) &&
        jsopencv_to_safe(jsobj_R1, R1, ArgInfo("R1", 1)) &&
        jsopencv_to_safe(jsobj_R2, R2, ArgInfo("R2", 1)) &&
        jsopencv_to_safe(jsobj_P1, P1, ArgInfo("P1", 1)) &&
        jsopencv_to_safe(jsobj_P2, P2, ArgInfo("P2", 1)) &&
        jsopencv_to_safe(jsobj_Q, Q, ArgInfo("Q", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_alpha, alpha, ArgInfo("alpha", 0)) &&
        jsopencv_to_safe(jsobj_newImageSize, newImageSize, ArgInfo("newImageSize", 0)))
    {
        ERRWRAP2_NAPI(info, cv::stereoRectify(cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, imageSize, R, T, R1, R2, P1, P2, Q, flags, alpha, newImageSize, &validPixROI1, &validPixROI2));
        return Js_BuildValue(info, "(NNNNNNN)", jsopencv_from(info, R1), jsopencv_from(info, R2), jsopencv_from(info, P1), jsopencv_from(info, P2), jsopencv_from(info, Q), jsopencv_from(info, validPixROI1), jsopencv_from(info, validPixROI2));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_cameraMatrix1 = NULL;
    UMat cameraMatrix1;
    Napi::Value* jsobj_distCoeffs1 = NULL;
    UMat distCoeffs1;
    Napi::Value* jsobj_cameraMatrix2 = NULL;
    UMat cameraMatrix2;
    Napi::Value* jsobj_distCoeffs2 = NULL;
    UMat distCoeffs2;
    Napi::Value* jsobj_imageSize = NULL;
    Size imageSize;
    Napi::Value* jsobj_R = NULL;
    UMat R;
    Napi::Value* jsobj_T = NULL;
    UMat T;
    Napi::Value* jsobj_R1 = NULL;
    UMat R1;
    Napi::Value* jsobj_R2 = NULL;
    UMat R2;
    Napi::Value* jsobj_P1 = NULL;
    UMat P1;
    Napi::Value* jsobj_P2 = NULL;
    UMat P2;
    Napi::Value* jsobj_Q = NULL;
    UMat Q;
    Napi::Value* jsobj_flags = NULL;
    int flags=CALIB_ZERO_DISPARITY;
    Napi::Value* jsobj_alpha = NULL;
    double alpha=-1;
    Napi::Value* jsobj_newImageSize = NULL;
    Size newImageSize;
    Rect validPixROI1;
    Rect validPixROI2;

    const char* keywords[] = { "cameraMatrix1", "distCoeffs1", "cameraMatrix2", "distCoeffs2", "imageSize", "R", "T", "R1", "R2", "P1", "P2", "Q", "flags", "alpha", "newImageSize", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOOO|OOOOOOOO:stereoRectify", (char**)keywords, &jsobj_cameraMatrix1, &jsobj_distCoeffs1, &jsobj_cameraMatrix2, &jsobj_distCoeffs2, &jsobj_imageSize, &jsobj_R, &jsobj_T, &jsobj_R1, &jsobj_R2, &jsobj_P1, &jsobj_P2, &jsobj_Q, &jsobj_flags, &jsobj_alpha, &jsobj_newImageSize) &&
        jsopencv_to_safe(jsobj_cameraMatrix1, cameraMatrix1, ArgInfo("cameraMatrix1", 0)) &&
        jsopencv_to_safe(jsobj_distCoeffs1, distCoeffs1, ArgInfo("distCoeffs1", 0)) &&
        jsopencv_to_safe(jsobj_cameraMatrix2, cameraMatrix2, ArgInfo("cameraMatrix2", 0)) &&
        jsopencv_to_safe(jsobj_distCoeffs2, distCoeffs2, ArgInfo("distCoeffs2", 0)) &&
        jsopencv_to_safe(jsobj_imageSize, imageSize, ArgInfo("imageSize", 0)) &&
        jsopencv_to_safe(jsobj_R, R, ArgInfo("R", 0)) &&
        jsopencv_to_safe(jsobj_T, T, ArgInfo("T", 0)) &&
        jsopencv_to_safe(jsobj_R1, R1, ArgInfo("R1", 1)) &&
        jsopencv_to_safe(jsobj_R2, R2, ArgInfo("R2", 1)) &&
        jsopencv_to_safe(jsobj_P1, P1, ArgInfo("P1", 1)) &&
        jsopencv_to_safe(jsobj_P2, P2, ArgInfo("P2", 1)) &&
        jsopencv_to_safe(jsobj_Q, Q, ArgInfo("Q", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_alpha, alpha, ArgInfo("alpha", 0)) &&
        jsopencv_to_safe(jsobj_newImageSize, newImageSize, ArgInfo("newImageSize", 0)))
    {
        ERRWRAP2_NAPI(info, cv::stereoRectify(cameraMatrix1, distCoeffs1, cameraMatrix2, distCoeffs2, imageSize, R, T, R1, R2, P1, P2, Q, flags, alpha, newImageSize, &validPixROI1, &validPixROI2));
        return Js_BuildValue(info, "(NNNNNNN)", jsopencv_from(info, R1), jsopencv_from(info, R2), jsopencv_from(info, P1), jsopencv_from(info, P2), jsopencv_from(info, Q), jsopencv_from(info, validPixROI1), jsopencv_from(info, validPixROI2));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "stereoRectify");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_stereoRectifyUncalibrated(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_points1 = NULL;
    Mat points1;
    Napi::Value* jsobj_points2 = NULL;
    Mat points2;
    Napi::Value* jsobj_F = NULL;
    Mat F;
    Napi::Value* jsobj_imgSize = NULL;
    Size imgSize;
    Napi::Value* jsobj_H1 = NULL;
    Mat H1;
    Napi::Value* jsobj_H2 = NULL;
    Mat H2;
    Napi::Value* jsobj_threshold = NULL;
    double threshold=5;
    bool retval;

    const char* keywords[] = { "points1", "points2", "F", "imgSize", "H1", "H2", "threshold", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOO:stereoRectifyUncalibrated", (char**)keywords, &jsobj_points1, &jsobj_points2, &jsobj_F, &jsobj_imgSize, &jsobj_H1, &jsobj_H2, &jsobj_threshold) &&
        jsopencv_to_safe(jsobj_points1, points1, ArgInfo("points1", 0)) &&
        jsopencv_to_safe(jsobj_points2, points2, ArgInfo("points2", 0)) &&
        jsopencv_to_safe(jsobj_F, F, ArgInfo("F", 0)) &&
        jsopencv_to_safe(jsobj_imgSize, imgSize, ArgInfo("imgSize", 0)) &&
        jsopencv_to_safe(jsobj_H1, H1, ArgInfo("H1", 1)) &&
        jsopencv_to_safe(jsobj_H2, H2, ArgInfo("H2", 1)) &&
        jsopencv_to_safe(jsobj_threshold, threshold, ArgInfo("threshold", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::stereoRectifyUncalibrated(points1, points2, F, imgSize, H1, H2, threshold));
        return Js_BuildValue(info, "(NNN)", jsopencv_from(info, retval), jsopencv_from(info, H1), jsopencv_from(info, H2));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_points1 = NULL;
    UMat points1;
    Napi::Value* jsobj_points2 = NULL;
    UMat points2;
    Napi::Value* jsobj_F = NULL;
    UMat F;
    Napi::Value* jsobj_imgSize = NULL;
    Size imgSize;
    Napi::Value* jsobj_H1 = NULL;
    UMat H1;
    Napi::Value* jsobj_H2 = NULL;
    UMat H2;
    Napi::Value* jsobj_threshold = NULL;
    double threshold=5;
    bool retval;

    const char* keywords[] = { "points1", "points2", "F", "imgSize", "H1", "H2", "threshold", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOO:stereoRectifyUncalibrated", (char**)keywords, &jsobj_points1, &jsobj_points2, &jsobj_F, &jsobj_imgSize, &jsobj_H1, &jsobj_H2, &jsobj_threshold) &&
        jsopencv_to_safe(jsobj_points1, points1, ArgInfo("points1", 0)) &&
        jsopencv_to_safe(jsobj_points2, points2, ArgInfo("points2", 0)) &&
        jsopencv_to_safe(jsobj_F, F, ArgInfo("F", 0)) &&
        jsopencv_to_safe(jsobj_imgSize, imgSize, ArgInfo("imgSize", 0)) &&
        jsopencv_to_safe(jsobj_H1, H1, ArgInfo("H1", 1)) &&
        jsopencv_to_safe(jsobj_H2, H2, ArgInfo("H2", 1)) &&
        jsopencv_to_safe(jsobj_threshold, threshold, ArgInfo("threshold", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::stereoRectifyUncalibrated(points1, points2, F, imgSize, H1, H2, threshold));
        return Js_BuildValue(info, "(NNN)", jsopencv_from(info, retval), jsopencv_from(info, H1), jsopencv_from(info, H2));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "stereoRectifyUncalibrated");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_stylization(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_sigma_s = NULL;
    float sigma_s=60;
    Napi::Value* jsobj_sigma_r = NULL;
    float sigma_r=0.45f;

    const char* keywords[] = { "src", "dst", "sigma_s", "sigma_r", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOO:stylization", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_sigma_s, &jsobj_sigma_r) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_sigma_s, sigma_s, ArgInfo("sigma_s", 0)) &&
        jsopencv_to_safe(jsobj_sigma_r, sigma_r, ArgInfo("sigma_r", 0)))
    {
        ERRWRAP2_NAPI(info, cv::stylization(src, dst, sigma_s, sigma_r));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_sigma_s = NULL;
    float sigma_s=60;
    Napi::Value* jsobj_sigma_r = NULL;
    float sigma_r=0.45f;

    const char* keywords[] = { "src", "dst", "sigma_s", "sigma_r", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOO:stylization", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_sigma_s, &jsobj_sigma_r) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_sigma_s, sigma_s, ArgInfo("sigma_s", 0)) &&
        jsopencv_to_safe(jsobj_sigma_r, sigma_r, ArgInfo("sigma_r", 0)))
    {
        ERRWRAP2_NAPI(info, cv::stylization(src, dst, sigma_s, sigma_r));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "stylization");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_subtract(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src1 = NULL;
    Mat src1;
    Napi::Value* jsobj_src2 = NULL;
    Mat src2;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_mask = NULL;
    Mat mask;
    Napi::Value* jsobj_dtype = NULL;
    int dtype=-1;

    const char* keywords[] = { "src1", "src2", "dst", "mask", "dtype", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOO:subtract", (char**)keywords, &jsobj_src1, &jsobj_src2, &jsobj_dst, &jsobj_mask, &jsobj_dtype) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)) &&
        jsopencv_to_safe(jsobj_dtype, dtype, ArgInfo("dtype", 0)))
    {
        ERRWRAP2_NAPI(info, cv::subtract(src1, src2, dst, mask, dtype));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src1 = NULL;
    UMat src1;
    Napi::Value* jsobj_src2 = NULL;
    UMat src2;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_mask = NULL;
    UMat mask;
    Napi::Value* jsobj_dtype = NULL;
    int dtype=-1;

    const char* keywords[] = { "src1", "src2", "dst", "mask", "dtype", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOO:subtract", (char**)keywords, &jsobj_src1, &jsobj_src2, &jsobj_dst, &jsobj_mask, &jsobj_dtype) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)) &&
        jsopencv_to_safe(jsobj_dtype, dtype, ArgInfo("dtype", 0)))
    {
        ERRWRAP2_NAPI(info, cv::subtract(src1, src2, dst, mask, dtype));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "subtract");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_sumElems(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Scalar retval;

    const char* keywords[] = { "src", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:sumElems", (char**)keywords, &jsobj_src) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::sum(src));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Scalar retval;

    const char* keywords[] = { "src", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:sumElems", (char**)keywords, &jsobj_src) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::sum(src));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "sumElems");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_textureFlattening(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_mask = NULL;
    Mat mask;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_low_threshold = NULL;
    float low_threshold=30;
    Napi::Value* jsobj_high_threshold = NULL;
    float high_threshold=45;
    Napi::Value* jsobj_kernel_size = NULL;
    int kernel_size=3;

    const char* keywords[] = { "src", "mask", "dst", "low_threshold", "high_threshold", "kernel_size", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOOO:textureFlattening", (char**)keywords, &jsobj_src, &jsobj_mask, &jsobj_dst, &jsobj_low_threshold, &jsobj_high_threshold, &jsobj_kernel_size) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_low_threshold, low_threshold, ArgInfo("low_threshold", 0)) &&
        jsopencv_to_safe(jsobj_high_threshold, high_threshold, ArgInfo("high_threshold", 0)) &&
        jsopencv_to_safe(jsobj_kernel_size, kernel_size, ArgInfo("kernel_size", 0)))
    {
        ERRWRAP2_NAPI(info, cv::textureFlattening(src, mask, dst, low_threshold, high_threshold, kernel_size));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_mask = NULL;
    UMat mask;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_low_threshold = NULL;
    float low_threshold=30;
    Napi::Value* jsobj_high_threshold = NULL;
    float high_threshold=45;
    Napi::Value* jsobj_kernel_size = NULL;
    int kernel_size=3;

    const char* keywords[] = { "src", "mask", "dst", "low_threshold", "high_threshold", "kernel_size", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOOO:textureFlattening", (char**)keywords, &jsobj_src, &jsobj_mask, &jsobj_dst, &jsobj_low_threshold, &jsobj_high_threshold, &jsobj_kernel_size) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_low_threshold, low_threshold, ArgInfo("low_threshold", 0)) &&
        jsopencv_to_safe(jsobj_high_threshold, high_threshold, ArgInfo("high_threshold", 0)) &&
        jsopencv_to_safe(jsobj_kernel_size, kernel_size, ArgInfo("kernel_size", 0)))
    {
        ERRWRAP2_NAPI(info, cv::textureFlattening(src, mask, dst, low_threshold, high_threshold, kernel_size));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "textureFlattening");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_threshold(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_thresh = NULL;
    double thresh=0;
    Napi::Value* jsobj_maxval = NULL;
    double maxval=0;
    Napi::Value* jsobj_type = NULL;
    int type=0;
    double retval;

    const char* keywords[] = { "src", "thresh", "maxval", "type", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|O:threshold", (char**)keywords, &jsobj_src, &jsobj_thresh, &jsobj_maxval, &jsobj_type, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_thresh, thresh, ArgInfo("thresh", 0)) &&
        jsopencv_to_safe(jsobj_maxval, maxval, ArgInfo("maxval", 0)) &&
        jsopencv_to_safe(jsobj_type, type, ArgInfo("type", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::threshold(src, dst, thresh, maxval, type));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, dst));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_thresh = NULL;
    double thresh=0;
    Napi::Value* jsobj_maxval = NULL;
    double maxval=0;
    Napi::Value* jsobj_type = NULL;
    int type=0;
    double retval;

    const char* keywords[] = { "src", "thresh", "maxval", "type", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|O:threshold", (char**)keywords, &jsobj_src, &jsobj_thresh, &jsobj_maxval, &jsobj_type, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_thresh, thresh, ArgInfo("thresh", 0)) &&
        jsopencv_to_safe(jsobj_maxval, maxval, ArgInfo("maxval", 0)) &&
        jsopencv_to_safe(jsobj_type, type, ArgInfo("type", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::threshold(src, dst, thresh, maxval, type));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, dst));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "threshold");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_trace(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_mtx = NULL;
    Mat mtx;
    Scalar retval;

    const char* keywords[] = { "mtx", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:trace", (char**)keywords, &jsobj_mtx) &&
        jsopencv_to_safe(jsobj_mtx, mtx, ArgInfo("mtx", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::trace(mtx));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_mtx = NULL;
    UMat mtx;
    Scalar retval;

    const char* keywords[] = { "mtx", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:trace", (char**)keywords, &jsobj_mtx) &&
        jsopencv_to_safe(jsobj_mtx, mtx, ArgInfo("mtx", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::trace(mtx));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "trace");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_transform(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_m = NULL;
    Mat m;

    const char* keywords[] = { "src", "m", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:transform", (char**)keywords, &jsobj_src, &jsobj_m, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_m, m, ArgInfo("m", 0)))
    {
        ERRWRAP2_NAPI(info, cv::transform(src, dst, m));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_m = NULL;
    UMat m;

    const char* keywords[] = { "src", "m", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:transform", (char**)keywords, &jsobj_src, &jsobj_m, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_m, m, ArgInfo("m", 0)))
    {
        ERRWRAP2_NAPI(info, cv::transform(src, dst, m));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "transform");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_transpose(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;

    const char* keywords[] = { "src", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:transpose", (char**)keywords, &jsobj_src, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)))
    {
        ERRWRAP2_NAPI(info, cv::transpose(src, dst));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;

    const char* keywords[] = { "src", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:transpose", (char**)keywords, &jsobj_src, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)))
    {
        ERRWRAP2_NAPI(info, cv::transpose(src, dst));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "transpose");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_transposeND(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_order = NULL;
    vector_int order;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;

    const char* keywords[] = { "src", "order", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:transposeND", (char**)keywords, &jsobj_src, &jsobj_order, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_order, order, ArgInfo("order", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)))
    {
        ERRWRAP2_NAPI(info, cv::transposeND(src, order, dst));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_order = NULL;
    vector_int order;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;

    const char* keywords[] = { "src", "order", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:transposeND", (char**)keywords, &jsobj_src, &jsobj_order, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_order, order, ArgInfo("order", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)))
    {
        ERRWRAP2_NAPI(info, cv::transposeND(src, order, dst));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "transposeND");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_triangulatePoints(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_projMatr1 = NULL;
    Mat projMatr1;
    Napi::Value* jsobj_projMatr2 = NULL;
    Mat projMatr2;
    Napi::Value* jsobj_projPoints1 = NULL;
    Mat projPoints1;
    Napi::Value* jsobj_projPoints2 = NULL;
    Mat projPoints2;
    Napi::Value* jsobj_points4D = NULL;
    Mat points4D;

    const char* keywords[] = { "projMatr1", "projMatr2", "projPoints1", "projPoints2", "points4D", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|O:triangulatePoints", (char**)keywords, &jsobj_projMatr1, &jsobj_projMatr2, &jsobj_projPoints1, &jsobj_projPoints2, &jsobj_points4D) &&
        jsopencv_to_safe(jsobj_projMatr1, projMatr1, ArgInfo("projMatr1", 0)) &&
        jsopencv_to_safe(jsobj_projMatr2, projMatr2, ArgInfo("projMatr2", 0)) &&
        jsopencv_to_safe(jsobj_projPoints1, projPoints1, ArgInfo("projPoints1", 0)) &&
        jsopencv_to_safe(jsobj_projPoints2, projPoints2, ArgInfo("projPoints2", 0)) &&
        jsopencv_to_safe(jsobj_points4D, points4D, ArgInfo("points4D", 1)))
    {
        ERRWRAP2_NAPI(info, cv::triangulatePoints(projMatr1, projMatr2, projPoints1, projPoints2, points4D));
        return jsopencv_from(info, points4D);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_projMatr1 = NULL;
    UMat projMatr1;
    Napi::Value* jsobj_projMatr2 = NULL;
    UMat projMatr2;
    Napi::Value* jsobj_projPoints1 = NULL;
    UMat projPoints1;
    Napi::Value* jsobj_projPoints2 = NULL;
    UMat projPoints2;
    Napi::Value* jsobj_points4D = NULL;
    UMat points4D;

    const char* keywords[] = { "projMatr1", "projMatr2", "projPoints1", "projPoints2", "points4D", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|O:triangulatePoints", (char**)keywords, &jsobj_projMatr1, &jsobj_projMatr2, &jsobj_projPoints1, &jsobj_projPoints2, &jsobj_points4D) &&
        jsopencv_to_safe(jsobj_projMatr1, projMatr1, ArgInfo("projMatr1", 0)) &&
        jsopencv_to_safe(jsobj_projMatr2, projMatr2, ArgInfo("projMatr2", 0)) &&
        jsopencv_to_safe(jsobj_projPoints1, projPoints1, ArgInfo("projPoints1", 0)) &&
        jsopencv_to_safe(jsobj_projPoints2, projPoints2, ArgInfo("projPoints2", 0)) &&
        jsopencv_to_safe(jsobj_points4D, points4D, ArgInfo("points4D", 1)))
    {
        ERRWRAP2_NAPI(info, cv::triangulatePoints(projMatr1, projMatr2, projPoints1, projPoints2, points4D));
        return jsopencv_from(info, points4D);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "triangulatePoints");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_undistort(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_cameraMatrix = NULL;
    Mat cameraMatrix;
    Napi::Value* jsobj_distCoeffs = NULL;
    Mat distCoeffs;
    Napi::Value* jsobj_newCameraMatrix = NULL;
    Mat newCameraMatrix;

    const char* keywords[] = { "src", "cameraMatrix", "distCoeffs", "dst", "newCameraMatrix", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OO:undistort", (char**)keywords, &jsobj_src, &jsobj_cameraMatrix, &jsobj_distCoeffs, &jsobj_dst, &jsobj_newCameraMatrix) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 0)) &&
        jsopencv_to_safe(jsobj_distCoeffs, distCoeffs, ArgInfo("distCoeffs", 0)) &&
        jsopencv_to_safe(jsobj_newCameraMatrix, newCameraMatrix, ArgInfo("newCameraMatrix", 0)))
    {
        ERRWRAP2_NAPI(info, cv::undistort(src, dst, cameraMatrix, distCoeffs, newCameraMatrix));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_cameraMatrix = NULL;
    UMat cameraMatrix;
    Napi::Value* jsobj_distCoeffs = NULL;
    UMat distCoeffs;
    Napi::Value* jsobj_newCameraMatrix = NULL;
    UMat newCameraMatrix;

    const char* keywords[] = { "src", "cameraMatrix", "distCoeffs", "dst", "newCameraMatrix", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OO:undistort", (char**)keywords, &jsobj_src, &jsobj_cameraMatrix, &jsobj_distCoeffs, &jsobj_dst, &jsobj_newCameraMatrix) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 0)) &&
        jsopencv_to_safe(jsobj_distCoeffs, distCoeffs, ArgInfo("distCoeffs", 0)) &&
        jsopencv_to_safe(jsobj_newCameraMatrix, newCameraMatrix, ArgInfo("newCameraMatrix", 0)))
    {
        ERRWRAP2_NAPI(info, cv::undistort(src, dst, cameraMatrix, distCoeffs, newCameraMatrix));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "undistort");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_undistortImagePoints(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_cameraMatrix = NULL;
    Mat cameraMatrix;
    Napi::Value* jsobj_distCoeffs = NULL;
    Mat distCoeffs;
    Napi::Value* jsobj_arg1 = NULL;
    TermCriteria arg1=TermCriteria(TermCriteria::MAX_ITER + TermCriteria::EPS, 5, 0.01);

    const char* keywords[] = { "src", "cameraMatrix", "distCoeffs", "dst", "arg1", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OO:undistortImagePoints", (char**)keywords, &jsobj_src, &jsobj_cameraMatrix, &jsobj_distCoeffs, &jsobj_dst, &jsobj_arg1) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 0)) &&
        jsopencv_to_safe(jsobj_distCoeffs, distCoeffs, ArgInfo("distCoeffs", 0)) &&
        jsopencv_to_safe(jsobj_arg1, arg1, ArgInfo("arg1", 0)))
    {
        ERRWRAP2_NAPI(info, cv::undistortImagePoints(src, dst, cameraMatrix, distCoeffs, arg1));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_cameraMatrix = NULL;
    UMat cameraMatrix;
    Napi::Value* jsobj_distCoeffs = NULL;
    UMat distCoeffs;
    Napi::Value* jsobj_arg1 = NULL;
    TermCriteria arg1=TermCriteria(TermCriteria::MAX_ITER + TermCriteria::EPS, 5, 0.01);

    const char* keywords[] = { "src", "cameraMatrix", "distCoeffs", "dst", "arg1", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OO:undistortImagePoints", (char**)keywords, &jsobj_src, &jsobj_cameraMatrix, &jsobj_distCoeffs, &jsobj_dst, &jsobj_arg1) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 0)) &&
        jsopencv_to_safe(jsobj_distCoeffs, distCoeffs, ArgInfo("distCoeffs", 0)) &&
        jsopencv_to_safe(jsobj_arg1, arg1, ArgInfo("arg1", 0)))
    {
        ERRWRAP2_NAPI(info, cv::undistortImagePoints(src, dst, cameraMatrix, distCoeffs, arg1));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "undistortImagePoints");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_undistortPoints(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_cameraMatrix = NULL;
    Mat cameraMatrix;
    Napi::Value* jsobj_distCoeffs = NULL;
    Mat distCoeffs;
    Napi::Value* jsobj_R = NULL;
    Mat R;
    Napi::Value* jsobj_P = NULL;
    Mat P;

    const char* keywords[] = { "src", "cameraMatrix", "distCoeffs", "dst", "R", "P", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOO:undistortPoints", (char**)keywords, &jsobj_src, &jsobj_cameraMatrix, &jsobj_distCoeffs, &jsobj_dst, &jsobj_R, &jsobj_P) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 0)) &&
        jsopencv_to_safe(jsobj_distCoeffs, distCoeffs, ArgInfo("distCoeffs", 0)) &&
        jsopencv_to_safe(jsobj_R, R, ArgInfo("R", 0)) &&
        jsopencv_to_safe(jsobj_P, P, ArgInfo("P", 0)))
    {
        ERRWRAP2_NAPI(info, cv::undistortPoints(src, dst, cameraMatrix, distCoeffs, R, P));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_cameraMatrix = NULL;
    UMat cameraMatrix;
    Napi::Value* jsobj_distCoeffs = NULL;
    UMat distCoeffs;
    Napi::Value* jsobj_R = NULL;
    UMat R;
    Napi::Value* jsobj_P = NULL;
    UMat P;

    const char* keywords[] = { "src", "cameraMatrix", "distCoeffs", "dst", "R", "P", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOO:undistortPoints", (char**)keywords, &jsobj_src, &jsobj_cameraMatrix, &jsobj_distCoeffs, &jsobj_dst, &jsobj_R, &jsobj_P) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 0)) &&
        jsopencv_to_safe(jsobj_distCoeffs, distCoeffs, ArgInfo("distCoeffs", 0)) &&
        jsopencv_to_safe(jsobj_R, R, ArgInfo("R", 0)) &&
        jsopencv_to_safe(jsobj_P, P, ArgInfo("P", 0)))
    {
        ERRWRAP2_NAPI(info, cv::undistortPoints(src, dst, cameraMatrix, distCoeffs, R, P));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "undistortPoints");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_undistortPointsIter(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_cameraMatrix = NULL;
    Mat cameraMatrix;
    Napi::Value* jsobj_distCoeffs = NULL;
    Mat distCoeffs;
    Napi::Value* jsobj_R = NULL;
    Mat R;
    Napi::Value* jsobj_P = NULL;
    Mat P;
    Napi::Value* jsobj_criteria = NULL;
    TermCriteria criteria;

    const char* keywords[] = { "src", "cameraMatrix", "distCoeffs", "R", "P", "criteria", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOO|O:undistortPointsIter", (char**)keywords, &jsobj_src, &jsobj_cameraMatrix, &jsobj_distCoeffs, &jsobj_R, &jsobj_P, &jsobj_criteria, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 0)) &&
        jsopencv_to_safe(jsobj_distCoeffs, distCoeffs, ArgInfo("distCoeffs", 0)) &&
        jsopencv_to_safe(jsobj_R, R, ArgInfo("R", 0)) &&
        jsopencv_to_safe(jsobj_P, P, ArgInfo("P", 0)) &&
        jsopencv_to_safe(jsobj_criteria, criteria, ArgInfo("criteria", 0)))
    {
        ERRWRAP2_NAPI(info, cv::undistortPoints(src, dst, cameraMatrix, distCoeffs, R, P, criteria));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_cameraMatrix = NULL;
    UMat cameraMatrix;
    Napi::Value* jsobj_distCoeffs = NULL;
    UMat distCoeffs;
    Napi::Value* jsobj_R = NULL;
    UMat R;
    Napi::Value* jsobj_P = NULL;
    UMat P;
    Napi::Value* jsobj_criteria = NULL;
    TermCriteria criteria;

    const char* keywords[] = { "src", "cameraMatrix", "distCoeffs", "R", "P", "criteria", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOO|O:undistortPointsIter", (char**)keywords, &jsobj_src, &jsobj_cameraMatrix, &jsobj_distCoeffs, &jsobj_R, &jsobj_P, &jsobj_criteria, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_cameraMatrix, cameraMatrix, ArgInfo("cameraMatrix", 0)) &&
        jsopencv_to_safe(jsobj_distCoeffs, distCoeffs, ArgInfo("distCoeffs", 0)) &&
        jsopencv_to_safe(jsobj_R, R, ArgInfo("R", 0)) &&
        jsopencv_to_safe(jsobj_P, P, ArgInfo("P", 0)) &&
        jsopencv_to_safe(jsobj_criteria, criteria, ArgInfo("criteria", 0)))
    {
        ERRWRAP2_NAPI(info, cv::undistortPoints(src, dst, cameraMatrix, distCoeffs, R, P, criteria));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "undistortPointsIter");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_useOpenVX(const Napi::CallbackInfo &info)
{
    using namespace cv;

    bool retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::useOpenVX());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_useOptimized(const Napi::CallbackInfo &info)
{
    using namespace cv;

    bool retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::useOptimized());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_validateDisparity(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_disparity = NULL;
    Mat disparity;
    Napi::Value* jsobj_cost = NULL;
    Mat cost;
    Napi::Value* jsobj_minDisparity = NULL;
    int minDisparity=0;
    Napi::Value* jsobj_numberOfDisparities = NULL;
    int numberOfDisparities=0;
    Napi::Value* jsobj_disp12MaxDisp = NULL;
    int disp12MaxDisp=1;

    const char* keywords[] = { "disparity", "cost", "minDisparity", "numberOfDisparities", "disp12MaxDisp", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|O:validateDisparity", (char**)keywords, &jsobj_disparity, &jsobj_cost, &jsobj_minDisparity, &jsobj_numberOfDisparities, &jsobj_disp12MaxDisp) &&
        jsopencv_to_safe(jsobj_disparity, disparity, ArgInfo("disparity", 1)) &&
        jsopencv_to_safe(jsobj_cost, cost, ArgInfo("cost", 0)) &&
        jsopencv_to_safe(jsobj_minDisparity, minDisparity, ArgInfo("minDisparity", 0)) &&
        jsopencv_to_safe(jsobj_numberOfDisparities, numberOfDisparities, ArgInfo("numberOfDisparities", 0)) &&
        jsopencv_to_safe(jsobj_disp12MaxDisp, disp12MaxDisp, ArgInfo("disp12MaxDisp", 0)))
    {
        ERRWRAP2_NAPI(info, cv::validateDisparity(disparity, cost, minDisparity, numberOfDisparities, disp12MaxDisp));
        return jsopencv_from(info, disparity);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_disparity = NULL;
    UMat disparity;
    Napi::Value* jsobj_cost = NULL;
    UMat cost;
    Napi::Value* jsobj_minDisparity = NULL;
    int minDisparity=0;
    Napi::Value* jsobj_numberOfDisparities = NULL;
    int numberOfDisparities=0;
    Napi::Value* jsobj_disp12MaxDisp = NULL;
    int disp12MaxDisp=1;

    const char* keywords[] = { "disparity", "cost", "minDisparity", "numberOfDisparities", "disp12MaxDisp", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|O:validateDisparity", (char**)keywords, &jsobj_disparity, &jsobj_cost, &jsobj_minDisparity, &jsobj_numberOfDisparities, &jsobj_disp12MaxDisp) &&
        jsopencv_to_safe(jsobj_disparity, disparity, ArgInfo("disparity", 1)) &&
        jsopencv_to_safe(jsobj_cost, cost, ArgInfo("cost", 0)) &&
        jsopencv_to_safe(jsobj_minDisparity, minDisparity, ArgInfo("minDisparity", 0)) &&
        jsopencv_to_safe(jsobj_numberOfDisparities, numberOfDisparities, ArgInfo("numberOfDisparities", 0)) &&
        jsopencv_to_safe(jsobj_disp12MaxDisp, disp12MaxDisp, ArgInfo("disp12MaxDisp", 0)))
    {
        ERRWRAP2_NAPI(info, cv::validateDisparity(disparity, cost, minDisparity, numberOfDisparities, disp12MaxDisp));
        return jsopencv_from(info, disparity);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "validateDisparity");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_vconcat(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    vector_Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;

    const char* keywords[] = { "src", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:vconcat", (char**)keywords, &jsobj_src, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)))
    {
        ERRWRAP2_NAPI(info, cv::vconcat(src, dst));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    vector_UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;

    const char* keywords[] = { "src", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:vconcat", (char**)keywords, &jsobj_src, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)))
    {
        ERRWRAP2_NAPI(info, cv::vconcat(src, dst));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "vconcat");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_waitKey(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_delay = NULL;
    int delay=0;
    int retval;

    const char* keywords[] = { "delay", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|O:waitKey", (char**)keywords, &jsobj_delay) &&
        jsopencv_to_safe(jsobj_delay, delay, ArgInfo("delay", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::waitKey(delay));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_waitKeyEx(const Napi::CallbackInfo &info)
{
    using namespace cv;

    Napi::Value* jsobj_delay = NULL;
    int delay=0;
    int retval;

    const char* keywords[] = { "delay", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|O:waitKeyEx", (char**)keywords, &jsobj_delay) &&
        jsopencv_to_safe(jsobj_delay, delay, ArgInfo("delay", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::waitKeyEx(delay));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_warpAffine(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_M = NULL;
    Mat M;
    Napi::Value* jsobj_dsize = NULL;
    Size dsize;
    Napi::Value* jsobj_flags = NULL;
    int flags=INTER_LINEAR;
    Napi::Value* jsobj_borderMode = NULL;
    int borderMode=BORDER_CONSTANT;
    Napi::Value* jsobj_borderValue = NULL;
    Scalar borderValue;

    const char* keywords[] = { "src", "M", "dsize", "dst", "flags", "borderMode", "borderValue", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOOO:warpAffine", (char**)keywords, &jsobj_src, &jsobj_M, &jsobj_dsize, &jsobj_dst, &jsobj_flags, &jsobj_borderMode, &jsobj_borderValue) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_M, M, ArgInfo("M", 0)) &&
        jsopencv_to_safe(jsobj_dsize, dsize, ArgInfo("dsize", 0)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_borderMode, borderMode, ArgInfo("borderMode", 0)) &&
        jsopencv_to_safe(jsobj_borderValue, borderValue, ArgInfo("borderValue", 0)))
    {
        ERRWRAP2_NAPI(info, cv::warpAffine(src, dst, M, dsize, flags, borderMode, borderValue));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_M = NULL;
    UMat M;
    Napi::Value* jsobj_dsize = NULL;
    Size dsize;
    Napi::Value* jsobj_flags = NULL;
    int flags=INTER_LINEAR;
    Napi::Value* jsobj_borderMode = NULL;
    int borderMode=BORDER_CONSTANT;
    Napi::Value* jsobj_borderValue = NULL;
    Scalar borderValue;

    const char* keywords[] = { "src", "M", "dsize", "dst", "flags", "borderMode", "borderValue", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOOO:warpAffine", (char**)keywords, &jsobj_src, &jsobj_M, &jsobj_dsize, &jsobj_dst, &jsobj_flags, &jsobj_borderMode, &jsobj_borderValue) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_M, M, ArgInfo("M", 0)) &&
        jsopencv_to_safe(jsobj_dsize, dsize, ArgInfo("dsize", 0)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_borderMode, borderMode, ArgInfo("borderMode", 0)) &&
        jsopencv_to_safe(jsobj_borderValue, borderValue, ArgInfo("borderValue", 0)))
    {
        ERRWRAP2_NAPI(info, cv::warpAffine(src, dst, M, dsize, flags, borderMode, borderValue));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "warpAffine");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_warpPerspective(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_M = NULL;
    Mat M;
    Napi::Value* jsobj_dsize = NULL;
    Size dsize;
    Napi::Value* jsobj_flags = NULL;
    int flags=INTER_LINEAR;
    Napi::Value* jsobj_borderMode = NULL;
    int borderMode=BORDER_CONSTANT;
    Napi::Value* jsobj_borderValue = NULL;
    Scalar borderValue;

    const char* keywords[] = { "src", "M", "dsize", "dst", "flags", "borderMode", "borderValue", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOOO:warpPerspective", (char**)keywords, &jsobj_src, &jsobj_M, &jsobj_dsize, &jsobj_dst, &jsobj_flags, &jsobj_borderMode, &jsobj_borderValue) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_M, M, ArgInfo("M", 0)) &&
        jsopencv_to_safe(jsobj_dsize, dsize, ArgInfo("dsize", 0)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_borderMode, borderMode, ArgInfo("borderMode", 0)) &&
        jsopencv_to_safe(jsobj_borderValue, borderValue, ArgInfo("borderValue", 0)))
    {
        ERRWRAP2_NAPI(info, cv::warpPerspective(src, dst, M, dsize, flags, borderMode, borderValue));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_M = NULL;
    UMat M;
    Napi::Value* jsobj_dsize = NULL;
    Size dsize;
    Napi::Value* jsobj_flags = NULL;
    int flags=INTER_LINEAR;
    Napi::Value* jsobj_borderMode = NULL;
    int borderMode=BORDER_CONSTANT;
    Napi::Value* jsobj_borderValue = NULL;
    Scalar borderValue;

    const char* keywords[] = { "src", "M", "dsize", "dst", "flags", "borderMode", "borderValue", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOOO:warpPerspective", (char**)keywords, &jsobj_src, &jsobj_M, &jsobj_dsize, &jsobj_dst, &jsobj_flags, &jsobj_borderMode, &jsobj_borderValue) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_M, M, ArgInfo("M", 0)) &&
        jsopencv_to_safe(jsobj_dsize, dsize, ArgInfo("dsize", 0)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_borderMode, borderMode, ArgInfo("borderMode", 0)) &&
        jsopencv_to_safe(jsobj_borderValue, borderValue, ArgInfo("borderValue", 0)))
    {
        ERRWRAP2_NAPI(info, cv::warpPerspective(src, dst, M, dsize, flags, borderMode, borderValue));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "warpPerspective");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_warpPolar(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_dsize = NULL;
    Size dsize;
    Napi::Value* jsobj_center = NULL;
    Point2f center;
    Napi::Value* jsobj_maxRadius = NULL;
    double maxRadius=0;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;

    const char* keywords[] = { "src", "dsize", "center", "maxRadius", "flags", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOO|O:warpPolar", (char**)keywords, &jsobj_src, &jsobj_dsize, &jsobj_center, &jsobj_maxRadius, &jsobj_flags, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_dsize, dsize, ArgInfo("dsize", 0)) &&
        jsopencv_to_safe(jsobj_center, center, ArgInfo("center", 0)) &&
        jsopencv_to_safe(jsobj_maxRadius, maxRadius, ArgInfo("maxRadius", 0)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, cv::warpPolar(src, dst, dsize, center, maxRadius, flags));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_dsize = NULL;
    Size dsize;
    Napi::Value* jsobj_center = NULL;
    Point2f center;
    Napi::Value* jsobj_maxRadius = NULL;
    double maxRadius=0;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;

    const char* keywords[] = { "src", "dsize", "center", "maxRadius", "flags", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOO|O:warpPolar", (char**)keywords, &jsobj_src, &jsobj_dsize, &jsobj_center, &jsobj_maxRadius, &jsobj_flags, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_dsize, dsize, ArgInfo("dsize", 0)) &&
        jsopencv_to_safe(jsobj_center, center, ArgInfo("center", 0)) &&
        jsopencv_to_safe(jsobj_maxRadius, maxRadius, ArgInfo("maxRadius", 0)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, cv::warpPolar(src, dst, dsize, center, maxRadius, flags));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "warpPolar");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_watershed(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_image = NULL;
    Mat image;
    Napi::Value* jsobj_markers = NULL;
    Mat markers;

    const char* keywords[] = { "image", "markers", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:watershed", (char**)keywords, &jsobj_image, &jsobj_markers) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_markers, markers, ArgInfo("markers", 1)))
    {
        ERRWRAP2_NAPI(info, cv::watershed(image, markers));
        return jsopencv_from(info, markers);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_image = NULL;
    UMat image;
    Napi::Value* jsobj_markers = NULL;
    UMat markers;

    const char* keywords[] = { "image", "markers", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:watershed", (char**)keywords, &jsobj_image, &jsobj_markers) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_markers, markers, ArgInfo("markers", 1)))
    {
        ERRWRAP2_NAPI(info, cv::watershed(image, markers));
        return jsopencv_from(info, markers);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "watershed");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_writeOpticalFlow(const Napi::CallbackInfo &info)
{
    using namespace cv;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_path = NULL;
    String path;
    Napi::Value* jsobj_flow = NULL;
    Mat flow;
    bool retval;

    const char* keywords[] = { "path", "flow", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:writeOpticalFlow", (char**)keywords, &jsobj_path, &jsobj_flow) &&
        jsopencv_to_safe(jsobj_path, path, ArgInfo("path", 0)) &&
        jsopencv_to_safe(jsobj_flow, flow, ArgInfo("flow", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::writeOpticalFlow(path, flow));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_path = NULL;
    String path;
    Napi::Value* jsobj_flow = NULL;
    UMat flow;
    bool retval;

    const char* keywords[] = { "path", "flow", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:writeOpticalFlow", (char**)keywords, &jsobj_path, &jsobj_flow) &&
        jsopencv_to_safe(jsobj_path, path, ArgInfo("path", 0)) &&
        jsopencv_to_safe(jsobj_flow, flow, ArgInfo("flow", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::writeOpticalFlow(path, flow));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "writeOpticalFlow");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_aruco_Dictionary_getBitsFromByteList(const Napi::CallbackInfo &info)
{
    using namespace cv::aruco;

    Napi::Value* jsobj_byteList = NULL;
    Mat byteList;
    Napi::Value* jsobj_markerSize = NULL;
    int markerSize=0;
    Mat retval;

    const char* keywords[] = { "byteList", "markerSize", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:Dictionary_getBitsFromByteList", (char**)keywords, &jsobj_byteList, &jsobj_markerSize) &&
        jsopencv_to_safe(jsobj_byteList, byteList, ArgInfo("byteList", 0)) &&
        jsopencv_to_safe(jsobj_markerSize, markerSize, ArgInfo("markerSize", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::aruco::Dictionary::getBitsFromByteList(byteList, markerSize));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_aruco_Dictionary_getByteListFromBits(const Napi::CallbackInfo &info)
{
    using namespace cv::aruco;

    Napi::Value* jsobj_bits = NULL;
    Mat bits;
    Mat retval;

    const char* keywords[] = { "bits", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:Dictionary_getByteListFromBits", (char**)keywords, &jsobj_bits) &&
        jsopencv_to_safe(jsobj_bits, bits, ArgInfo("bits", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::aruco::Dictionary::getByteListFromBits(bits));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_aruco_drawDetectedCornersCharuco(const Napi::CallbackInfo &info)
{
    using namespace cv::aruco;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_image = NULL;
    Mat image;
    Napi::Value* jsobj_charucoCorners = NULL;
    Mat charucoCorners;
    Napi::Value* jsobj_charucoIds = NULL;
    Mat charucoIds;
    Napi::Value* jsobj_cornerColor = NULL;
    Scalar cornerColor=Scalar(255, 0, 0);

    const char* keywords[] = { "image", "charucoCorners", "charucoIds", "cornerColor", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:drawDetectedCornersCharuco", (char**)keywords, &jsobj_image, &jsobj_charucoCorners, &jsobj_charucoIds, &jsobj_cornerColor) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 1)) &&
        jsopencv_to_safe(jsobj_charucoCorners, charucoCorners, ArgInfo("charucoCorners", 0)) &&
        jsopencv_to_safe(jsobj_charucoIds, charucoIds, ArgInfo("charucoIds", 0)) &&
        jsopencv_to_safe(jsobj_cornerColor, cornerColor, ArgInfo("cornerColor", 0)))
    {
        ERRWRAP2_NAPI(info, cv::aruco::drawDetectedCornersCharuco(image, charucoCorners, charucoIds, cornerColor));
        return jsopencv_from(info, image);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_image = NULL;
    UMat image;
    Napi::Value* jsobj_charucoCorners = NULL;
    UMat charucoCorners;
    Napi::Value* jsobj_charucoIds = NULL;
    UMat charucoIds;
    Napi::Value* jsobj_cornerColor = NULL;
    Scalar cornerColor=Scalar(255, 0, 0);

    const char* keywords[] = { "image", "charucoCorners", "charucoIds", "cornerColor", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:drawDetectedCornersCharuco", (char**)keywords, &jsobj_image, &jsobj_charucoCorners, &jsobj_charucoIds, &jsobj_cornerColor) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 1)) &&
        jsopencv_to_safe(jsobj_charucoCorners, charucoCorners, ArgInfo("charucoCorners", 0)) &&
        jsopencv_to_safe(jsobj_charucoIds, charucoIds, ArgInfo("charucoIds", 0)) &&
        jsopencv_to_safe(jsobj_cornerColor, cornerColor, ArgInfo("cornerColor", 0)))
    {
        ERRWRAP2_NAPI(info, cv::aruco::drawDetectedCornersCharuco(image, charucoCorners, charucoIds, cornerColor));
        return jsopencv_from(info, image);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "drawDetectedCornersCharuco");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_aruco_drawDetectedDiamonds(const Napi::CallbackInfo &info)
{
    using namespace cv::aruco;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_image = NULL;
    Mat image;
    Napi::Value* jsobj_diamondCorners = NULL;
    vector_Mat diamondCorners;
    Napi::Value* jsobj_diamondIds = NULL;
    Mat diamondIds;
    Napi::Value* jsobj_borderColor = NULL;
    Scalar borderColor=Scalar(0, 0, 255);

    const char* keywords[] = { "image", "diamondCorners", "diamondIds", "borderColor", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:drawDetectedDiamonds", (char**)keywords, &jsobj_image, &jsobj_diamondCorners, &jsobj_diamondIds, &jsobj_borderColor) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 1)) &&
        jsopencv_to_safe(jsobj_diamondCorners, diamondCorners, ArgInfo("diamondCorners", 0)) &&
        jsopencv_to_safe(jsobj_diamondIds, diamondIds, ArgInfo("diamondIds", 0)) &&
        jsopencv_to_safe(jsobj_borderColor, borderColor, ArgInfo("borderColor", 0)))
    {
        ERRWRAP2_NAPI(info, cv::aruco::drawDetectedDiamonds(image, diamondCorners, diamondIds, borderColor));
        return jsopencv_from(info, image);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_image = NULL;
    UMat image;
    Napi::Value* jsobj_diamondCorners = NULL;
    vector_UMat diamondCorners;
    Napi::Value* jsobj_diamondIds = NULL;
    UMat diamondIds;
    Napi::Value* jsobj_borderColor = NULL;
    Scalar borderColor=Scalar(0, 0, 255);

    const char* keywords[] = { "image", "diamondCorners", "diamondIds", "borderColor", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:drawDetectedDiamonds", (char**)keywords, &jsobj_image, &jsobj_diamondCorners, &jsobj_diamondIds, &jsobj_borderColor) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 1)) &&
        jsopencv_to_safe(jsobj_diamondCorners, diamondCorners, ArgInfo("diamondCorners", 0)) &&
        jsopencv_to_safe(jsobj_diamondIds, diamondIds, ArgInfo("diamondIds", 0)) &&
        jsopencv_to_safe(jsobj_borderColor, borderColor, ArgInfo("borderColor", 0)))
    {
        ERRWRAP2_NAPI(info, cv::aruco::drawDetectedDiamonds(image, diamondCorners, diamondIds, borderColor));
        return jsopencv_from(info, image);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "drawDetectedDiamonds");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_aruco_drawDetectedMarkers(const Napi::CallbackInfo &info)
{
    using namespace cv::aruco;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_image = NULL;
    Mat image;
    Napi::Value* jsobj_corners = NULL;
    vector_Mat corners;
    Napi::Value* jsobj_ids = NULL;
    Mat ids;
    Napi::Value* jsobj_borderColor = NULL;
    Scalar borderColor=Scalar(0, 255, 0);

    const char* keywords[] = { "image", "corners", "ids", "borderColor", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:drawDetectedMarkers", (char**)keywords, &jsobj_image, &jsobj_corners, &jsobj_ids, &jsobj_borderColor) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 1)) &&
        jsopencv_to_safe(jsobj_corners, corners, ArgInfo("corners", 0)) &&
        jsopencv_to_safe(jsobj_ids, ids, ArgInfo("ids", 0)) &&
        jsopencv_to_safe(jsobj_borderColor, borderColor, ArgInfo("borderColor", 0)))
    {
        ERRWRAP2_NAPI(info, cv::aruco::drawDetectedMarkers(image, corners, ids, borderColor));
        return jsopencv_from(info, image);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_image = NULL;
    UMat image;
    Napi::Value* jsobj_corners = NULL;
    vector_UMat corners;
    Napi::Value* jsobj_ids = NULL;
    UMat ids;
    Napi::Value* jsobj_borderColor = NULL;
    Scalar borderColor=Scalar(0, 255, 0);

    const char* keywords[] = { "image", "corners", "ids", "borderColor", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:drawDetectedMarkers", (char**)keywords, &jsobj_image, &jsobj_corners, &jsobj_ids, &jsobj_borderColor) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 1)) &&
        jsopencv_to_safe(jsobj_corners, corners, ArgInfo("corners", 0)) &&
        jsopencv_to_safe(jsobj_ids, ids, ArgInfo("ids", 0)) &&
        jsopencv_to_safe(jsobj_borderColor, borderColor, ArgInfo("borderColor", 0)))
    {
        ERRWRAP2_NAPI(info, cv::aruco::drawDetectedMarkers(image, corners, ids, borderColor));
        return jsopencv_from(info, image);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "drawDetectedMarkers");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_aruco_extendDictionary(const Napi::CallbackInfo &info)
{
    using namespace cv::aruco;

    Napi::Value* jsobj_nMarkers = NULL;
    int nMarkers=0;
    Napi::Value* jsobj_markerSize = NULL;
    int markerSize=0;
    Napi::Value* jsobj_baseDictionary = NULL;
    Dictionary baseDictionary;
    Napi::Value* jsobj_randomSeed = NULL;
    int randomSeed=0;
    Dictionary retval;

    const char* keywords[] = { "nMarkers", "markerSize", "baseDictionary", "randomSeed", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:extendDictionary", (char**)keywords, &jsobj_nMarkers, &jsobj_markerSize, &jsobj_baseDictionary, &jsobj_randomSeed) &&
        jsopencv_to_safe(jsobj_nMarkers, nMarkers, ArgInfo("nMarkers", 0)) &&
        jsopencv_to_safe(jsobj_markerSize, markerSize, ArgInfo("markerSize", 0)) &&
        jsopencv_to_safe(jsobj_baseDictionary, baseDictionary, ArgInfo("baseDictionary", 0)) &&
        jsopencv_to_safe(jsobj_randomSeed, randomSeed, ArgInfo("randomSeed", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::aruco::extendDictionary(nMarkers, markerSize, baseDictionary, randomSeed));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_aruco_generateImageMarker(const Napi::CallbackInfo &info)
{
    using namespace cv::aruco;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_dictionary = NULL;
    Dictionary dictionary;
    Napi::Value* jsobj_id = NULL;
    int id=0;
    Napi::Value* jsobj_sidePixels = NULL;
    int sidePixels=0;
    Napi::Value* jsobj_img = NULL;
    Mat img;
    Napi::Value* jsobj_borderBits = NULL;
    int borderBits=1;

    const char* keywords[] = { "dictionary", "id", "sidePixels", "img", "borderBits", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OO:generateImageMarker", (char**)keywords, &jsobj_dictionary, &jsobj_id, &jsobj_sidePixels, &jsobj_img, &jsobj_borderBits) &&
        jsopencv_to_safe(jsobj_dictionary, dictionary, ArgInfo("dictionary", 0)) &&
        jsopencv_to_safe(jsobj_id, id, ArgInfo("id", 0)) &&
        jsopencv_to_safe(jsobj_sidePixels, sidePixels, ArgInfo("sidePixels", 0)) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 1)) &&
        jsopencv_to_safe(jsobj_borderBits, borderBits, ArgInfo("borderBits", 0)))
    {
        ERRWRAP2_NAPI(info, cv::aruco::generateImageMarker(dictionary, id, sidePixels, img, borderBits));
        return jsopencv_from(info, img);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_dictionary = NULL;
    Dictionary dictionary;
    Napi::Value* jsobj_id = NULL;
    int id=0;
    Napi::Value* jsobj_sidePixels = NULL;
    int sidePixels=0;
    Napi::Value* jsobj_img = NULL;
    UMat img;
    Napi::Value* jsobj_borderBits = NULL;
    int borderBits=1;

    const char* keywords[] = { "dictionary", "id", "sidePixels", "img", "borderBits", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OO:generateImageMarker", (char**)keywords, &jsobj_dictionary, &jsobj_id, &jsobj_sidePixels, &jsobj_img, &jsobj_borderBits) &&
        jsopencv_to_safe(jsobj_dictionary, dictionary, ArgInfo("dictionary", 0)) &&
        jsopencv_to_safe(jsobj_id, id, ArgInfo("id", 0)) &&
        jsopencv_to_safe(jsobj_sidePixels, sidePixels, ArgInfo("sidePixels", 0)) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 1)) &&
        jsopencv_to_safe(jsobj_borderBits, borderBits, ArgInfo("borderBits", 0)))
    {
        ERRWRAP2_NAPI(info, cv::aruco::generateImageMarker(dictionary, id, sidePixels, img, borderBits));
        return jsopencv_from(info, img);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "generateImageMarker");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_aruco_getPredefinedDictionary(const Napi::CallbackInfo &info)
{
    using namespace cv::aruco;

    Napi::Value* jsobj_dict = NULL;
    int dict=0;
    Dictionary retval;

    const char* keywords[] = { "dict", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:getPredefinedDictionary", (char**)keywords, &jsobj_dict) &&
        jsopencv_to_safe(jsobj_dict, dict, ArgInfo("dict", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::aruco::getPredefinedDictionary(dict));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_cuda_Event_elapsedTime(const Napi::CallbackInfo &info)
{
    using namespace cv::cuda;

    Napi::Value* jsobj_start = NULL;
    Event start;
    Napi::Value* jsobj_end = NULL;
    Event end;
    float retval;

    const char* keywords[] = { "start", "end", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:Event_elapsedTime", (char**)keywords, &jsobj_start, &jsobj_end) &&
        jsopencv_to_safe(jsobj_start, start, ArgInfo("start", 0)) &&
        jsopencv_to_safe(jsobj_end, end, ArgInfo("end", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::cuda::Event::elapsedTime(start, end));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_cuda_GpuMat_defaultAllocator(const Napi::CallbackInfo &info)
{
    using namespace cv::cuda;

    GpuMat::Allocator* retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::cuda::GpuMat::defaultAllocator());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_cuda_GpuMat_setDefaultAllocator(const Napi::CallbackInfo &info)
{
    using namespace cv::cuda;

    Napi::Value* jsobj_allocator = NULL;
    GpuMat_Allocator* allocator;

    const char* keywords[] = { "allocator", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:GpuMat_setDefaultAllocator", (char**)keywords, &jsobj_allocator) &&
        jsopencv_to_safe(jsobj_allocator, allocator, ArgInfo("allocator", 0)))
    {
        ERRWRAP2_NAPI(info, cv::cuda::GpuMat::setDefaultAllocator(allocator));
        return info.Env().Null();;
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_cuda_SURF_CUDA_create(const Napi::CallbackInfo &info)
{
    using namespace cv::cuda;

    Napi::Value* jsobj__hessianThreshold = NULL;
    double _hessianThreshold=0;
    Napi::Value* jsobj__nOctaves = NULL;
    int _nOctaves=4;
    Napi::Value* jsobj__nOctaveLayers = NULL;
    int _nOctaveLayers=2;
    Napi::Value* jsobj__extended = NULL;
    bool _extended=false;
    Napi::Value* jsobj__keypointsRatio = NULL;
    float _keypointsRatio=0.01f;
    Napi::Value* jsobj__upright = NULL;
    bool _upright=false;
    Ptr<SURF_CUDA> retval;

    const char* keywords[] = { "_hessianThreshold", "_nOctaves", "_nOctaveLayers", "_extended", "_keypointsRatio", "_upright", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOOOO:SURF_CUDA_create", (char**)keywords, &jsobj__hessianThreshold, &jsobj__nOctaves, &jsobj__nOctaveLayers, &jsobj__extended, &jsobj__keypointsRatio, &jsobj__upright) &&
        jsopencv_to_safe(jsobj__hessianThreshold, _hessianThreshold, ArgInfo("_hessianThreshold", 0)) &&
        jsopencv_to_safe(jsobj__nOctaves, _nOctaves, ArgInfo("_nOctaves", 0)) &&
        jsopencv_to_safe(jsobj__nOctaveLayers, _nOctaveLayers, ArgInfo("_nOctaveLayers", 0)) &&
        jsopencv_to_safe(jsobj__extended, _extended, ArgInfo("_extended", 0)) &&
        jsopencv_to_safe(jsobj__keypointsRatio, _keypointsRatio, ArgInfo("_keypointsRatio", 0)) &&
        jsopencv_to_safe(jsobj__upright, _upright, ArgInfo("_upright", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::cuda::SURF_CUDA::create(_hessianThreshold, _nOctaves, _nOctaveLayers, _extended, _keypointsRatio, _upright));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_cuda_Stream_Null(const Napi::CallbackInfo &info)
{
    using namespace cv::cuda;

    Stream retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::cuda::Stream::Null());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_cuda_TargetArchs_has(const Napi::CallbackInfo &info)
{
    using namespace cv::cuda;

    Napi::Value* jsobj_major = NULL;
    int major=0;
    Napi::Value* jsobj_minor = NULL;
    int minor=0;
    bool retval;

    const char* keywords[] = { "major", "minor", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:TargetArchs_has", (char**)keywords, &jsobj_major, &jsobj_minor) &&
        jsopencv_to_safe(jsobj_major, major, ArgInfo("major", 0)) &&
        jsopencv_to_safe(jsobj_minor, minor, ArgInfo("minor", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::cuda::TargetArchs::has(major, minor));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_cuda_TargetArchs_hasBin(const Napi::CallbackInfo &info)
{
    using namespace cv::cuda;

    Napi::Value* jsobj_major = NULL;
    int major=0;
    Napi::Value* jsobj_minor = NULL;
    int minor=0;
    bool retval;

    const char* keywords[] = { "major", "minor", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:TargetArchs_hasBin", (char**)keywords, &jsobj_major, &jsobj_minor) &&
        jsopencv_to_safe(jsobj_major, major, ArgInfo("major", 0)) &&
        jsopencv_to_safe(jsobj_minor, minor, ArgInfo("minor", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::cuda::TargetArchs::hasBin(major, minor));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_cuda_TargetArchs_hasEqualOrGreater(const Napi::CallbackInfo &info)
{
    using namespace cv::cuda;

    Napi::Value* jsobj_major = NULL;
    int major=0;
    Napi::Value* jsobj_minor = NULL;
    int minor=0;
    bool retval;

    const char* keywords[] = { "major", "minor", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:TargetArchs_hasEqualOrGreater", (char**)keywords, &jsobj_major, &jsobj_minor) &&
        jsopencv_to_safe(jsobj_major, major, ArgInfo("major", 0)) &&
        jsopencv_to_safe(jsobj_minor, minor, ArgInfo("minor", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::cuda::TargetArchs::hasEqualOrGreater(major, minor));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_cuda_TargetArchs_hasEqualOrGreaterBin(const Napi::CallbackInfo &info)
{
    using namespace cv::cuda;

    Napi::Value* jsobj_major = NULL;
    int major=0;
    Napi::Value* jsobj_minor = NULL;
    int minor=0;
    bool retval;

    const char* keywords[] = { "major", "minor", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:TargetArchs_hasEqualOrGreaterBin", (char**)keywords, &jsobj_major, &jsobj_minor) &&
        jsopencv_to_safe(jsobj_major, major, ArgInfo("major", 0)) &&
        jsopencv_to_safe(jsobj_minor, minor, ArgInfo("minor", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::cuda::TargetArchs::hasEqualOrGreaterBin(major, minor));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_cuda_TargetArchs_hasEqualOrGreaterPtx(const Napi::CallbackInfo &info)
{
    using namespace cv::cuda;

    Napi::Value* jsobj_major = NULL;
    int major=0;
    Napi::Value* jsobj_minor = NULL;
    int minor=0;
    bool retval;

    const char* keywords[] = { "major", "minor", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:TargetArchs_hasEqualOrGreaterPtx", (char**)keywords, &jsobj_major, &jsobj_minor) &&
        jsopencv_to_safe(jsobj_major, major, ArgInfo("major", 0)) &&
        jsopencv_to_safe(jsobj_minor, minor, ArgInfo("minor", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::cuda::TargetArchs::hasEqualOrGreaterPtx(major, minor));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_cuda_TargetArchs_hasEqualOrLessPtx(const Napi::CallbackInfo &info)
{
    using namespace cv::cuda;

    Napi::Value* jsobj_major = NULL;
    int major=0;
    Napi::Value* jsobj_minor = NULL;
    int minor=0;
    bool retval;

    const char* keywords[] = { "major", "minor", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:TargetArchs_hasEqualOrLessPtx", (char**)keywords, &jsobj_major, &jsobj_minor) &&
        jsopencv_to_safe(jsobj_major, major, ArgInfo("major", 0)) &&
        jsopencv_to_safe(jsobj_minor, minor, ArgInfo("minor", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::cuda::TargetArchs::hasEqualOrLessPtx(major, minor));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_cuda_TargetArchs_hasPtx(const Napi::CallbackInfo &info)
{
    using namespace cv::cuda;

    Napi::Value* jsobj_major = NULL;
    int major=0;
    Napi::Value* jsobj_minor = NULL;
    int minor=0;
    bool retval;

    const char* keywords[] = { "major", "minor", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:TargetArchs_hasPtx", (char**)keywords, &jsobj_major, &jsobj_minor) &&
        jsopencv_to_safe(jsobj_major, major, ArgInfo("major", 0)) &&
        jsopencv_to_safe(jsobj_minor, minor, ArgInfo("minor", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::cuda::TargetArchs::hasPtx(major, minor));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_cuda_createContinuous(const Napi::CallbackInfo &info)
{
    using namespace cv::cuda;

    jsPrepareArgumentConversionErrorsStorage(3);

    {
    Napi::Value* jsobj_rows = NULL;
    int rows=0;
    Napi::Value* jsobj_cols = NULL;
    int cols=0;
    Napi::Value* jsobj_type = NULL;
    int type=0;
    Napi::Value* jsobj_arr = NULL;
    Mat arr;

    const char* keywords[] = { "rows", "cols", "type", "arr", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:createContinuous", (char**)keywords, &jsobj_rows, &jsobj_cols, &jsobj_type, &jsobj_arr) &&
        jsopencv_to_safe(jsobj_rows, rows, ArgInfo("rows", 0)) &&
        jsopencv_to_safe(jsobj_cols, cols, ArgInfo("cols", 0)) &&
        jsopencv_to_safe(jsobj_type, type, ArgInfo("type", 0)) &&
        jsopencv_to_safe(jsobj_arr, arr, ArgInfo("arr", 1)))
    {
        ERRWRAP2_NAPI(info, cv::cuda::createContinuous(rows, cols, type, arr));
        return jsopencv_from(info, arr);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_rows = NULL;
    int rows=0;
    Napi::Value* jsobj_cols = NULL;
    int cols=0;
    Napi::Value* jsobj_type = NULL;
    int type=0;
    Napi::Value* jsobj_arr = NULL;
    cuda::GpuMat arr;

    const char* keywords[] = { "rows", "cols", "type", "arr", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:createContinuous", (char**)keywords, &jsobj_rows, &jsobj_cols, &jsobj_type, &jsobj_arr) &&
        jsopencv_to_safe(jsobj_rows, rows, ArgInfo("rows", 0)) &&
        jsopencv_to_safe(jsobj_cols, cols, ArgInfo("cols", 0)) &&
        jsopencv_to_safe(jsobj_type, type, ArgInfo("type", 0)) &&
        jsopencv_to_safe(jsobj_arr, arr, ArgInfo("arr", 1)))
    {
        ERRWRAP2_NAPI(info, cv::cuda::createContinuous(rows, cols, type, arr));
        return jsopencv_from(info, arr);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_rows = NULL;
    int rows=0;
    Napi::Value* jsobj_cols = NULL;
    int cols=0;
    Napi::Value* jsobj_type = NULL;
    int type=0;
    Napi::Value* jsobj_arr = NULL;
    UMat arr;

    const char* keywords[] = { "rows", "cols", "type", "arr", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:createContinuous", (char**)keywords, &jsobj_rows, &jsobj_cols, &jsobj_type, &jsobj_arr) &&
        jsopencv_to_safe(jsobj_rows, rows, ArgInfo("rows", 0)) &&
        jsopencv_to_safe(jsobj_cols, cols, ArgInfo("cols", 0)) &&
        jsopencv_to_safe(jsobj_type, type, ArgInfo("type", 0)) &&
        jsopencv_to_safe(jsobj_arr, arr, ArgInfo("arr", 1)))
    {
        ERRWRAP2_NAPI(info, cv::cuda::createContinuous(rows, cols, type, arr));
        return jsopencv_from(info, arr);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "createContinuous");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_cuda_ensureSizeIsEnough(const Napi::CallbackInfo &info)
{
    using namespace cv::cuda;

    jsPrepareArgumentConversionErrorsStorage(3);

    {
    Napi::Value* jsobj_rows = NULL;
    int rows=0;
    Napi::Value* jsobj_cols = NULL;
    int cols=0;
    Napi::Value* jsobj_type = NULL;
    int type=0;
    Napi::Value* jsobj_arr = NULL;
    Mat arr;

    const char* keywords[] = { "rows", "cols", "type", "arr", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:ensureSizeIsEnough", (char**)keywords, &jsobj_rows, &jsobj_cols, &jsobj_type, &jsobj_arr) &&
        jsopencv_to_safe(jsobj_rows, rows, ArgInfo("rows", 0)) &&
        jsopencv_to_safe(jsobj_cols, cols, ArgInfo("cols", 0)) &&
        jsopencv_to_safe(jsobj_type, type, ArgInfo("type", 0)) &&
        jsopencv_to_safe(jsobj_arr, arr, ArgInfo("arr", 1)))
    {
        ERRWRAP2_NAPI(info, cv::cuda::ensureSizeIsEnough(rows, cols, type, arr));
        return jsopencv_from(info, arr);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_rows = NULL;
    int rows=0;
    Napi::Value* jsobj_cols = NULL;
    int cols=0;
    Napi::Value* jsobj_type = NULL;
    int type=0;
    Napi::Value* jsobj_arr = NULL;
    cuda::GpuMat arr;

    const char* keywords[] = { "rows", "cols", "type", "arr", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:ensureSizeIsEnough", (char**)keywords, &jsobj_rows, &jsobj_cols, &jsobj_type, &jsobj_arr) &&
        jsopencv_to_safe(jsobj_rows, rows, ArgInfo("rows", 0)) &&
        jsopencv_to_safe(jsobj_cols, cols, ArgInfo("cols", 0)) &&
        jsopencv_to_safe(jsobj_type, type, ArgInfo("type", 0)) &&
        jsopencv_to_safe(jsobj_arr, arr, ArgInfo("arr", 1)))
    {
        ERRWRAP2_NAPI(info, cv::cuda::ensureSizeIsEnough(rows, cols, type, arr));
        return jsopencv_from(info, arr);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_rows = NULL;
    int rows=0;
    Napi::Value* jsobj_cols = NULL;
    int cols=0;
    Napi::Value* jsobj_type = NULL;
    int type=0;
    Napi::Value* jsobj_arr = NULL;
    UMat arr;

    const char* keywords[] = { "rows", "cols", "type", "arr", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:ensureSizeIsEnough", (char**)keywords, &jsobj_rows, &jsobj_cols, &jsobj_type, &jsobj_arr) &&
        jsopencv_to_safe(jsobj_rows, rows, ArgInfo("rows", 0)) &&
        jsopencv_to_safe(jsobj_cols, cols, ArgInfo("cols", 0)) &&
        jsopencv_to_safe(jsobj_type, type, ArgInfo("type", 0)) &&
        jsopencv_to_safe(jsobj_arr, arr, ArgInfo("arr", 1)))
    {
        ERRWRAP2_NAPI(info, cv::cuda::ensureSizeIsEnough(rows, cols, type, arr));
        return jsopencv_from(info, arr);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "ensureSizeIsEnough");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_cuda_fastNlMeansDenoising(const Napi::CallbackInfo &info)
{
    using namespace cv::cuda;

    Napi::Value* jsobj_src = NULL;
    GpuMat src;
    Napi::Value* jsobj_dst = NULL;
    GpuMat dst;
    Napi::Value* jsobj_h = NULL;
    float h=0.f;
    Napi::Value* jsobj_search_window = NULL;
    int search_window=21;
    Napi::Value* jsobj_block_size = NULL;
    int block_size=7;
    Napi::Value* jsobj_stream = NULL;
    Stream stream=Stream::Null();

    const char* keywords[] = { "src", "h", "dst", "search_window", "block_size", "stream", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOOO:fastNlMeansDenoising", (char**)keywords, &jsobj_src, &jsobj_h, &jsobj_dst, &jsobj_search_window, &jsobj_block_size, &jsobj_stream) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_h, h, ArgInfo("h", 0)) &&
        jsopencv_to_safe(jsobj_search_window, search_window, ArgInfo("search_window", 0)) &&
        jsopencv_to_safe(jsobj_block_size, block_size, ArgInfo("block_size", 0)) &&
        jsopencv_to_safe(jsobj_stream, stream, ArgInfo("stream", 0)))
    {
        ERRWRAP2_NAPI(info, cv::cuda::fastNlMeansDenoising(src, dst, h, search_window, block_size, stream));
        return jsopencv_from(info, dst);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_cuda_fastNlMeansDenoisingColored(const Napi::CallbackInfo &info)
{
    using namespace cv::cuda;

    Napi::Value* jsobj_src = NULL;
    GpuMat src;
    Napi::Value* jsobj_dst = NULL;
    GpuMat dst;
    Napi::Value* jsobj_h_luminance = NULL;
    float h_luminance=0.f;
    Napi::Value* jsobj_photo_render = NULL;
    float photo_render=0.f;
    Napi::Value* jsobj_search_window = NULL;
    int search_window=21;
    Napi::Value* jsobj_block_size = NULL;
    int block_size=7;
    Napi::Value* jsobj_stream = NULL;
    Stream stream=Stream::Null();

    const char* keywords[] = { "src", "h_luminance", "photo_render", "dst", "search_window", "block_size", "stream", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOOO:fastNlMeansDenoisingColored", (char**)keywords, &jsobj_src, &jsobj_h_luminance, &jsobj_photo_render, &jsobj_dst, &jsobj_search_window, &jsobj_block_size, &jsobj_stream) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_h_luminance, h_luminance, ArgInfo("h_luminance", 0)) &&
        jsopencv_to_safe(jsobj_photo_render, photo_render, ArgInfo("photo_render", 0)) &&
        jsopencv_to_safe(jsobj_search_window, search_window, ArgInfo("search_window", 0)) &&
        jsopencv_to_safe(jsobj_block_size, block_size, ArgInfo("block_size", 0)) &&
        jsopencv_to_safe(jsobj_stream, stream, ArgInfo("stream", 0)))
    {
        ERRWRAP2_NAPI(info, cv::cuda::fastNlMeansDenoisingColored(src, dst, h_luminance, photo_render, search_window, block_size, stream));
        return jsopencv_from(info, dst);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_cuda_getCudaEnabledDeviceCount(const Napi::CallbackInfo &info)
{
    using namespace cv::cuda;

    int retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::cuda::getCudaEnabledDeviceCount());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_cuda_getDevice(const Napi::CallbackInfo &info)
{
    using namespace cv::cuda;

    int retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::cuda::getDevice());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_cuda_nonLocalMeans(const Napi::CallbackInfo &info)
{
    using namespace cv::cuda;

    Napi::Value* jsobj_src = NULL;
    GpuMat src;
    Napi::Value* jsobj_dst = NULL;
    GpuMat dst;
    Napi::Value* jsobj_h = NULL;
    float h=0.f;
    Napi::Value* jsobj_search_window = NULL;
    int search_window=21;
    Napi::Value* jsobj_block_size = NULL;
    int block_size=7;
    Napi::Value* jsobj_borderMode = NULL;
    int borderMode=BORDER_DEFAULT;
    Napi::Value* jsobj_stream = NULL;
    Stream stream=Stream::Null();

    const char* keywords[] = { "src", "h", "dst", "search_window", "block_size", "borderMode", "stream", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOOOO:nonLocalMeans", (char**)keywords, &jsobj_src, &jsobj_h, &jsobj_dst, &jsobj_search_window, &jsobj_block_size, &jsobj_borderMode, &jsobj_stream) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_h, h, ArgInfo("h", 0)) &&
        jsopencv_to_safe(jsobj_search_window, search_window, ArgInfo("search_window", 0)) &&
        jsopencv_to_safe(jsobj_block_size, block_size, ArgInfo("block_size", 0)) &&
        jsopencv_to_safe(jsobj_borderMode, borderMode, ArgInfo("borderMode", 0)) &&
        jsopencv_to_safe(jsobj_stream, stream, ArgInfo("stream", 0)))
    {
        ERRWRAP2_NAPI(info, cv::cuda::nonLocalMeans(src, dst, h, search_window, block_size, borderMode, stream));
        return jsopencv_from(info, dst);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_cuda_printCudaDeviceInfo(const Napi::CallbackInfo &info)
{
    using namespace cv::cuda;

    Napi::Value* jsobj_device = NULL;
    int device=0;

    const char* keywords[] = { "device", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:printCudaDeviceInfo", (char**)keywords, &jsobj_device) &&
        jsopencv_to_safe(jsobj_device, device, ArgInfo("device", 0)))
    {
        ERRWRAP2_NAPI(info, cv::cuda::printCudaDeviceInfo(device));
        return info.Env().Null();;
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_cuda_printShortCudaDeviceInfo(const Napi::CallbackInfo &info)
{
    using namespace cv::cuda;

    Napi::Value* jsobj_device = NULL;
    int device=0;

    const char* keywords[] = { "device", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:printShortCudaDeviceInfo", (char**)keywords, &jsobj_device) &&
        jsopencv_to_safe(jsobj_device, device, ArgInfo("device", 0)))
    {
        ERRWRAP2_NAPI(info, cv::cuda::printShortCudaDeviceInfo(device));
        return info.Env().Null();;
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_cuda_registerPageLocked(const Napi::CallbackInfo &info)
{
    using namespace cv::cuda;

    Napi::Value* jsobj_m = NULL;
    Mat m;

    const char* keywords[] = { "m", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:registerPageLocked", (char**)keywords, &jsobj_m) &&
        jsopencv_to_safe(jsobj_m, m, ArgInfo("m", 0)))
    {
        ERRWRAP2_NAPI(info, cv::cuda::registerPageLocked(m));
        return info.Env().Null();;
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_cuda_resetDevice(const Napi::CallbackInfo &info)
{
    using namespace cv::cuda;


    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, cv::cuda::resetDevice());
        return info.Env().Null();;
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_cuda_setBufferPoolConfig(const Napi::CallbackInfo &info)
{
    using namespace cv::cuda;

    Napi::Value* jsobj_deviceId = NULL;
    int deviceId=0;
    Napi::Value* jsobj_stackSize = NULL;
    size_t stackSize=0;
    Napi::Value* jsobj_stackCount = NULL;
    int stackCount=0;

    const char* keywords[] = { "deviceId", "stackSize", "stackCount", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:setBufferPoolConfig", (char**)keywords, &jsobj_deviceId, &jsobj_stackSize, &jsobj_stackCount) &&
        jsopencv_to_safe(jsobj_deviceId, deviceId, ArgInfo("deviceId", 0)) &&
        jsopencv_to_safe(jsobj_stackSize, stackSize, ArgInfo("stackSize", 0)) &&
        jsopencv_to_safe(jsobj_stackCount, stackCount, ArgInfo("stackCount", 0)))
    {
        ERRWRAP2_NAPI(info, cv::cuda::setBufferPoolConfig(deviceId, stackSize, stackCount));
        return info.Env().Null();;
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_cuda_setBufferPoolUsage(const Napi::CallbackInfo &info)
{
    using namespace cv::cuda;

    Napi::Value* jsobj_on = NULL;
    bool on=0;

    const char* keywords[] = { "on", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:setBufferPoolUsage", (char**)keywords, &jsobj_on) &&
        jsopencv_to_safe(jsobj_on, on, ArgInfo("on", 0)))
    {
        ERRWRAP2_NAPI(info, cv::cuda::setBufferPoolUsage(on));
        return info.Env().Null();;
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_cuda_setDevice(const Napi::CallbackInfo &info)
{
    using namespace cv::cuda;

    Napi::Value* jsobj_device = NULL;
    int device=0;

    const char* keywords[] = { "device", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:setDevice", (char**)keywords, &jsobj_device) &&
        jsopencv_to_safe(jsobj_device, device, ArgInfo("device", 0)))
    {
        ERRWRAP2_NAPI(info, cv::cuda::setDevice(device));
        return info.Env().Null();;
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_cuda_unregisterPageLocked(const Napi::CallbackInfo &info)
{
    using namespace cv::cuda;

    Napi::Value* jsobj_m = NULL;
    Mat m;

    const char* keywords[] = { "m", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:unregisterPageLocked", (char**)keywords, &jsobj_m) &&
        jsopencv_to_safe(jsobj_m, m, ArgInfo("m", 0)))
    {
        ERRWRAP2_NAPI(info, cv::cuda::unregisterPageLocked(m));
        return info.Env().Null();;
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_detail_strip(const Napi::CallbackInfo &info)
{
    using namespace cv::detail;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_params = NULL;
    cv::gapi::ie::PyParams params;
    gapi::GNetParam retval;

    const char* keywords[] = { "params", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:strip", (char**)keywords, &jsobj_params) &&
        jsopencv_to_safe(jsobj_params, params, ArgInfo("params", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::detail::strip(params));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_params = NULL;
    cv::gapi::onnx::PyParams params;
    gapi::GNetParam retval;

    const char* keywords[] = { "params", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:strip", (char**)keywords, &jsobj_params) &&
        jsopencv_to_safe(jsobj_params, params, ArgInfo("params", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::detail::strip(params));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "strip");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_dnn_NMSBoxes(const Napi::CallbackInfo &info)
{
    using namespace cv::dnn;

    Napi::Value* jsobj_bboxes = NULL;
    vector_Rect2d bboxes;
    Napi::Value* jsobj_scores = NULL;
    vector_float scores;
    Napi::Value* jsobj_score_threshold = NULL;
    float score_threshold=0.f;
    Napi::Value* jsobj_nms_threshold = NULL;
    float nms_threshold=0.f;
    vector_int indices;
    Napi::Value* jsobj_eta = NULL;
    float eta=1.f;
    Napi::Value* jsobj_top_k = NULL;
    int top_k=0;

    const char* keywords[] = { "bboxes", "scores", "score_threshold", "nms_threshold", "eta", "top_k", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OO:NMSBoxes", (char**)keywords, &jsobj_bboxes, &jsobj_scores, &jsobj_score_threshold, &jsobj_nms_threshold, &jsobj_eta, &jsobj_top_k) &&
        jsopencv_to_safe(jsobj_bboxes, bboxes, ArgInfo("bboxes", 0)) &&
        jsopencv_to_safe(jsobj_scores, scores, ArgInfo("scores", 0)) &&
        jsopencv_to_safe(jsobj_score_threshold, score_threshold, ArgInfo("score_threshold", 0)) &&
        jsopencv_to_safe(jsobj_nms_threshold, nms_threshold, ArgInfo("nms_threshold", 0)) &&
        jsopencv_to_safe(jsobj_eta, eta, ArgInfo("eta", 0)) &&
        jsopencv_to_safe(jsobj_top_k, top_k, ArgInfo("top_k", 0)))
    {
        ERRWRAP2_NAPI(info, cv::dnn::NMSBoxes(bboxes, scores, score_threshold, nms_threshold, indices, eta, top_k));
        return jsopencv_from(info, indices);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_dnn_NMSBoxesBatched(const Napi::CallbackInfo &info)
{
    using namespace cv::dnn;

    Napi::Value* jsobj_bboxes = NULL;
    vector_Rect2d bboxes;
    Napi::Value* jsobj_scores = NULL;
    vector_float scores;
    Napi::Value* jsobj_class_ids = NULL;
    vector_int class_ids;
    Napi::Value* jsobj_score_threshold = NULL;
    float score_threshold=0.f;
    Napi::Value* jsobj_nms_threshold = NULL;
    float nms_threshold=0.f;
    vector_int indices;
    Napi::Value* jsobj_eta = NULL;
    float eta=1.f;
    Napi::Value* jsobj_top_k = NULL;
    int top_k=0;

    const char* keywords[] = { "bboxes", "scores", "class_ids", "score_threshold", "nms_threshold", "eta", "top_k", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOO|OO:NMSBoxesBatched", (char**)keywords, &jsobj_bboxes, &jsobj_scores, &jsobj_class_ids, &jsobj_score_threshold, &jsobj_nms_threshold, &jsobj_eta, &jsobj_top_k) &&
        jsopencv_to_safe(jsobj_bboxes, bboxes, ArgInfo("bboxes", 0)) &&
        jsopencv_to_safe(jsobj_scores, scores, ArgInfo("scores", 0)) &&
        jsopencv_to_safe(jsobj_class_ids, class_ids, ArgInfo("class_ids", 0)) &&
        jsopencv_to_safe(jsobj_score_threshold, score_threshold, ArgInfo("score_threshold", 0)) &&
        jsopencv_to_safe(jsobj_nms_threshold, nms_threshold, ArgInfo("nms_threshold", 0)) &&
        jsopencv_to_safe(jsobj_eta, eta, ArgInfo("eta", 0)) &&
        jsopencv_to_safe(jsobj_top_k, top_k, ArgInfo("top_k", 0)))
    {
        ERRWRAP2_NAPI(info, cv::dnn::NMSBoxesBatched(bboxes, scores, class_ids, score_threshold, nms_threshold, indices, eta, top_k));
        return jsopencv_from(info, indices);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_dnn_NMSBoxesRotated(const Napi::CallbackInfo &info)
{
    using namespace cv::dnn;

    Napi::Value* jsobj_bboxes = NULL;
    vector_RotatedRect bboxes;
    Napi::Value* jsobj_scores = NULL;
    vector_float scores;
    Napi::Value* jsobj_score_threshold = NULL;
    float score_threshold=0.f;
    Napi::Value* jsobj_nms_threshold = NULL;
    float nms_threshold=0.f;
    vector_int indices;
    Napi::Value* jsobj_eta = NULL;
    float eta=1.f;
    Napi::Value* jsobj_top_k = NULL;
    int top_k=0;

    const char* keywords[] = { "bboxes", "scores", "score_threshold", "nms_threshold", "eta", "top_k", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OO:NMSBoxesRotated", (char**)keywords, &jsobj_bboxes, &jsobj_scores, &jsobj_score_threshold, &jsobj_nms_threshold, &jsobj_eta, &jsobj_top_k) &&
        jsopencv_to_safe(jsobj_bboxes, bboxes, ArgInfo("bboxes", 0)) &&
        jsopencv_to_safe(jsobj_scores, scores, ArgInfo("scores", 0)) &&
        jsopencv_to_safe(jsobj_score_threshold, score_threshold, ArgInfo("score_threshold", 0)) &&
        jsopencv_to_safe(jsobj_nms_threshold, nms_threshold, ArgInfo("nms_threshold", 0)) &&
        jsopencv_to_safe(jsobj_eta, eta, ArgInfo("eta", 0)) &&
        jsopencv_to_safe(jsobj_top_k, top_k, ArgInfo("top_k", 0)))
    {
        ERRWRAP2_NAPI(info, cv::dnn::NMSBoxes(bboxes, scores, score_threshold, nms_threshold, indices, eta, top_k));
        return jsopencv_from(info, indices);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_dnn_Net_readFromModelOptimizer(const Napi::CallbackInfo &info)
{
    using namespace cv::dnn;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_xml = NULL;
    String xml;
    Napi::Value* jsobj_bin = NULL;
    String bin;
    Net retval;

    const char* keywords[] = { "xml", "bin", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:Net_readFromModelOptimizer", (char**)keywords, &jsobj_xml, &jsobj_bin) &&
        jsopencv_to_safe(jsobj_xml, xml, ArgInfo("xml", 0)) &&
        jsopencv_to_safe(jsobj_bin, bin, ArgInfo("bin", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::dnn::Net::readFromModelOptimizer(xml, bin));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_bufferModelConfig = NULL;
    vector_uchar bufferModelConfig;
    Napi::Value* jsobj_bufferWeights = NULL;
    vector_uchar bufferWeights;
    Net retval;

    const char* keywords[] = { "bufferModelConfig", "bufferWeights", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:Net_readFromModelOptimizer", (char**)keywords, &jsobj_bufferModelConfig, &jsobj_bufferWeights) &&
        jsopencv_to_safe(jsobj_bufferModelConfig, bufferModelConfig, ArgInfo("bufferModelConfig", 0)) &&
        jsopencv_to_safe(jsobj_bufferWeights, bufferWeights, ArgInfo("bufferWeights", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::dnn::Net::readFromModelOptimizer(bufferModelConfig, bufferWeights));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "Net_readFromModelOptimizer");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_dnn_blobFromImage(const Napi::CallbackInfo &info)
{
    using namespace cv::dnn;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_image = NULL;
    Mat image;
    Napi::Value* jsobj_scalefactor = NULL;
    double scalefactor=1.0;
    Napi::Value* jsobj_size = NULL;
    Size size;
    Napi::Value* jsobj_mean = NULL;
    Scalar mean;
    Napi::Value* jsobj_swapRB = NULL;
    bool swapRB=false;
    Napi::Value* jsobj_crop = NULL;
    bool crop=false;
    Napi::Value* jsobj_ddepth = NULL;
    int ddepth=CV_32F;
    Mat retval;

    const char* keywords[] = { "image", "scalefactor", "size", "mean", "swapRB", "crop", "ddepth", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOOOOO:blobFromImage", (char**)keywords, &jsobj_image, &jsobj_scalefactor, &jsobj_size, &jsobj_mean, &jsobj_swapRB, &jsobj_crop, &jsobj_ddepth) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_scalefactor, scalefactor, ArgInfo("scalefactor", 0)) &&
        jsopencv_to_safe(jsobj_size, size, ArgInfo("size", 0)) &&
        jsopencv_to_safe(jsobj_mean, mean, ArgInfo("mean", 0)) &&
        jsopencv_to_safe(jsobj_swapRB, swapRB, ArgInfo("swapRB", 0)) &&
        jsopencv_to_safe(jsobj_crop, crop, ArgInfo("crop", 0)) &&
        jsopencv_to_safe(jsobj_ddepth, ddepth, ArgInfo("ddepth", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::dnn::blobFromImage(image, scalefactor, size, mean, swapRB, crop, ddepth));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_image = NULL;
    UMat image;
    Napi::Value* jsobj_scalefactor = NULL;
    double scalefactor=1.0;
    Napi::Value* jsobj_size = NULL;
    Size size;
    Napi::Value* jsobj_mean = NULL;
    Scalar mean;
    Napi::Value* jsobj_swapRB = NULL;
    bool swapRB=false;
    Napi::Value* jsobj_crop = NULL;
    bool crop=false;
    Napi::Value* jsobj_ddepth = NULL;
    int ddepth=CV_32F;
    Mat retval;

    const char* keywords[] = { "image", "scalefactor", "size", "mean", "swapRB", "crop", "ddepth", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOOOOO:blobFromImage", (char**)keywords, &jsobj_image, &jsobj_scalefactor, &jsobj_size, &jsobj_mean, &jsobj_swapRB, &jsobj_crop, &jsobj_ddepth) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_scalefactor, scalefactor, ArgInfo("scalefactor", 0)) &&
        jsopencv_to_safe(jsobj_size, size, ArgInfo("size", 0)) &&
        jsopencv_to_safe(jsobj_mean, mean, ArgInfo("mean", 0)) &&
        jsopencv_to_safe(jsobj_swapRB, swapRB, ArgInfo("swapRB", 0)) &&
        jsopencv_to_safe(jsobj_crop, crop, ArgInfo("crop", 0)) &&
        jsopencv_to_safe(jsobj_ddepth, ddepth, ArgInfo("ddepth", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::dnn::blobFromImage(image, scalefactor, size, mean, swapRB, crop, ddepth));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "blobFromImage");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_dnn_blobFromImages(const Napi::CallbackInfo &info)
{
    using namespace cv::dnn;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_images = NULL;
    vector_Mat images;
    Napi::Value* jsobj_scalefactor = NULL;
    double scalefactor=1.0;
    Napi::Value* jsobj_size = NULL;
    Size size;
    Napi::Value* jsobj_mean = NULL;
    Scalar mean;
    Napi::Value* jsobj_swapRB = NULL;
    bool swapRB=false;
    Napi::Value* jsobj_crop = NULL;
    bool crop=false;
    Napi::Value* jsobj_ddepth = NULL;
    int ddepth=CV_32F;
    Mat retval;

    const char* keywords[] = { "images", "scalefactor", "size", "mean", "swapRB", "crop", "ddepth", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOOOOO:blobFromImages", (char**)keywords, &jsobj_images, &jsobj_scalefactor, &jsobj_size, &jsobj_mean, &jsobj_swapRB, &jsobj_crop, &jsobj_ddepth) &&
        jsopencv_to_safe(jsobj_images, images, ArgInfo("images", 0)) &&
        jsopencv_to_safe(jsobj_scalefactor, scalefactor, ArgInfo("scalefactor", 0)) &&
        jsopencv_to_safe(jsobj_size, size, ArgInfo("size", 0)) &&
        jsopencv_to_safe(jsobj_mean, mean, ArgInfo("mean", 0)) &&
        jsopencv_to_safe(jsobj_swapRB, swapRB, ArgInfo("swapRB", 0)) &&
        jsopencv_to_safe(jsobj_crop, crop, ArgInfo("crop", 0)) &&
        jsopencv_to_safe(jsobj_ddepth, ddepth, ArgInfo("ddepth", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::dnn::blobFromImages(images, scalefactor, size, mean, swapRB, crop, ddepth));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_images = NULL;
    vector_UMat images;
    Napi::Value* jsobj_scalefactor = NULL;
    double scalefactor=1.0;
    Napi::Value* jsobj_size = NULL;
    Size size;
    Napi::Value* jsobj_mean = NULL;
    Scalar mean;
    Napi::Value* jsobj_swapRB = NULL;
    bool swapRB=false;
    Napi::Value* jsobj_crop = NULL;
    bool crop=false;
    Napi::Value* jsobj_ddepth = NULL;
    int ddepth=CV_32F;
    Mat retval;

    const char* keywords[] = { "images", "scalefactor", "size", "mean", "swapRB", "crop", "ddepth", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOOOOO:blobFromImages", (char**)keywords, &jsobj_images, &jsobj_scalefactor, &jsobj_size, &jsobj_mean, &jsobj_swapRB, &jsobj_crop, &jsobj_ddepth) &&
        jsopencv_to_safe(jsobj_images, images, ArgInfo("images", 0)) &&
        jsopencv_to_safe(jsobj_scalefactor, scalefactor, ArgInfo("scalefactor", 0)) &&
        jsopencv_to_safe(jsobj_size, size, ArgInfo("size", 0)) &&
        jsopencv_to_safe(jsobj_mean, mean, ArgInfo("mean", 0)) &&
        jsopencv_to_safe(jsobj_swapRB, swapRB, ArgInfo("swapRB", 0)) &&
        jsopencv_to_safe(jsobj_crop, crop, ArgInfo("crop", 0)) &&
        jsopencv_to_safe(jsobj_ddepth, ddepth, ArgInfo("ddepth", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::dnn::blobFromImages(images, scalefactor, size, mean, swapRB, crop, ddepth));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "blobFromImages");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_dnn_getAvailableTargets(const Napi::CallbackInfo &info)
{
    using namespace cv::dnn;

    Napi::Value* jsobj_be = NULL;
    dnn_Backend be=static_cast<dnn_Backend>(0);
    std::vector<Target> retval;

    const char* keywords[] = { "be", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:getAvailableTargets", (char**)keywords, &jsobj_be) &&
        jsopencv_to_safe(jsobj_be, be, ArgInfo("be", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::dnn::getAvailableTargets(be));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_dnn_imagesFromBlob(const Napi::CallbackInfo &info)
{
    using namespace cv::dnn;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_blob_ = NULL;
    Mat blob_;
    Napi::Value* jsobj_images_ = NULL;
    vector_Mat images_;

    const char* keywords[] = { "blob_", "images_", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:imagesFromBlob", (char**)keywords, &jsobj_blob_, &jsobj_images_) &&
        jsopencv_to_safe(jsobj_blob_, blob_, ArgInfo("blob_", 0)) &&
        jsopencv_to_safe(jsobj_images_, images_, ArgInfo("images_", 1)))
    {
        ERRWRAP2_NAPI(info, cv::dnn::imagesFromBlob(blob_, images_));
        return jsopencv_from(info, images_);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_blob_ = NULL;
    Mat blob_;
    Napi::Value* jsobj_images_ = NULL;
    vector_UMat images_;

    const char* keywords[] = { "blob_", "images_", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:imagesFromBlob", (char**)keywords, &jsobj_blob_, &jsobj_images_) &&
        jsopencv_to_safe(jsobj_blob_, blob_, ArgInfo("blob_", 0)) &&
        jsopencv_to_safe(jsobj_images_, images_, ArgInfo("images_", 1)))
    {
        ERRWRAP2_NAPI(info, cv::dnn::imagesFromBlob(blob_, images_));
        return jsopencv_from(info, images_);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "imagesFromBlob");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_dnn_readNet(const Napi::CallbackInfo &info)
{
    using namespace cv::dnn;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_model = NULL;
    String model;
    Napi::Value* jsobj_config = NULL;
    String config="";
    Napi::Value* jsobj_framework = NULL;
    String framework="";
    Net retval;

    const char* keywords[] = { "model", "config", "framework", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OO:readNet", (char**)keywords, &jsobj_model, &jsobj_config, &jsobj_framework) &&
        jsopencv_to_safe(jsobj_model, model, ArgInfo("model", 0)) &&
        jsopencv_to_safe(jsobj_config, config, ArgInfo("config", 0)) &&
        jsopencv_to_safe(jsobj_framework, framework, ArgInfo("framework", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::dnn::readNet(model, config, framework));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_framework = NULL;
    String framework;
    Napi::Value* jsobj_bufferModel = NULL;
    vector_uchar bufferModel;
    Napi::Value* jsobj_bufferConfig = NULL;
    vector_uchar bufferConfig=std::vector<uchar>();
    Net retval;

    const char* keywords[] = { "framework", "bufferModel", "bufferConfig", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:readNet", (char**)keywords, &jsobj_framework, &jsobj_bufferModel, &jsobj_bufferConfig) &&
        jsopencv_to_safe(jsobj_framework, framework, ArgInfo("framework", 0)) &&
        jsopencv_to_safe(jsobj_bufferModel, bufferModel, ArgInfo("bufferModel", 0)) &&
        jsopencv_to_safe(jsobj_bufferConfig, bufferConfig, ArgInfo("bufferConfig", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::dnn::readNet(framework, bufferModel, bufferConfig));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "readNet");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_dnn_readNetFromCaffe(const Napi::CallbackInfo &info)
{
    using namespace cv::dnn;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_prototxt = NULL;
    String prototxt;
    Napi::Value* jsobj_caffeModel = NULL;
    String caffeModel;
    Net retval;

    const char* keywords[] = { "prototxt", "caffeModel", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:readNetFromCaffe", (char**)keywords, &jsobj_prototxt, &jsobj_caffeModel) &&
        jsopencv_to_safe(jsobj_prototxt, prototxt, ArgInfo("prototxt", 0)) &&
        jsopencv_to_safe(jsobj_caffeModel, caffeModel, ArgInfo("caffeModel", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::dnn::readNetFromCaffe(prototxt, caffeModel));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_bufferProto = NULL;
    vector_uchar bufferProto;
    Napi::Value* jsobj_bufferModel = NULL;
    vector_uchar bufferModel=std::vector<uchar>();
    Net retval;

    const char* keywords[] = { "bufferProto", "bufferModel", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:readNetFromCaffe", (char**)keywords, &jsobj_bufferProto, &jsobj_bufferModel) &&
        jsopencv_to_safe(jsobj_bufferProto, bufferProto, ArgInfo("bufferProto", 0)) &&
        jsopencv_to_safe(jsobj_bufferModel, bufferModel, ArgInfo("bufferModel", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::dnn::readNetFromCaffe(bufferProto, bufferModel));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "readNetFromCaffe");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_dnn_readNetFromDarknet(const Napi::CallbackInfo &info)
{
    using namespace cv::dnn;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_cfgFile = NULL;
    String cfgFile;
    Napi::Value* jsobj_darknetModel = NULL;
    String darknetModel;
    Net retval;

    const char* keywords[] = { "cfgFile", "darknetModel", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:readNetFromDarknet", (char**)keywords, &jsobj_cfgFile, &jsobj_darknetModel) &&
        jsopencv_to_safe(jsobj_cfgFile, cfgFile, ArgInfo("cfgFile", 0)) &&
        jsopencv_to_safe(jsobj_darknetModel, darknetModel, ArgInfo("darknetModel", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::dnn::readNetFromDarknet(cfgFile, darknetModel));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_bufferCfg = NULL;
    vector_uchar bufferCfg;
    Napi::Value* jsobj_bufferModel = NULL;
    vector_uchar bufferModel=std::vector<uchar>();
    Net retval;

    const char* keywords[] = { "bufferCfg", "bufferModel", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:readNetFromDarknet", (char**)keywords, &jsobj_bufferCfg, &jsobj_bufferModel) &&
        jsopencv_to_safe(jsobj_bufferCfg, bufferCfg, ArgInfo("bufferCfg", 0)) &&
        jsopencv_to_safe(jsobj_bufferModel, bufferModel, ArgInfo("bufferModel", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::dnn::readNetFromDarknet(bufferCfg, bufferModel));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "readNetFromDarknet");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_dnn_readNetFromModelOptimizer(const Napi::CallbackInfo &info)
{
    using namespace cv::dnn;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_xml = NULL;
    String xml;
    Napi::Value* jsobj_bin = NULL;
    String bin;
    Net retval;

    const char* keywords[] = { "xml", "bin", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:readNetFromModelOptimizer", (char**)keywords, &jsobj_xml, &jsobj_bin) &&
        jsopencv_to_safe(jsobj_xml, xml, ArgInfo("xml", 0)) &&
        jsopencv_to_safe(jsobj_bin, bin, ArgInfo("bin", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::dnn::readNetFromModelOptimizer(xml, bin));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_bufferModelConfig = NULL;
    vector_uchar bufferModelConfig;
    Napi::Value* jsobj_bufferWeights = NULL;
    vector_uchar bufferWeights;
    Net retval;

    const char* keywords[] = { "bufferModelConfig", "bufferWeights", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:readNetFromModelOptimizer", (char**)keywords, &jsobj_bufferModelConfig, &jsobj_bufferWeights) &&
        jsopencv_to_safe(jsobj_bufferModelConfig, bufferModelConfig, ArgInfo("bufferModelConfig", 0)) &&
        jsopencv_to_safe(jsobj_bufferWeights, bufferWeights, ArgInfo("bufferWeights", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::dnn::readNetFromModelOptimizer(bufferModelConfig, bufferWeights));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "readNetFromModelOptimizer");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_dnn_readNetFromONNX(const Napi::CallbackInfo &info)
{
    using namespace cv::dnn;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_onnxFile = NULL;
    String onnxFile;
    Net retval;

    const char* keywords[] = { "onnxFile", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:readNetFromONNX", (char**)keywords, &jsobj_onnxFile) &&
        jsopencv_to_safe(jsobj_onnxFile, onnxFile, ArgInfo("onnxFile", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::dnn::readNetFromONNX(onnxFile));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_buffer = NULL;
    vector_uchar buffer;
    Net retval;

    const char* keywords[] = { "buffer", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:readNetFromONNX", (char**)keywords, &jsobj_buffer) &&
        jsopencv_to_safe(jsobj_buffer, buffer, ArgInfo("buffer", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::dnn::readNetFromONNX(buffer));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "readNetFromONNX");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_dnn_readNetFromTensorflow(const Napi::CallbackInfo &info)
{
    using namespace cv::dnn;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_model = NULL;
    String model;
    Napi::Value* jsobj_config = NULL;
    String config;
    Net retval;

    const char* keywords[] = { "model", "config", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:readNetFromTensorflow", (char**)keywords, &jsobj_model, &jsobj_config) &&
        jsopencv_to_safe(jsobj_model, model, ArgInfo("model", 0)) &&
        jsopencv_to_safe(jsobj_config, config, ArgInfo("config", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::dnn::readNetFromTensorflow(model, config));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_bufferModel = NULL;
    vector_uchar bufferModel;
    Napi::Value* jsobj_bufferConfig = NULL;
    vector_uchar bufferConfig=std::vector<uchar>();
    Net retval;

    const char* keywords[] = { "bufferModel", "bufferConfig", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:readNetFromTensorflow", (char**)keywords, &jsobj_bufferModel, &jsobj_bufferConfig) &&
        jsopencv_to_safe(jsobj_bufferModel, bufferModel, ArgInfo("bufferModel", 0)) &&
        jsopencv_to_safe(jsobj_bufferConfig, bufferConfig, ArgInfo("bufferConfig", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::dnn::readNetFromTensorflow(bufferModel, bufferConfig));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "readNetFromTensorflow");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_dnn_readNetFromTorch(const Napi::CallbackInfo &info)
{
    using namespace cv::dnn;

    Napi::Value* jsobj_model = NULL;
    String model;
    Napi::Value* jsobj_isBinary = NULL;
    bool isBinary=true;
    Napi::Value* jsobj_evaluate = NULL;
    bool evaluate=true;
    Net retval;

    const char* keywords[] = { "model", "isBinary", "evaluate", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OO:readNetFromTorch", (char**)keywords, &jsobj_model, &jsobj_isBinary, &jsobj_evaluate) &&
        jsopencv_to_safe(jsobj_model, model, ArgInfo("model", 0)) &&
        jsopencv_to_safe(jsobj_isBinary, isBinary, ArgInfo("isBinary", 0)) &&
        jsopencv_to_safe(jsobj_evaluate, evaluate, ArgInfo("evaluate", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::dnn::readNetFromTorch(model, isBinary, evaluate));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_dnn_readTensorFromONNX(const Napi::CallbackInfo &info)
{
    using namespace cv::dnn;

    Napi::Value* jsobj_path = NULL;
    String path;
    Mat retval;

    const char* keywords[] = { "path", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:readTensorFromONNX", (char**)keywords, &jsobj_path) &&
        jsopencv_to_safe(jsobj_path, path, ArgInfo("path", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::dnn::readTensorFromONNX(path));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_dnn_readTorchBlob(const Napi::CallbackInfo &info)
{
    using namespace cv::dnn;

    Napi::Value* jsobj_filename = NULL;
    String filename;
    Napi::Value* jsobj_isBinary = NULL;
    bool isBinary=true;
    Mat retval;

    const char* keywords[] = { "filename", "isBinary", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:readTorchBlob", (char**)keywords, &jsobj_filename, &jsobj_isBinary) &&
        jsopencv_to_safe(jsobj_filename, filename, ArgInfo("filename", 0)) &&
        jsopencv_to_safe(jsobj_isBinary, isBinary, ArgInfo("isBinary", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::dnn::readTorchBlob(filename, isBinary));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_dnn_shrinkCaffeModel(const Napi::CallbackInfo &info)
{
    using namespace cv::dnn;

    Napi::Value* jsobj_src = NULL;
    String src;
    Napi::Value* jsobj_dst = NULL;
    String dst;
    Napi::Value* jsobj_layersTypes = NULL;
    vector_String layersTypes=std::vector<String>();

    const char* keywords[] = { "src", "dst", "layersTypes", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:shrinkCaffeModel", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_layersTypes) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 0)) &&
        jsopencv_to_safe(jsobj_layersTypes, layersTypes, ArgInfo("layersTypes", 0)))
    {
        ERRWRAP2_NAPI(info, cv::dnn::shrinkCaffeModel(src, dst, layersTypes));
        return info.Env().Null();;
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_dnn_softNMSBoxes(const Napi::CallbackInfo &info)
{
    using namespace cv::dnn;

    Napi::Value* jsobj_bboxes = NULL;
    vector_Rect bboxes;
    Napi::Value* jsobj_scores = NULL;
    vector_float scores;
    vector_float updated_scores;
    Napi::Value* jsobj_score_threshold = NULL;
    float score_threshold=0.f;
    Napi::Value* jsobj_nms_threshold = NULL;
    float nms_threshold=0.f;
    vector_int indices;
    Napi::Value* jsobj_top_k = NULL;
    size_t top_k=0;
    Napi::Value* jsobj_sigma = NULL;
    float sigma=0.5;
    Napi::Value* jsobj_method = NULL;
    SoftNMSMethod method=SoftNMSMethod::SOFTNMS_GAUSSIAN;

    const char* keywords[] = { "bboxes", "scores", "score_threshold", "nms_threshold", "top_k", "sigma", "method", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOO:softNMSBoxes", (char**)keywords, &jsobj_bboxes, &jsobj_scores, &jsobj_score_threshold, &jsobj_nms_threshold, &jsobj_top_k, &jsobj_sigma, &jsobj_method) &&
        jsopencv_to_safe(jsobj_bboxes, bboxes, ArgInfo("bboxes", 0)) &&
        jsopencv_to_safe(jsobj_scores, scores, ArgInfo("scores", 0)) &&
        jsopencv_to_safe(jsobj_score_threshold, score_threshold, ArgInfo("score_threshold", 0)) &&
        jsopencv_to_safe(jsobj_nms_threshold, nms_threshold, ArgInfo("nms_threshold", 0)) &&
        jsopencv_to_safe(jsobj_top_k, top_k, ArgInfo("top_k", 0)) &&
        jsopencv_to_safe(jsobj_sigma, sigma, ArgInfo("sigma", 0)) &&
        jsopencv_to_safe(jsobj_method, method, ArgInfo("method", 0)))
    {
        ERRWRAP2_NAPI(info, cv::dnn::softNMSBoxes(bboxes, scores, updated_scores, score_threshold, nms_threshold, indices, top_k, sigma, method));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, updated_scores), jsopencv_from(info, indices));
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_dnn_writeTextGraph(const Napi::CallbackInfo &info)
{
    using namespace cv::dnn;

    Napi::Value* jsobj_model = NULL;
    String model;
    Napi::Value* jsobj_output = NULL;
    String output;

    const char* keywords[] = { "model", "output", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:writeTextGraph", (char**)keywords, &jsobj_model, &jsobj_output) &&
        jsopencv_to_safe(jsobj_model, model, ArgInfo("model", 0)) &&
        jsopencv_to_safe(jsobj_output, output, ArgInfo("output", 0)))
    {
        ERRWRAP2_NAPI(info, cv::dnn::writeTextGraph(model, output));
        return info.Env().Null();;
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_dnn_superres_DnnSuperResImpl_create(const Napi::CallbackInfo &info)
{
    using namespace cv::dnn_superres;

    Ptr<DnnSuperResImpl> retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::dnn_superres::DnnSuperResImpl::create());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_face_BIF_create(const Napi::CallbackInfo &info)
{
    using namespace cv::face;

    Napi::Value* jsobj_num_bands = NULL;
    int num_bands=8;
    Napi::Value* jsobj_num_rotations = NULL;
    int num_rotations=12;
    Ptr<BIF> retval;

    const char* keywords[] = { "num_bands", "num_rotations", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OO:BIF_create", (char**)keywords, &jsobj_num_bands, &jsobj_num_rotations) &&
        jsopencv_to_safe(jsobj_num_bands, num_bands, ArgInfo("num_bands", 0)) &&
        jsopencv_to_safe(jsobj_num_rotations, num_rotations, ArgInfo("num_rotations", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::face::BIF::create(num_bands, num_rotations));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_face_EigenFaceRecognizer_create(const Napi::CallbackInfo &info)
{
    using namespace cv::face;

    Napi::Value* jsobj_num_components = NULL;
    int num_components=0;
    Napi::Value* jsobj_threshold = NULL;
    double threshold=DBL_MAX;
    Ptr<EigenFaceRecognizer> retval;

    const char* keywords[] = { "num_components", "threshold", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OO:EigenFaceRecognizer_create", (char**)keywords, &jsobj_num_components, &jsobj_threshold) &&
        jsopencv_to_safe(jsobj_num_components, num_components, ArgInfo("num_components", 0)) &&
        jsopencv_to_safe(jsobj_threshold, threshold, ArgInfo("threshold", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::face::EigenFaceRecognizer::create(num_components, threshold));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_face_FisherFaceRecognizer_create(const Napi::CallbackInfo &info)
{
    using namespace cv::face;

    Napi::Value* jsobj_num_components = NULL;
    int num_components=0;
    Napi::Value* jsobj_threshold = NULL;
    double threshold=DBL_MAX;
    Ptr<FisherFaceRecognizer> retval;

    const char* keywords[] = { "num_components", "threshold", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OO:FisherFaceRecognizer_create", (char**)keywords, &jsobj_num_components, &jsobj_threshold) &&
        jsopencv_to_safe(jsobj_num_components, num_components, ArgInfo("num_components", 0)) &&
        jsopencv_to_safe(jsobj_threshold, threshold, ArgInfo("threshold", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::face::FisherFaceRecognizer::create(num_components, threshold));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_face_LBPHFaceRecognizer_create(const Napi::CallbackInfo &info)
{
    using namespace cv::face;

    Napi::Value* jsobj_radius = NULL;
    int radius=1;
    Napi::Value* jsobj_neighbors = NULL;
    int neighbors=8;
    Napi::Value* jsobj_grid_x = NULL;
    int grid_x=8;
    Napi::Value* jsobj_grid_y = NULL;
    int grid_y=8;
    Napi::Value* jsobj_threshold = NULL;
    double threshold=DBL_MAX;
    Ptr<LBPHFaceRecognizer> retval;

    const char* keywords[] = { "radius", "neighbors", "grid_x", "grid_y", "threshold", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OOOOO:LBPHFaceRecognizer_create", (char**)keywords, &jsobj_radius, &jsobj_neighbors, &jsobj_grid_x, &jsobj_grid_y, &jsobj_threshold) &&
        jsopencv_to_safe(jsobj_radius, radius, ArgInfo("radius", 0)) &&
        jsopencv_to_safe(jsobj_neighbors, neighbors, ArgInfo("neighbors", 0)) &&
        jsopencv_to_safe(jsobj_grid_x, grid_x, ArgInfo("grid_x", 0)) &&
        jsopencv_to_safe(jsobj_grid_y, grid_y, ArgInfo("grid_y", 0)) &&
        jsopencv_to_safe(jsobj_threshold, threshold, ArgInfo("threshold", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::face::LBPHFaceRecognizer::create(radius, neighbors, grid_x, grid_y, threshold));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_face_MACE_create(const Napi::CallbackInfo &info)
{
    using namespace cv::face;

    Napi::Value* jsobj_IMGSIZE = NULL;
    int IMGSIZE=64;
    cv::Ptr<MACE> retval;

    const char* keywords[] = { "IMGSIZE", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|O:MACE_create", (char**)keywords, &jsobj_IMGSIZE) &&
        jsopencv_to_safe(jsobj_IMGSIZE, IMGSIZE, ArgInfo("IMGSIZE", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::face::MACE::create(IMGSIZE));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_face_MACE_load(const Napi::CallbackInfo &info)
{
    using namespace cv::face;

    Napi::Value* jsobj_filename = NULL;
    String filename;
    Napi::Value* jsobj_objname = NULL;
    String objname;
    cv::Ptr<MACE> retval;

    const char* keywords[] = { "filename", "objname", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:MACE_load", (char**)keywords, &jsobj_filename, &jsobj_objname) &&
        jsopencv_to_safe(jsobj_filename, filename, ArgInfo("filename", 0)) &&
        jsopencv_to_safe(jsobj_objname, objname, ArgInfo("objname", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::face::MACE::load(filename, objname));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_face_StandardCollector_create(const Napi::CallbackInfo &info)
{
    using namespace cv::face;

    Napi::Value* jsobj_threshold = NULL;
    double threshold=DBL_MAX;
    Ptr<StandardCollector> retval;

    const char* keywords[] = { "threshold", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|O:StandardCollector_create", (char**)keywords, &jsobj_threshold) &&
        jsopencv_to_safe(jsobj_threshold, threshold, ArgInfo("threshold", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::face::StandardCollector::create(threshold));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_face_createFacemarkAAM(const Napi::CallbackInfo &info)
{
    using namespace cv::face;

    Ptr<Facemark> retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::face::createFacemarkAAM());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_face_createFacemarkKazemi(const Napi::CallbackInfo &info)
{
    using namespace cv::face;

    Ptr<Facemark> retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::face::createFacemarkKazemi());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_face_createFacemarkLBF(const Napi::CallbackInfo &info)
{
    using namespace cv::face;

    Ptr<Facemark> retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::face::createFacemarkLBF());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_face_drawFacemarks(const Napi::CallbackInfo &info)
{
    using namespace cv::face;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_image = NULL;
    Mat image;
    Napi::Value* jsobj_points = NULL;
    Mat points;
    Napi::Value* jsobj_color = NULL;
    Scalar color=Scalar(255,0,0);

    const char* keywords[] = { "image", "points", "color", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:drawFacemarks", (char**)keywords, &jsobj_image, &jsobj_points, &jsobj_color) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 1)) &&
        jsopencv_to_safe(jsobj_points, points, ArgInfo("points", 0)) &&
        jsopencv_to_safe(jsobj_color, color, ArgInfo("color", 0)))
    {
        ERRWRAP2_NAPI(info, cv::face::drawFacemarks(image, points, color));
        return jsopencv_from(info, image);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_image = NULL;
    UMat image;
    Napi::Value* jsobj_points = NULL;
    UMat points;
    Napi::Value* jsobj_color = NULL;
    Scalar color=Scalar(255,0,0);

    const char* keywords[] = { "image", "points", "color", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:drawFacemarks", (char**)keywords, &jsobj_image, &jsobj_points, &jsobj_color) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 1)) &&
        jsopencv_to_safe(jsobj_points, points, ArgInfo("points", 0)) &&
        jsopencv_to_safe(jsobj_color, color, ArgInfo("color", 0)))
    {
        ERRWRAP2_NAPI(info, cv::face::drawFacemarks(image, points, color));
        return jsopencv_from(info, image);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "drawFacemarks");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_face_getFacesHAAR(const Napi::CallbackInfo &info)
{
    using namespace cv::face;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_image = NULL;
    Mat image;
    Napi::Value* jsobj_faces = NULL;
    Mat faces;
    Napi::Value* jsobj_face_cascade_name = NULL;
    String face_cascade_name;
    bool retval;

    const char* keywords[] = { "image", "face_cascade_name", "faces", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:getFacesHAAR", (char**)keywords, &jsobj_image, &jsobj_face_cascade_name, &jsobj_faces) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_faces, faces, ArgInfo("faces", 1)) &&
        jsopencv_to_safe(jsobj_face_cascade_name, face_cascade_name, ArgInfo("face_cascade_name", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::face::getFacesHAAR(image, faces, face_cascade_name));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, faces));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_image = NULL;
    UMat image;
    Napi::Value* jsobj_faces = NULL;
    UMat faces;
    Napi::Value* jsobj_face_cascade_name = NULL;
    String face_cascade_name;
    bool retval;

    const char* keywords[] = { "image", "face_cascade_name", "faces", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:getFacesHAAR", (char**)keywords, &jsobj_image, &jsobj_face_cascade_name, &jsobj_faces) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_faces, faces, ArgInfo("faces", 1)) &&
        jsopencv_to_safe(jsobj_face_cascade_name, face_cascade_name, ArgInfo("face_cascade_name", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::face::getFacesHAAR(image, faces, face_cascade_name));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, faces));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "getFacesHAAR");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_face_loadDatasetList(const Napi::CallbackInfo &info)
{
    using namespace cv::face;

    Napi::Value* jsobj_imageList = NULL;
    String imageList;
    Napi::Value* jsobj_annotationList = NULL;
    String annotationList;
    Napi::Value* jsobj_images = NULL;
    vector_String images;
    Napi::Value* jsobj_annotations = NULL;
    vector_String annotations;
    bool retval;

    const char* keywords[] = { "imageList", "annotationList", "images", "annotations", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO:loadDatasetList", (char**)keywords, &jsobj_imageList, &jsobj_annotationList, &jsobj_images, &jsobj_annotations) &&
        jsopencv_to_safe(jsobj_imageList, imageList, ArgInfo("imageList", 0)) &&
        jsopencv_to_safe(jsobj_annotationList, annotationList, ArgInfo("annotationList", 0)) &&
        jsopencv_to_safe(jsobj_images, images, ArgInfo("images", 0)) &&
        jsopencv_to_safe(jsobj_annotations, annotations, ArgInfo("annotations", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::face::loadDatasetList(imageList, annotationList, images, annotations));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_face_loadFacePoints(const Napi::CallbackInfo &info)
{
    using namespace cv::face;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_filename = NULL;
    String filename;
    Napi::Value* jsobj_points = NULL;
    Mat points;
    Napi::Value* jsobj_offset = NULL;
    float offset=0.0f;
    bool retval;

    const char* keywords[] = { "filename", "points", "offset", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OO:loadFacePoints", (char**)keywords, &jsobj_filename, &jsobj_points, &jsobj_offset) &&
        jsopencv_to_safe(jsobj_filename, filename, ArgInfo("filename", 0)) &&
        jsopencv_to_safe(jsobj_points, points, ArgInfo("points", 1)) &&
        jsopencv_to_safe(jsobj_offset, offset, ArgInfo("offset", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::face::loadFacePoints(filename, points, offset));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, points));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_filename = NULL;
    String filename;
    Napi::Value* jsobj_points = NULL;
    UMat points;
    Napi::Value* jsobj_offset = NULL;
    float offset=0.0f;
    bool retval;

    const char* keywords[] = { "filename", "points", "offset", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OO:loadFacePoints", (char**)keywords, &jsobj_filename, &jsobj_points, &jsobj_offset) &&
        jsopencv_to_safe(jsobj_filename, filename, ArgInfo("filename", 0)) &&
        jsopencv_to_safe(jsobj_points, points, ArgInfo("points", 1)) &&
        jsopencv_to_safe(jsobj_offset, offset, ArgInfo("offset", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::face::loadFacePoints(filename, points, offset));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, points));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "loadFacePoints");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_face_loadTrainingData(const Napi::CallbackInfo &info)
{
    using namespace cv::face;

    jsPrepareArgumentConversionErrorsStorage(5);

    {
    Napi::Value* jsobj_filename = NULL;
    String filename;
    Napi::Value* jsobj_images = NULL;
    vector_String images;
    Napi::Value* jsobj_facePoints = NULL;
    Mat facePoints;
    Napi::Value* jsobj_delim = NULL;
    char delim=' ';
    Napi::Value* jsobj_offset = NULL;
    float offset=0.0f;
    bool retval;

    const char* keywords[] = { "filename", "images", "facePoints", "delim", "offset", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOO:loadTrainingData", (char**)keywords, &jsobj_filename, &jsobj_images, &jsobj_facePoints, &jsobj_delim, &jsobj_offset) &&
        jsopencv_to_safe(jsobj_filename, filename, ArgInfo("filename", 0)) &&
        jsopencv_to_safe(jsobj_images, images, ArgInfo("images", 0)) &&
        jsopencv_to_safe(jsobj_facePoints, facePoints, ArgInfo("facePoints", 1)) &&
        jsconvert_to_char(jsobj_delim, &delim, ArgInfo("delim", 0)) &&
        jsopencv_to_safe(jsobj_offset, offset, ArgInfo("offset", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::face::loadTrainingData(filename, images, facePoints, delim, offset));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, facePoints));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_filename = NULL;
    String filename;
    Napi::Value* jsobj_images = NULL;
    vector_String images;
    Napi::Value* jsobj_facePoints = NULL;
    UMat facePoints;
    Napi::Value* jsobj_delim = NULL;
    char delim=' ';
    Napi::Value* jsobj_offset = NULL;
    float offset=0.0f;
    bool retval;

    const char* keywords[] = { "filename", "images", "facePoints", "delim", "offset", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOO:loadTrainingData", (char**)keywords, &jsobj_filename, &jsobj_images, &jsobj_facePoints, &jsobj_delim, &jsobj_offset) &&
        jsopencv_to_safe(jsobj_filename, filename, ArgInfo("filename", 0)) &&
        jsopencv_to_safe(jsobj_images, images, ArgInfo("images", 0)) &&
        jsopencv_to_safe(jsobj_facePoints, facePoints, ArgInfo("facePoints", 1)) &&
        jsconvert_to_char(jsobj_delim, &delim, ArgInfo("delim", 0)) &&
        jsopencv_to_safe(jsobj_offset, offset, ArgInfo("offset", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::face::loadTrainingData(filename, images, facePoints, delim, offset));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, facePoints));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_imageList = NULL;
    String imageList;
    Napi::Value* jsobj_groundTruth = NULL;
    String groundTruth;
    Napi::Value* jsobj_images = NULL;
    vector_String images;
    Napi::Value* jsobj_facePoints = NULL;
    Mat facePoints;
    Napi::Value* jsobj_offset = NULL;
    float offset=0.0f;
    bool retval;

    const char* keywords[] = { "imageList", "groundTruth", "images", "facePoints", "offset", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OO:loadTrainingData", (char**)keywords, &jsobj_imageList, &jsobj_groundTruth, &jsobj_images, &jsobj_facePoints, &jsobj_offset) &&
        jsopencv_to_safe(jsobj_imageList, imageList, ArgInfo("imageList", 0)) &&
        jsopencv_to_safe(jsobj_groundTruth, groundTruth, ArgInfo("groundTruth", 0)) &&
        jsopencv_to_safe(jsobj_images, images, ArgInfo("images", 0)) &&
        jsopencv_to_safe(jsobj_facePoints, facePoints, ArgInfo("facePoints", 1)) &&
        jsopencv_to_safe(jsobj_offset, offset, ArgInfo("offset", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::face::loadTrainingData(imageList, groundTruth, images, facePoints, offset));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, facePoints));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_imageList = NULL;
    String imageList;
    Napi::Value* jsobj_groundTruth = NULL;
    String groundTruth;
    Napi::Value* jsobj_images = NULL;
    vector_String images;
    Napi::Value* jsobj_facePoints = NULL;
    UMat facePoints;
    Napi::Value* jsobj_offset = NULL;
    float offset=0.0f;
    bool retval;

    const char* keywords[] = { "imageList", "groundTruth", "images", "facePoints", "offset", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OO:loadTrainingData", (char**)keywords, &jsobj_imageList, &jsobj_groundTruth, &jsobj_images, &jsobj_facePoints, &jsobj_offset) &&
        jsopencv_to_safe(jsobj_imageList, imageList, ArgInfo("imageList", 0)) &&
        jsopencv_to_safe(jsobj_groundTruth, groundTruth, ArgInfo("groundTruth", 0)) &&
        jsopencv_to_safe(jsobj_images, images, ArgInfo("images", 0)) &&
        jsopencv_to_safe(jsobj_facePoints, facePoints, ArgInfo("facePoints", 1)) &&
        jsopencv_to_safe(jsobj_offset, offset, ArgInfo("offset", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::face::loadTrainingData(imageList, groundTruth, images, facePoints, offset));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, facePoints));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_filename = NULL;
    vector_String filename;
    Napi::Value* jsobj_trainlandmarks = NULL;
    vector_vector_Point2f trainlandmarks;
    Napi::Value* jsobj_trainimages = NULL;
    vector_String trainimages;
    bool retval;

    const char* keywords[] = { "filename", "trainlandmarks", "trainimages", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:loadTrainingData", (char**)keywords, &jsobj_filename, &jsobj_trainlandmarks, &jsobj_trainimages) &&
        jsopencv_to_safe(jsobj_filename, filename, ArgInfo("filename", 0)) &&
        jsopencv_to_safe(jsobj_trainlandmarks, trainlandmarks, ArgInfo("trainlandmarks", 0)) &&
        jsopencv_to_safe(jsobj_trainimages, trainimages, ArgInfo("trainimages", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::face::loadTrainingData(filename, trainlandmarks, trainimages));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "loadTrainingData");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_fisheye_calibrate(const Napi::CallbackInfo &info)
{
    using namespace cv::fisheye;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_objectPoints = NULL;
    vector_Mat objectPoints;
    Napi::Value* jsobj_imagePoints = NULL;
    vector_Mat imagePoints;
    Napi::Value* jsobj_image_size = NULL;
    Size image_size;
    Napi::Value* jsobj_K = NULL;
    Mat K;
    Napi::Value* jsobj_D = NULL;
    Mat D;
    Napi::Value* jsobj_rvecs = NULL;
    vector_Mat rvecs;
    Napi::Value* jsobj_tvecs = NULL;
    vector_Mat tvecs;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;
    Napi::Value* jsobj_criteria = NULL;
    TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, DBL_EPSILON);
    double retval;

    const char* keywords[] = { "objectPoints", "imagePoints", "image_size", "K", "D", "rvecs", "tvecs", "flags", "criteria", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOO|OOOO:calibrate", (char**)keywords, &jsobj_objectPoints, &jsobj_imagePoints, &jsobj_image_size, &jsobj_K, &jsobj_D, &jsobj_rvecs, &jsobj_tvecs, &jsobj_flags, &jsobj_criteria) &&
        jsopencv_to_safe(jsobj_objectPoints, objectPoints, ArgInfo("objectPoints", 0)) &&
        jsopencv_to_safe(jsobj_imagePoints, imagePoints, ArgInfo("imagePoints", 0)) &&
        jsopencv_to_safe(jsobj_image_size, image_size, ArgInfo("image_size", 0)) &&
        jsopencv_to_safe(jsobj_K, K, ArgInfo("K", 1)) &&
        jsopencv_to_safe(jsobj_D, D, ArgInfo("D", 1)) &&
        jsopencv_to_safe(jsobj_rvecs, rvecs, ArgInfo("rvecs", 1)) &&
        jsopencv_to_safe(jsobj_tvecs, tvecs, ArgInfo("tvecs", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_criteria, criteria, ArgInfo("criteria", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::fisheye::calibrate(objectPoints, imagePoints, image_size, K, D, rvecs, tvecs, flags, criteria));
        return Js_BuildValue(info, "(NNNNN)", jsopencv_from(info, retval), jsopencv_from(info, K), jsopencv_from(info, D), jsopencv_from(info, rvecs), jsopencv_from(info, tvecs));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_objectPoints = NULL;
    vector_UMat objectPoints;
    Napi::Value* jsobj_imagePoints = NULL;
    vector_UMat imagePoints;
    Napi::Value* jsobj_image_size = NULL;
    Size image_size;
    Napi::Value* jsobj_K = NULL;
    UMat K;
    Napi::Value* jsobj_D = NULL;
    UMat D;
    Napi::Value* jsobj_rvecs = NULL;
    vector_UMat rvecs;
    Napi::Value* jsobj_tvecs = NULL;
    vector_UMat tvecs;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;
    Napi::Value* jsobj_criteria = NULL;
    TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, DBL_EPSILON);
    double retval;

    const char* keywords[] = { "objectPoints", "imagePoints", "image_size", "K", "D", "rvecs", "tvecs", "flags", "criteria", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOO|OOOO:calibrate", (char**)keywords, &jsobj_objectPoints, &jsobj_imagePoints, &jsobj_image_size, &jsobj_K, &jsobj_D, &jsobj_rvecs, &jsobj_tvecs, &jsobj_flags, &jsobj_criteria) &&
        jsopencv_to_safe(jsobj_objectPoints, objectPoints, ArgInfo("objectPoints", 0)) &&
        jsopencv_to_safe(jsobj_imagePoints, imagePoints, ArgInfo("imagePoints", 0)) &&
        jsopencv_to_safe(jsobj_image_size, image_size, ArgInfo("image_size", 0)) &&
        jsopencv_to_safe(jsobj_K, K, ArgInfo("K", 1)) &&
        jsopencv_to_safe(jsobj_D, D, ArgInfo("D", 1)) &&
        jsopencv_to_safe(jsobj_rvecs, rvecs, ArgInfo("rvecs", 1)) &&
        jsopencv_to_safe(jsobj_tvecs, tvecs, ArgInfo("tvecs", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_criteria, criteria, ArgInfo("criteria", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::fisheye::calibrate(objectPoints, imagePoints, image_size, K, D, rvecs, tvecs, flags, criteria));
        return Js_BuildValue(info, "(NNNNN)", jsopencv_from(info, retval), jsopencv_from(info, K), jsopencv_from(info, D), jsopencv_from(info, rvecs), jsopencv_from(info, tvecs));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "calibrate");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_fisheye_distortPoints(const Napi::CallbackInfo &info)
{
    using namespace cv::fisheye;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_undistorted = NULL;
    Mat undistorted;
    Napi::Value* jsobj_distorted = NULL;
    Mat distorted;
    Napi::Value* jsobj_K = NULL;
    Mat K;
    Napi::Value* jsobj_D = NULL;
    Mat D;
    Napi::Value* jsobj_alpha = NULL;
    double alpha=0;

    const char* keywords[] = { "undistorted", "K", "D", "distorted", "alpha", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OO:distortPoints", (char**)keywords, &jsobj_undistorted, &jsobj_K, &jsobj_D, &jsobj_distorted, &jsobj_alpha) &&
        jsopencv_to_safe(jsobj_undistorted, undistorted, ArgInfo("undistorted", 0)) &&
        jsopencv_to_safe(jsobj_distorted, distorted, ArgInfo("distorted", 1)) &&
        jsopencv_to_safe(jsobj_K, K, ArgInfo("K", 0)) &&
        jsopencv_to_safe(jsobj_D, D, ArgInfo("D", 0)) &&
        jsopencv_to_safe(jsobj_alpha, alpha, ArgInfo("alpha", 0)))
    {
        ERRWRAP2_NAPI(info, cv::fisheye::distortPoints(undistorted, distorted, K, D, alpha));
        return jsopencv_from(info, distorted);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_undistorted = NULL;
    UMat undistorted;
    Napi::Value* jsobj_distorted = NULL;
    UMat distorted;
    Napi::Value* jsobj_K = NULL;
    UMat K;
    Napi::Value* jsobj_D = NULL;
    UMat D;
    Napi::Value* jsobj_alpha = NULL;
    double alpha=0;

    const char* keywords[] = { "undistorted", "K", "D", "distorted", "alpha", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OO:distortPoints", (char**)keywords, &jsobj_undistorted, &jsobj_K, &jsobj_D, &jsobj_distorted, &jsobj_alpha) &&
        jsopencv_to_safe(jsobj_undistorted, undistorted, ArgInfo("undistorted", 0)) &&
        jsopencv_to_safe(jsobj_distorted, distorted, ArgInfo("distorted", 1)) &&
        jsopencv_to_safe(jsobj_K, K, ArgInfo("K", 0)) &&
        jsopencv_to_safe(jsobj_D, D, ArgInfo("D", 0)) &&
        jsopencv_to_safe(jsobj_alpha, alpha, ArgInfo("alpha", 0)))
    {
        ERRWRAP2_NAPI(info, cv::fisheye::distortPoints(undistorted, distorted, K, D, alpha));
        return jsopencv_from(info, distorted);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "distortPoints");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_fisheye_estimateNewCameraMatrixForUndistortRectify(const Napi::CallbackInfo &info)
{
    using namespace cv::fisheye;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_K = NULL;
    Mat K;
    Napi::Value* jsobj_D = NULL;
    Mat D;
    Napi::Value* jsobj_image_size = NULL;
    Size image_size;
    Napi::Value* jsobj_R = NULL;
    Mat R;
    Napi::Value* jsobj_P = NULL;
    Mat P;
    Napi::Value* jsobj_balance = NULL;
    double balance=0.0;
    Napi::Value* jsobj_new_size = NULL;
    Size new_size;
    Napi::Value* jsobj_fov_scale = NULL;
    double fov_scale=1.0;

    const char* keywords[] = { "K", "D", "image_size", "R", "P", "balance", "new_size", "fov_scale", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOOO:estimateNewCameraMatrixForUndistortRectify", (char**)keywords, &jsobj_K, &jsobj_D, &jsobj_image_size, &jsobj_R, &jsobj_P, &jsobj_balance, &jsobj_new_size, &jsobj_fov_scale) &&
        jsopencv_to_safe(jsobj_K, K, ArgInfo("K", 0)) &&
        jsopencv_to_safe(jsobj_D, D, ArgInfo("D", 0)) &&
        jsopencv_to_safe(jsobj_image_size, image_size, ArgInfo("image_size", 0)) &&
        jsopencv_to_safe(jsobj_R, R, ArgInfo("R", 0)) &&
        jsopencv_to_safe(jsobj_P, P, ArgInfo("P", 1)) &&
        jsopencv_to_safe(jsobj_balance, balance, ArgInfo("balance", 0)) &&
        jsopencv_to_safe(jsobj_new_size, new_size, ArgInfo("new_size", 0)) &&
        jsopencv_to_safe(jsobj_fov_scale, fov_scale, ArgInfo("fov_scale", 0)))
    {
        ERRWRAP2_NAPI(info, cv::fisheye::estimateNewCameraMatrixForUndistortRectify(K, D, image_size, R, P, balance, new_size, fov_scale));
        return jsopencv_from(info, P);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_K = NULL;
    UMat K;
    Napi::Value* jsobj_D = NULL;
    UMat D;
    Napi::Value* jsobj_image_size = NULL;
    Size image_size;
    Napi::Value* jsobj_R = NULL;
    UMat R;
    Napi::Value* jsobj_P = NULL;
    UMat P;
    Napi::Value* jsobj_balance = NULL;
    double balance=0.0;
    Napi::Value* jsobj_new_size = NULL;
    Size new_size;
    Napi::Value* jsobj_fov_scale = NULL;
    double fov_scale=1.0;

    const char* keywords[] = { "K", "D", "image_size", "R", "P", "balance", "new_size", "fov_scale", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOOO:estimateNewCameraMatrixForUndistortRectify", (char**)keywords, &jsobj_K, &jsobj_D, &jsobj_image_size, &jsobj_R, &jsobj_P, &jsobj_balance, &jsobj_new_size, &jsobj_fov_scale) &&
        jsopencv_to_safe(jsobj_K, K, ArgInfo("K", 0)) &&
        jsopencv_to_safe(jsobj_D, D, ArgInfo("D", 0)) &&
        jsopencv_to_safe(jsobj_image_size, image_size, ArgInfo("image_size", 0)) &&
        jsopencv_to_safe(jsobj_R, R, ArgInfo("R", 0)) &&
        jsopencv_to_safe(jsobj_P, P, ArgInfo("P", 1)) &&
        jsopencv_to_safe(jsobj_balance, balance, ArgInfo("balance", 0)) &&
        jsopencv_to_safe(jsobj_new_size, new_size, ArgInfo("new_size", 0)) &&
        jsopencv_to_safe(jsobj_fov_scale, fov_scale, ArgInfo("fov_scale", 0)))
    {
        ERRWRAP2_NAPI(info, cv::fisheye::estimateNewCameraMatrixForUndistortRectify(K, D, image_size, R, P, balance, new_size, fov_scale));
        return jsopencv_from(info, P);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "estimateNewCameraMatrixForUndistortRectify");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_fisheye_initUndistortRectifyMap(const Napi::CallbackInfo &info)
{
    using namespace cv::fisheye;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_K = NULL;
    Mat K;
    Napi::Value* jsobj_D = NULL;
    Mat D;
    Napi::Value* jsobj_R = NULL;
    Mat R;
    Napi::Value* jsobj_P = NULL;
    Mat P;
    Napi::Value* jsobj_size = NULL;
    Size size;
    Napi::Value* jsobj_m1type = NULL;
    int m1type=0;
    Napi::Value* jsobj_map1 = NULL;
    Mat map1;
    Napi::Value* jsobj_map2 = NULL;
    Mat map2;

    const char* keywords[] = { "K", "D", "R", "P", "size", "m1type", "map1", "map2", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOO|OO:initUndistortRectifyMap", (char**)keywords, &jsobj_K, &jsobj_D, &jsobj_R, &jsobj_P, &jsobj_size, &jsobj_m1type, &jsobj_map1, &jsobj_map2) &&
        jsopencv_to_safe(jsobj_K, K, ArgInfo("K", 0)) &&
        jsopencv_to_safe(jsobj_D, D, ArgInfo("D", 0)) &&
        jsopencv_to_safe(jsobj_R, R, ArgInfo("R", 0)) &&
        jsopencv_to_safe(jsobj_P, P, ArgInfo("P", 0)) &&
        jsopencv_to_safe(jsobj_size, size, ArgInfo("size", 0)) &&
        jsopencv_to_safe(jsobj_m1type, m1type, ArgInfo("m1type", 0)) &&
        jsopencv_to_safe(jsobj_map1, map1, ArgInfo("map1", 1)) &&
        jsopencv_to_safe(jsobj_map2, map2, ArgInfo("map2", 1)))
    {
        ERRWRAP2_NAPI(info, cv::fisheye::initUndistortRectifyMap(K, D, R, P, size, m1type, map1, map2));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, map1), jsopencv_from(info, map2));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_K = NULL;
    UMat K;
    Napi::Value* jsobj_D = NULL;
    UMat D;
    Napi::Value* jsobj_R = NULL;
    UMat R;
    Napi::Value* jsobj_P = NULL;
    UMat P;
    Napi::Value* jsobj_size = NULL;
    Size size;
    Napi::Value* jsobj_m1type = NULL;
    int m1type=0;
    Napi::Value* jsobj_map1 = NULL;
    UMat map1;
    Napi::Value* jsobj_map2 = NULL;
    UMat map2;

    const char* keywords[] = { "K", "D", "R", "P", "size", "m1type", "map1", "map2", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOO|OO:initUndistortRectifyMap", (char**)keywords, &jsobj_K, &jsobj_D, &jsobj_R, &jsobj_P, &jsobj_size, &jsobj_m1type, &jsobj_map1, &jsobj_map2) &&
        jsopencv_to_safe(jsobj_K, K, ArgInfo("K", 0)) &&
        jsopencv_to_safe(jsobj_D, D, ArgInfo("D", 0)) &&
        jsopencv_to_safe(jsobj_R, R, ArgInfo("R", 0)) &&
        jsopencv_to_safe(jsobj_P, P, ArgInfo("P", 0)) &&
        jsopencv_to_safe(jsobj_size, size, ArgInfo("size", 0)) &&
        jsopencv_to_safe(jsobj_m1type, m1type, ArgInfo("m1type", 0)) &&
        jsopencv_to_safe(jsobj_map1, map1, ArgInfo("map1", 1)) &&
        jsopencv_to_safe(jsobj_map2, map2, ArgInfo("map2", 1)))
    {
        ERRWRAP2_NAPI(info, cv::fisheye::initUndistortRectifyMap(K, D, R, P, size, m1type, map1, map2));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, map1), jsopencv_from(info, map2));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "initUndistortRectifyMap");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_fisheye_projectPoints(const Napi::CallbackInfo &info)
{
    using namespace cv::fisheye;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_objectPoints = NULL;
    Mat objectPoints;
    Napi::Value* jsobj_imagePoints = NULL;
    Mat imagePoints;
    Napi::Value* jsobj_rvec = NULL;
    Mat rvec;
    Napi::Value* jsobj_tvec = NULL;
    Mat tvec;
    Napi::Value* jsobj_K = NULL;
    Mat K;
    Napi::Value* jsobj_D = NULL;
    Mat D;
    Napi::Value* jsobj_alpha = NULL;
    double alpha=0;
    Napi::Value* jsobj_jacobian = NULL;
    Mat jacobian;

    const char* keywords[] = { "objectPoints", "rvec", "tvec", "K", "D", "imagePoints", "alpha", "jacobian", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOO|OOO:projectPoints", (char**)keywords, &jsobj_objectPoints, &jsobj_rvec, &jsobj_tvec, &jsobj_K, &jsobj_D, &jsobj_imagePoints, &jsobj_alpha, &jsobj_jacobian) &&
        jsopencv_to_safe(jsobj_objectPoints, objectPoints, ArgInfo("objectPoints", 0)) &&
        jsopencv_to_safe(jsobj_imagePoints, imagePoints, ArgInfo("imagePoints", 1)) &&
        jsopencv_to_safe(jsobj_rvec, rvec, ArgInfo("rvec", 0)) &&
        jsopencv_to_safe(jsobj_tvec, tvec, ArgInfo("tvec", 0)) &&
        jsopencv_to_safe(jsobj_K, K, ArgInfo("K", 0)) &&
        jsopencv_to_safe(jsobj_D, D, ArgInfo("D", 0)) &&
        jsopencv_to_safe(jsobj_alpha, alpha, ArgInfo("alpha", 0)) &&
        jsopencv_to_safe(jsobj_jacobian, jacobian, ArgInfo("jacobian", 1)))
    {
        ERRWRAP2_NAPI(info, cv::fisheye::projectPoints(objectPoints, imagePoints, rvec, tvec, K, D, alpha, jacobian));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, imagePoints), jsopencv_from(info, jacobian));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_objectPoints = NULL;
    UMat objectPoints;
    Napi::Value* jsobj_imagePoints = NULL;
    UMat imagePoints;
    Napi::Value* jsobj_rvec = NULL;
    UMat rvec;
    Napi::Value* jsobj_tvec = NULL;
    UMat tvec;
    Napi::Value* jsobj_K = NULL;
    UMat K;
    Napi::Value* jsobj_D = NULL;
    UMat D;
    Napi::Value* jsobj_alpha = NULL;
    double alpha=0;
    Napi::Value* jsobj_jacobian = NULL;
    UMat jacobian;

    const char* keywords[] = { "objectPoints", "rvec", "tvec", "K", "D", "imagePoints", "alpha", "jacobian", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOO|OOO:projectPoints", (char**)keywords, &jsobj_objectPoints, &jsobj_rvec, &jsobj_tvec, &jsobj_K, &jsobj_D, &jsobj_imagePoints, &jsobj_alpha, &jsobj_jacobian) &&
        jsopencv_to_safe(jsobj_objectPoints, objectPoints, ArgInfo("objectPoints", 0)) &&
        jsopencv_to_safe(jsobj_imagePoints, imagePoints, ArgInfo("imagePoints", 1)) &&
        jsopencv_to_safe(jsobj_rvec, rvec, ArgInfo("rvec", 0)) &&
        jsopencv_to_safe(jsobj_tvec, tvec, ArgInfo("tvec", 0)) &&
        jsopencv_to_safe(jsobj_K, K, ArgInfo("K", 0)) &&
        jsopencv_to_safe(jsobj_D, D, ArgInfo("D", 0)) &&
        jsopencv_to_safe(jsobj_alpha, alpha, ArgInfo("alpha", 0)) &&
        jsopencv_to_safe(jsobj_jacobian, jacobian, ArgInfo("jacobian", 1)))
    {
        ERRWRAP2_NAPI(info, cv::fisheye::projectPoints(objectPoints, imagePoints, rvec, tvec, K, D, alpha, jacobian));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, imagePoints), jsopencv_from(info, jacobian));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "projectPoints");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_fisheye_stereoCalibrate(const Napi::CallbackInfo &info)
{
    using namespace cv::fisheye;

    jsPrepareArgumentConversionErrorsStorage(4);

    {
    Napi::Value* jsobj_objectPoints = NULL;
    vector_Mat objectPoints;
    Napi::Value* jsobj_imagePoints1 = NULL;
    vector_Mat imagePoints1;
    Napi::Value* jsobj_imagePoints2 = NULL;
    vector_Mat imagePoints2;
    Napi::Value* jsobj_K1 = NULL;
    Mat K1;
    Napi::Value* jsobj_D1 = NULL;
    Mat D1;
    Napi::Value* jsobj_K2 = NULL;
    Mat K2;
    Napi::Value* jsobj_D2 = NULL;
    Mat D2;
    Napi::Value* jsobj_imageSize = NULL;
    Size imageSize;
    Napi::Value* jsobj_R = NULL;
    Mat R;
    Napi::Value* jsobj_T = NULL;
    Mat T;
    Napi::Value* jsobj_rvecs = NULL;
    vector_Mat rvecs;
    Napi::Value* jsobj_tvecs = NULL;
    vector_Mat tvecs;
    Napi::Value* jsobj_flags = NULL;
    int flags=fisheye::CALIB_FIX_INTRINSIC;
    Napi::Value* jsobj_criteria = NULL;
    TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, DBL_EPSILON);
    double retval;

    const char* keywords[] = { "objectPoints", "imagePoints1", "imagePoints2", "K1", "D1", "K2", "D2", "imageSize", "R", "T", "rvecs", "tvecs", "flags", "criteria", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOOOO|OOOOOO:stereoCalibrate", (char**)keywords, &jsobj_objectPoints, &jsobj_imagePoints1, &jsobj_imagePoints2, &jsobj_K1, &jsobj_D1, &jsobj_K2, &jsobj_D2, &jsobj_imageSize, &jsobj_R, &jsobj_T, &jsobj_rvecs, &jsobj_tvecs, &jsobj_flags, &jsobj_criteria) &&
        jsopencv_to_safe(jsobj_objectPoints, objectPoints, ArgInfo("objectPoints", 0)) &&
        jsopencv_to_safe(jsobj_imagePoints1, imagePoints1, ArgInfo("imagePoints1", 0)) &&
        jsopencv_to_safe(jsobj_imagePoints2, imagePoints2, ArgInfo("imagePoints2", 0)) &&
        jsopencv_to_safe(jsobj_K1, K1, ArgInfo("K1", 1)) &&
        jsopencv_to_safe(jsobj_D1, D1, ArgInfo("D1", 1)) &&
        jsopencv_to_safe(jsobj_K2, K2, ArgInfo("K2", 1)) &&
        jsopencv_to_safe(jsobj_D2, D2, ArgInfo("D2", 1)) &&
        jsopencv_to_safe(jsobj_imageSize, imageSize, ArgInfo("imageSize", 0)) &&
        jsopencv_to_safe(jsobj_R, R, ArgInfo("R", 1)) &&
        jsopencv_to_safe(jsobj_T, T, ArgInfo("T", 1)) &&
        jsopencv_to_safe(jsobj_rvecs, rvecs, ArgInfo("rvecs", 1)) &&
        jsopencv_to_safe(jsobj_tvecs, tvecs, ArgInfo("tvecs", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_criteria, criteria, ArgInfo("criteria", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::fisheye::stereoCalibrate(objectPoints, imagePoints1, imagePoints2, K1, D1, K2, D2, imageSize, R, T, rvecs, tvecs, flags, criteria));
        return Js_BuildValue(info, "(NNNNNNNNN)", jsopencv_from(info, retval), jsopencv_from(info, K1), jsopencv_from(info, D1), jsopencv_from(info, K2), jsopencv_from(info, D2), jsopencv_from(info, R), jsopencv_from(info, T), jsopencv_from(info, rvecs), jsopencv_from(info, tvecs));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_objectPoints = NULL;
    vector_UMat objectPoints;
    Napi::Value* jsobj_imagePoints1 = NULL;
    vector_UMat imagePoints1;
    Napi::Value* jsobj_imagePoints2 = NULL;
    vector_UMat imagePoints2;
    Napi::Value* jsobj_K1 = NULL;
    UMat K1;
    Napi::Value* jsobj_D1 = NULL;
    UMat D1;
    Napi::Value* jsobj_K2 = NULL;
    UMat K2;
    Napi::Value* jsobj_D2 = NULL;
    UMat D2;
    Napi::Value* jsobj_imageSize = NULL;
    Size imageSize;
    Napi::Value* jsobj_R = NULL;
    UMat R;
    Napi::Value* jsobj_T = NULL;
    UMat T;
    Napi::Value* jsobj_rvecs = NULL;
    vector_UMat rvecs;
    Napi::Value* jsobj_tvecs = NULL;
    vector_UMat tvecs;
    Napi::Value* jsobj_flags = NULL;
    int flags=fisheye::CALIB_FIX_INTRINSIC;
    Napi::Value* jsobj_criteria = NULL;
    TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, DBL_EPSILON);
    double retval;

    const char* keywords[] = { "objectPoints", "imagePoints1", "imagePoints2", "K1", "D1", "K2", "D2", "imageSize", "R", "T", "rvecs", "tvecs", "flags", "criteria", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOOOO|OOOOOO:stereoCalibrate", (char**)keywords, &jsobj_objectPoints, &jsobj_imagePoints1, &jsobj_imagePoints2, &jsobj_K1, &jsobj_D1, &jsobj_K2, &jsobj_D2, &jsobj_imageSize, &jsobj_R, &jsobj_T, &jsobj_rvecs, &jsobj_tvecs, &jsobj_flags, &jsobj_criteria) &&
        jsopencv_to_safe(jsobj_objectPoints, objectPoints, ArgInfo("objectPoints", 0)) &&
        jsopencv_to_safe(jsobj_imagePoints1, imagePoints1, ArgInfo("imagePoints1", 0)) &&
        jsopencv_to_safe(jsobj_imagePoints2, imagePoints2, ArgInfo("imagePoints2", 0)) &&
        jsopencv_to_safe(jsobj_K1, K1, ArgInfo("K1", 1)) &&
        jsopencv_to_safe(jsobj_D1, D1, ArgInfo("D1", 1)) &&
        jsopencv_to_safe(jsobj_K2, K2, ArgInfo("K2", 1)) &&
        jsopencv_to_safe(jsobj_D2, D2, ArgInfo("D2", 1)) &&
        jsopencv_to_safe(jsobj_imageSize, imageSize, ArgInfo("imageSize", 0)) &&
        jsopencv_to_safe(jsobj_R, R, ArgInfo("R", 1)) &&
        jsopencv_to_safe(jsobj_T, T, ArgInfo("T", 1)) &&
        jsopencv_to_safe(jsobj_rvecs, rvecs, ArgInfo("rvecs", 1)) &&
        jsopencv_to_safe(jsobj_tvecs, tvecs, ArgInfo("tvecs", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_criteria, criteria, ArgInfo("criteria", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::fisheye::stereoCalibrate(objectPoints, imagePoints1, imagePoints2, K1, D1, K2, D2, imageSize, R, T, rvecs, tvecs, flags, criteria));
        return Js_BuildValue(info, "(NNNNNNNNN)", jsopencv_from(info, retval), jsopencv_from(info, K1), jsopencv_from(info, D1), jsopencv_from(info, K2), jsopencv_from(info, D2), jsopencv_from(info, R), jsopencv_from(info, T), jsopencv_from(info, rvecs), jsopencv_from(info, tvecs));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_objectPoints = NULL;
    vector_Mat objectPoints;
    Napi::Value* jsobj_imagePoints1 = NULL;
    vector_Mat imagePoints1;
    Napi::Value* jsobj_imagePoints2 = NULL;
    vector_Mat imagePoints2;
    Napi::Value* jsobj_K1 = NULL;
    Mat K1;
    Napi::Value* jsobj_D1 = NULL;
    Mat D1;
    Napi::Value* jsobj_K2 = NULL;
    Mat K2;
    Napi::Value* jsobj_D2 = NULL;
    Mat D2;
    Napi::Value* jsobj_imageSize = NULL;
    Size imageSize;
    Napi::Value* jsobj_R = NULL;
    Mat R;
    Napi::Value* jsobj_T = NULL;
    Mat T;
    Napi::Value* jsobj_flags = NULL;
    int flags=fisheye::CALIB_FIX_INTRINSIC;
    Napi::Value* jsobj_criteria = NULL;
    TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, DBL_EPSILON);
    double retval;

    const char* keywords[] = { "objectPoints", "imagePoints1", "imagePoints2", "K1", "D1", "K2", "D2", "imageSize", "R", "T", "flags", "criteria", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOOOO|OOOO:stereoCalibrate", (char**)keywords, &jsobj_objectPoints, &jsobj_imagePoints1, &jsobj_imagePoints2, &jsobj_K1, &jsobj_D1, &jsobj_K2, &jsobj_D2, &jsobj_imageSize, &jsobj_R, &jsobj_T, &jsobj_flags, &jsobj_criteria) &&
        jsopencv_to_safe(jsobj_objectPoints, objectPoints, ArgInfo("objectPoints", 0)) &&
        jsopencv_to_safe(jsobj_imagePoints1, imagePoints1, ArgInfo("imagePoints1", 0)) &&
        jsopencv_to_safe(jsobj_imagePoints2, imagePoints2, ArgInfo("imagePoints2", 0)) &&
        jsopencv_to_safe(jsobj_K1, K1, ArgInfo("K1", 1)) &&
        jsopencv_to_safe(jsobj_D1, D1, ArgInfo("D1", 1)) &&
        jsopencv_to_safe(jsobj_K2, K2, ArgInfo("K2", 1)) &&
        jsopencv_to_safe(jsobj_D2, D2, ArgInfo("D2", 1)) &&
        jsopencv_to_safe(jsobj_imageSize, imageSize, ArgInfo("imageSize", 0)) &&
        jsopencv_to_safe(jsobj_R, R, ArgInfo("R", 1)) &&
        jsopencv_to_safe(jsobj_T, T, ArgInfo("T", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_criteria, criteria, ArgInfo("criteria", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::fisheye::stereoCalibrate(objectPoints, imagePoints1, imagePoints2, K1, D1, K2, D2, imageSize, R, T, flags, criteria));
        return Js_BuildValue(info, "(NNNNNNN)", jsopencv_from(info, retval), jsopencv_from(info, K1), jsopencv_from(info, D1), jsopencv_from(info, K2), jsopencv_from(info, D2), jsopencv_from(info, R), jsopencv_from(info, T));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_objectPoints = NULL;
    vector_UMat objectPoints;
    Napi::Value* jsobj_imagePoints1 = NULL;
    vector_UMat imagePoints1;
    Napi::Value* jsobj_imagePoints2 = NULL;
    vector_UMat imagePoints2;
    Napi::Value* jsobj_K1 = NULL;
    UMat K1;
    Napi::Value* jsobj_D1 = NULL;
    UMat D1;
    Napi::Value* jsobj_K2 = NULL;
    UMat K2;
    Napi::Value* jsobj_D2 = NULL;
    UMat D2;
    Napi::Value* jsobj_imageSize = NULL;
    Size imageSize;
    Napi::Value* jsobj_R = NULL;
    UMat R;
    Napi::Value* jsobj_T = NULL;
    UMat T;
    Napi::Value* jsobj_flags = NULL;
    int flags=fisheye::CALIB_FIX_INTRINSIC;
    Napi::Value* jsobj_criteria = NULL;
    TermCriteria criteria=TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 100, DBL_EPSILON);
    double retval;

    const char* keywords[] = { "objectPoints", "imagePoints1", "imagePoints2", "K1", "D1", "K2", "D2", "imageSize", "R", "T", "flags", "criteria", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOOOO|OOOO:stereoCalibrate", (char**)keywords, &jsobj_objectPoints, &jsobj_imagePoints1, &jsobj_imagePoints2, &jsobj_K1, &jsobj_D1, &jsobj_K2, &jsobj_D2, &jsobj_imageSize, &jsobj_R, &jsobj_T, &jsobj_flags, &jsobj_criteria) &&
        jsopencv_to_safe(jsobj_objectPoints, objectPoints, ArgInfo("objectPoints", 0)) &&
        jsopencv_to_safe(jsobj_imagePoints1, imagePoints1, ArgInfo("imagePoints1", 0)) &&
        jsopencv_to_safe(jsobj_imagePoints2, imagePoints2, ArgInfo("imagePoints2", 0)) &&
        jsopencv_to_safe(jsobj_K1, K1, ArgInfo("K1", 1)) &&
        jsopencv_to_safe(jsobj_D1, D1, ArgInfo("D1", 1)) &&
        jsopencv_to_safe(jsobj_K2, K2, ArgInfo("K2", 1)) &&
        jsopencv_to_safe(jsobj_D2, D2, ArgInfo("D2", 1)) &&
        jsopencv_to_safe(jsobj_imageSize, imageSize, ArgInfo("imageSize", 0)) &&
        jsopencv_to_safe(jsobj_R, R, ArgInfo("R", 1)) &&
        jsopencv_to_safe(jsobj_T, T, ArgInfo("T", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_criteria, criteria, ArgInfo("criteria", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::fisheye::stereoCalibrate(objectPoints, imagePoints1, imagePoints2, K1, D1, K2, D2, imageSize, R, T, flags, criteria));
        return Js_BuildValue(info, "(NNNNNNN)", jsopencv_from(info, retval), jsopencv_from(info, K1), jsopencv_from(info, D1), jsopencv_from(info, K2), jsopencv_from(info, D2), jsopencv_from(info, R), jsopencv_from(info, T));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "stereoCalibrate");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_fisheye_stereoRectify(const Napi::CallbackInfo &info)
{
    using namespace cv::fisheye;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_K1 = NULL;
    Mat K1;
    Napi::Value* jsobj_D1 = NULL;
    Mat D1;
    Napi::Value* jsobj_K2 = NULL;
    Mat K2;
    Napi::Value* jsobj_D2 = NULL;
    Mat D2;
    Napi::Value* jsobj_imageSize = NULL;
    Size imageSize;
    Napi::Value* jsobj_R = NULL;
    Mat R;
    Napi::Value* jsobj_tvec = NULL;
    Mat tvec;
    Napi::Value* jsobj_R1 = NULL;
    Mat R1;
    Napi::Value* jsobj_R2 = NULL;
    Mat R2;
    Napi::Value* jsobj_P1 = NULL;
    Mat P1;
    Napi::Value* jsobj_P2 = NULL;
    Mat P2;
    Napi::Value* jsobj_Q = NULL;
    Mat Q;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;
    Napi::Value* jsobj_newImageSize = NULL;
    Size newImageSize;
    Napi::Value* jsobj_balance = NULL;
    double balance=0.0;
    Napi::Value* jsobj_fov_scale = NULL;
    double fov_scale=1.0;

    const char* keywords[] = { "K1", "D1", "K2", "D2", "imageSize", "R", "tvec", "flags", "R1", "R2", "P1", "P2", "Q", "newImageSize", "balance", "fov_scale", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOOOO|OOOOOOOO:stereoRectify", (char**)keywords, &jsobj_K1, &jsobj_D1, &jsobj_K2, &jsobj_D2, &jsobj_imageSize, &jsobj_R, &jsobj_tvec, &jsobj_flags, &jsobj_R1, &jsobj_R2, &jsobj_P1, &jsobj_P2, &jsobj_Q, &jsobj_newImageSize, &jsobj_balance, &jsobj_fov_scale) &&
        jsopencv_to_safe(jsobj_K1, K1, ArgInfo("K1", 0)) &&
        jsopencv_to_safe(jsobj_D1, D1, ArgInfo("D1", 0)) &&
        jsopencv_to_safe(jsobj_K2, K2, ArgInfo("K2", 0)) &&
        jsopencv_to_safe(jsobj_D2, D2, ArgInfo("D2", 0)) &&
        jsopencv_to_safe(jsobj_imageSize, imageSize, ArgInfo("imageSize", 0)) &&
        jsopencv_to_safe(jsobj_R, R, ArgInfo("R", 0)) &&
        jsopencv_to_safe(jsobj_tvec, tvec, ArgInfo("tvec", 0)) &&
        jsopencv_to_safe(jsobj_R1, R1, ArgInfo("R1", 1)) &&
        jsopencv_to_safe(jsobj_R2, R2, ArgInfo("R2", 1)) &&
        jsopencv_to_safe(jsobj_P1, P1, ArgInfo("P1", 1)) &&
        jsopencv_to_safe(jsobj_P2, P2, ArgInfo("P2", 1)) &&
        jsopencv_to_safe(jsobj_Q, Q, ArgInfo("Q", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_newImageSize, newImageSize, ArgInfo("newImageSize", 0)) &&
        jsopencv_to_safe(jsobj_balance, balance, ArgInfo("balance", 0)) &&
        jsopencv_to_safe(jsobj_fov_scale, fov_scale, ArgInfo("fov_scale", 0)))
    {
        ERRWRAP2_NAPI(info, cv::fisheye::stereoRectify(K1, D1, K2, D2, imageSize, R, tvec, R1, R2, P1, P2, Q, flags, newImageSize, balance, fov_scale));
        return Js_BuildValue(info, "(NNNNN)", jsopencv_from(info, R1), jsopencv_from(info, R2), jsopencv_from(info, P1), jsopencv_from(info, P2), jsopencv_from(info, Q));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_K1 = NULL;
    UMat K1;
    Napi::Value* jsobj_D1 = NULL;
    UMat D1;
    Napi::Value* jsobj_K2 = NULL;
    UMat K2;
    Napi::Value* jsobj_D2 = NULL;
    UMat D2;
    Napi::Value* jsobj_imageSize = NULL;
    Size imageSize;
    Napi::Value* jsobj_R = NULL;
    UMat R;
    Napi::Value* jsobj_tvec = NULL;
    UMat tvec;
    Napi::Value* jsobj_R1 = NULL;
    UMat R1;
    Napi::Value* jsobj_R2 = NULL;
    UMat R2;
    Napi::Value* jsobj_P1 = NULL;
    UMat P1;
    Napi::Value* jsobj_P2 = NULL;
    UMat P2;
    Napi::Value* jsobj_Q = NULL;
    UMat Q;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;
    Napi::Value* jsobj_newImageSize = NULL;
    Size newImageSize;
    Napi::Value* jsobj_balance = NULL;
    double balance=0.0;
    Napi::Value* jsobj_fov_scale = NULL;
    double fov_scale=1.0;

    const char* keywords[] = { "K1", "D1", "K2", "D2", "imageSize", "R", "tvec", "flags", "R1", "R2", "P1", "P2", "Q", "newImageSize", "balance", "fov_scale", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOOOO|OOOOOOOO:stereoRectify", (char**)keywords, &jsobj_K1, &jsobj_D1, &jsobj_K2, &jsobj_D2, &jsobj_imageSize, &jsobj_R, &jsobj_tvec, &jsobj_flags, &jsobj_R1, &jsobj_R2, &jsobj_P1, &jsobj_P2, &jsobj_Q, &jsobj_newImageSize, &jsobj_balance, &jsobj_fov_scale) &&
        jsopencv_to_safe(jsobj_K1, K1, ArgInfo("K1", 0)) &&
        jsopencv_to_safe(jsobj_D1, D1, ArgInfo("D1", 0)) &&
        jsopencv_to_safe(jsobj_K2, K2, ArgInfo("K2", 0)) &&
        jsopencv_to_safe(jsobj_D2, D2, ArgInfo("D2", 0)) &&
        jsopencv_to_safe(jsobj_imageSize, imageSize, ArgInfo("imageSize", 0)) &&
        jsopencv_to_safe(jsobj_R, R, ArgInfo("R", 0)) &&
        jsopencv_to_safe(jsobj_tvec, tvec, ArgInfo("tvec", 0)) &&
        jsopencv_to_safe(jsobj_R1, R1, ArgInfo("R1", 1)) &&
        jsopencv_to_safe(jsobj_R2, R2, ArgInfo("R2", 1)) &&
        jsopencv_to_safe(jsobj_P1, P1, ArgInfo("P1", 1)) &&
        jsopencv_to_safe(jsobj_P2, P2, ArgInfo("P2", 1)) &&
        jsopencv_to_safe(jsobj_Q, Q, ArgInfo("Q", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_newImageSize, newImageSize, ArgInfo("newImageSize", 0)) &&
        jsopencv_to_safe(jsobj_balance, balance, ArgInfo("balance", 0)) &&
        jsopencv_to_safe(jsobj_fov_scale, fov_scale, ArgInfo("fov_scale", 0)))
    {
        ERRWRAP2_NAPI(info, cv::fisheye::stereoRectify(K1, D1, K2, D2, imageSize, R, tvec, R1, R2, P1, P2, Q, flags, newImageSize, balance, fov_scale));
        return Js_BuildValue(info, "(NNNNN)", jsopencv_from(info, R1), jsopencv_from(info, R2), jsopencv_from(info, P1), jsopencv_from(info, P2), jsopencv_from(info, Q));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "stereoRectify");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_fisheye_undistortImage(const Napi::CallbackInfo &info)
{
    using namespace cv::fisheye;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_distorted = NULL;
    Mat distorted;
    Napi::Value* jsobj_undistorted = NULL;
    Mat undistorted;
    Napi::Value* jsobj_K = NULL;
    Mat K;
    Napi::Value* jsobj_D = NULL;
    Mat D;
    Napi::Value* jsobj_Knew = NULL;
    Mat Knew=cv::Mat();
    Napi::Value* jsobj_new_size = NULL;
    Size new_size;

    const char* keywords[] = { "distorted", "K", "D", "undistorted", "Knew", "new_size", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOO:undistortImage", (char**)keywords, &jsobj_distorted, &jsobj_K, &jsobj_D, &jsobj_undistorted, &jsobj_Knew, &jsobj_new_size) &&
        jsopencv_to_safe(jsobj_distorted, distorted, ArgInfo("distorted", 0)) &&
        jsopencv_to_safe(jsobj_undistorted, undistorted, ArgInfo("undistorted", 1)) &&
        jsopencv_to_safe(jsobj_K, K, ArgInfo("K", 0)) &&
        jsopencv_to_safe(jsobj_D, D, ArgInfo("D", 0)) &&
        jsopencv_to_safe(jsobj_Knew, Knew, ArgInfo("Knew", 0)) &&
        jsopencv_to_safe(jsobj_new_size, new_size, ArgInfo("new_size", 0)))
    {
        ERRWRAP2_NAPI(info, cv::fisheye::undistortImage(distorted, undistorted, K, D, Knew, new_size));
        return jsopencv_from(info, undistorted);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_distorted = NULL;
    UMat distorted;
    Napi::Value* jsobj_undistorted = NULL;
    UMat undistorted;
    Napi::Value* jsobj_K = NULL;
    UMat K;
    Napi::Value* jsobj_D = NULL;
    UMat D;
    Napi::Value* jsobj_Knew = NULL;
    UMat Knew=cv::UMat();
    Napi::Value* jsobj_new_size = NULL;
    Size new_size;

    const char* keywords[] = { "distorted", "K", "D", "undistorted", "Knew", "new_size", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOO:undistortImage", (char**)keywords, &jsobj_distorted, &jsobj_K, &jsobj_D, &jsobj_undistorted, &jsobj_Knew, &jsobj_new_size) &&
        jsopencv_to_safe(jsobj_distorted, distorted, ArgInfo("distorted", 0)) &&
        jsopencv_to_safe(jsobj_undistorted, undistorted, ArgInfo("undistorted", 1)) &&
        jsopencv_to_safe(jsobj_K, K, ArgInfo("K", 0)) &&
        jsopencv_to_safe(jsobj_D, D, ArgInfo("D", 0)) &&
        jsopencv_to_safe(jsobj_Knew, Knew, ArgInfo("Knew", 0)) &&
        jsopencv_to_safe(jsobj_new_size, new_size, ArgInfo("new_size", 0)))
    {
        ERRWRAP2_NAPI(info, cv::fisheye::undistortImage(distorted, undistorted, K, D, Knew, new_size));
        return jsopencv_from(info, undistorted);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "undistortImage");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_fisheye_undistortPoints(const Napi::CallbackInfo &info)
{
    using namespace cv::fisheye;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_distorted = NULL;
    Mat distorted;
    Napi::Value* jsobj_undistorted = NULL;
    Mat undistorted;
    Napi::Value* jsobj_K = NULL;
    Mat K;
    Napi::Value* jsobj_D = NULL;
    Mat D;
    Napi::Value* jsobj_R = NULL;
    Mat R;
    Napi::Value* jsobj_P = NULL;
    Mat P;
    Napi::Value* jsobj_criteria = NULL;
    TermCriteria criteria=TermCriteria(TermCriteria::MAX_ITER + TermCriteria::EPS, 10, 1e-8);

    const char* keywords[] = { "distorted", "K", "D", "undistorted", "R", "P", "criteria", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOOO:undistortPoints", (char**)keywords, &jsobj_distorted, &jsobj_K, &jsobj_D, &jsobj_undistorted, &jsobj_R, &jsobj_P, &jsobj_criteria) &&
        jsopencv_to_safe(jsobj_distorted, distorted, ArgInfo("distorted", 0)) &&
        jsopencv_to_safe(jsobj_undistorted, undistorted, ArgInfo("undistorted", 1)) &&
        jsopencv_to_safe(jsobj_K, K, ArgInfo("K", 0)) &&
        jsopencv_to_safe(jsobj_D, D, ArgInfo("D", 0)) &&
        jsopencv_to_safe(jsobj_R, R, ArgInfo("R", 0)) &&
        jsopencv_to_safe(jsobj_P, P, ArgInfo("P", 0)) &&
        jsopencv_to_safe(jsobj_criteria, criteria, ArgInfo("criteria", 0)))
    {
        ERRWRAP2_NAPI(info, cv::fisheye::undistortPoints(distorted, undistorted, K, D, R, P, criteria));
        return jsopencv_from(info, undistorted);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_distorted = NULL;
    UMat distorted;
    Napi::Value* jsobj_undistorted = NULL;
    UMat undistorted;
    Napi::Value* jsobj_K = NULL;
    UMat K;
    Napi::Value* jsobj_D = NULL;
    UMat D;
    Napi::Value* jsobj_R = NULL;
    UMat R;
    Napi::Value* jsobj_P = NULL;
    UMat P;
    Napi::Value* jsobj_criteria = NULL;
    TermCriteria criteria=TermCriteria(TermCriteria::MAX_ITER + TermCriteria::EPS, 10, 1e-8);

    const char* keywords[] = { "distorted", "K", "D", "undistorted", "R", "P", "criteria", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOOO:undistortPoints", (char**)keywords, &jsobj_distorted, &jsobj_K, &jsobj_D, &jsobj_undistorted, &jsobj_R, &jsobj_P, &jsobj_criteria) &&
        jsopencv_to_safe(jsobj_distorted, distorted, ArgInfo("distorted", 0)) &&
        jsopencv_to_safe(jsobj_undistorted, undistorted, ArgInfo("undistorted", 1)) &&
        jsopencv_to_safe(jsobj_K, K, ArgInfo("K", 0)) &&
        jsopencv_to_safe(jsobj_D, D, ArgInfo("D", 0)) &&
        jsopencv_to_safe(jsobj_R, R, ArgInfo("R", 0)) &&
        jsopencv_to_safe(jsobj_P, P, ArgInfo("P", 0)) &&
        jsopencv_to_safe(jsobj_criteria, criteria, ArgInfo("criteria", 0)))
    {
        ERRWRAP2_NAPI(info, cv::fisheye::undistortPoints(distorted, undistorted, K, D, R, P, criteria));
        return jsopencv_from(info, undistorted);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "undistortPoints");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_BGR2Gray(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    GMat retval;

    const char* keywords[] = { "src", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:BGR2Gray", (char**)keywords, &jsobj_src) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::BGR2Gray(src));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_BGR2I420(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    GMat retval;

    const char* keywords[] = { "src", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:BGR2I420", (char**)keywords, &jsobj_src) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::BGR2I420(src));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_BGR2LUV(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    GMat retval;

    const char* keywords[] = { "src", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:BGR2LUV", (char**)keywords, &jsobj_src) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::BGR2LUV(src));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_BGR2RGB(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    GMat retval;

    const char* keywords[] = { "src", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:BGR2RGB", (char**)keywords, &jsobj_src) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::BGR2RGB(src));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_BGR2YUV(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    GMat retval;

    const char* keywords[] = { "src", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:BGR2YUV", (char**)keywords, &jsobj_src) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::BGR2YUV(src));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_BayerGR2RGB(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src_gr = NULL;
    cv::GMat src_gr;
    GMat retval;

    const char* keywords[] = { "src_gr", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:BayerGR2RGB", (char**)keywords, &jsobj_src_gr) &&
        jsopencv_to_safe(jsobj_src_gr, src_gr, ArgInfo("src_gr", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::BayerGR2RGB(src_gr));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_Canny(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_image = NULL;
    cv::GMat image;
    Napi::Value* jsobj_threshold1 = NULL;
    double threshold1=0;
    Napi::Value* jsobj_threshold2 = NULL;
    double threshold2=0;
    Napi::Value* jsobj_apertureSize = NULL;
    int apertureSize=3;
    Napi::Value* jsobj_L2gradient = NULL;
    bool L2gradient=false;
    GMat retval;

    const char* keywords[] = { "image", "threshold1", "threshold2", "apertureSize", "L2gradient", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OO:Canny", (char**)keywords, &jsobj_image, &jsobj_threshold1, &jsobj_threshold2, &jsobj_apertureSize, &jsobj_L2gradient) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_threshold1, threshold1, ArgInfo("threshold1", 0)) &&
        jsopencv_to_safe(jsobj_threshold2, threshold2, ArgInfo("threshold2", 0)) &&
        jsopencv_to_safe(jsobj_apertureSize, apertureSize, ArgInfo("apertureSize", 0)) &&
        jsopencv_to_safe(jsobj_L2gradient, L2gradient, ArgInfo("L2gradient", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::Canny(image, threshold1, threshold2, apertureSize, L2gradient));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_I4202BGR(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    GMat retval;

    const char* keywords[] = { "src", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:I4202BGR", (char**)keywords, &jsobj_src) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::I4202BGR(src));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_I4202RGB(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    GMat retval;

    const char* keywords[] = { "src", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:I4202RGB", (char**)keywords, &jsobj_src) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::I4202RGB(src));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_LUT(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    Napi::Value* jsobj_lut = NULL;
    Mat lut;
    GMat retval;

    const char* keywords[] = { "src", "lut", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:LUT", (char**)keywords, &jsobj_src, &jsobj_lut) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_lut, lut, ArgInfo("lut", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::LUT(src, lut));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_LUV2BGR(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    GMat retval;

    const char* keywords[] = { "src", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:LUV2BGR", (char**)keywords, &jsobj_src) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::LUV2BGR(src));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_Laplacian(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    Napi::Value* jsobj_ddepth = NULL;
    int ddepth=0;
    Napi::Value* jsobj_ksize = NULL;
    int ksize=1;
    Napi::Value* jsobj_scale = NULL;
    double scale=1;
    Napi::Value* jsobj_delta = NULL;
    double delta=0;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_DEFAULT;
    GMat retval;

    const char* keywords[] = { "src", "ddepth", "ksize", "scale", "delta", "borderType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOOO:Laplacian", (char**)keywords, &jsobj_src, &jsobj_ddepth, &jsobj_ksize, &jsobj_scale, &jsobj_delta, &jsobj_borderType) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_ddepth, ddepth, ArgInfo("ddepth", 0)) &&
        jsopencv_to_safe(jsobj_ksize, ksize, ArgInfo("ksize", 0)) &&
        jsopencv_to_safe(jsobj_scale, scale, ArgInfo("scale", 0)) &&
        jsopencv_to_safe(jsobj_delta, delta, ArgInfo("delta", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::Laplacian(src, ddepth, ksize, scale, delta, borderType));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_NV12toBGR(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src_y = NULL;
    cv::GMat src_y;
    Napi::Value* jsobj_src_uv = NULL;
    cv::GMat src_uv;
    GMat retval;

    const char* keywords[] = { "src_y", "src_uv", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:NV12toBGR", (char**)keywords, &jsobj_src_y, &jsobj_src_uv) &&
        jsopencv_to_safe(jsobj_src_y, src_y, ArgInfo("src_y", 0)) &&
        jsopencv_to_safe(jsobj_src_uv, src_uv, ArgInfo("src_uv", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::NV12toBGR(src_y, src_uv));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_NV12toGray(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src_y = NULL;
    cv::GMat src_y;
    Napi::Value* jsobj_src_uv = NULL;
    cv::GMat src_uv;
    GMat retval;

    const char* keywords[] = { "src_y", "src_uv", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:NV12toGray", (char**)keywords, &jsobj_src_y, &jsobj_src_uv) &&
        jsopencv_to_safe(jsobj_src_y, src_y, ArgInfo("src_y", 0)) &&
        jsopencv_to_safe(jsobj_src_uv, src_uv, ArgInfo("src_uv", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::NV12toGray(src_y, src_uv));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_NV12toRGB(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src_y = NULL;
    cv::GMat src_y;
    Napi::Value* jsobj_src_uv = NULL;
    cv::GMat src_uv;
    GMat retval;

    const char* keywords[] = { "src_y", "src_uv", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:NV12toRGB", (char**)keywords, &jsobj_src_y, &jsobj_src_uv) &&
        jsopencv_to_safe(jsobj_src_y, src_y, ArgInfo("src_y", 0)) &&
        jsopencv_to_safe(jsobj_src_uv, src_uv, ArgInfo("src_uv", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::NV12toRGB(src_y, src_uv));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_RGB2Gray(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    GMat retval;

    const char* keywords[] = { "src", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:RGB2Gray", (char**)keywords, &jsobj_src) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::RGB2Gray(src));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    Napi::Value* jsobj_rY = NULL;
    float rY=0.f;
    Napi::Value* jsobj_gY = NULL;
    float gY=0.f;
    Napi::Value* jsobj_bY = NULL;
    float bY=0.f;
    GMat retval;

    const char* keywords[] = { "src", "rY", "gY", "bY", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO:RGB2Gray", (char**)keywords, &jsobj_src, &jsobj_rY, &jsobj_gY, &jsobj_bY) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_rY, rY, ArgInfo("rY", 0)) &&
        jsopencv_to_safe(jsobj_gY, gY, ArgInfo("gY", 0)) &&
        jsopencv_to_safe(jsobj_bY, bY, ArgInfo("bY", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::RGB2Gray(src, rY, gY, bY));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "RGB2Gray");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_RGB2HSV(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    GMat retval;

    const char* keywords[] = { "src", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:RGB2HSV", (char**)keywords, &jsobj_src) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::RGB2HSV(src));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_RGB2I420(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    GMat retval;

    const char* keywords[] = { "src", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:RGB2I420", (char**)keywords, &jsobj_src) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::RGB2I420(src));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_RGB2Lab(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    GMat retval;

    const char* keywords[] = { "src", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:RGB2Lab", (char**)keywords, &jsobj_src) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::RGB2Lab(src));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_RGB2YUV(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    GMat retval;

    const char* keywords[] = { "src", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:RGB2YUV", (char**)keywords, &jsobj_src) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::RGB2YUV(src));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_RGB2YUV422(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    GMat retval;

    const char* keywords[] = { "src", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:RGB2YUV422", (char**)keywords, &jsobj_src) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::RGB2YUV422(src));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_Sobel(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    Napi::Value* jsobj_ddepth = NULL;
    int ddepth=0;
    Napi::Value* jsobj_dx = NULL;
    int dx=0;
    Napi::Value* jsobj_dy = NULL;
    int dy=0;
    Napi::Value* jsobj_ksize = NULL;
    int ksize=3;
    Napi::Value* jsobj_scale = NULL;
    double scale=1;
    Napi::Value* jsobj_delta = NULL;
    double delta=0;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_DEFAULT;
    Napi::Value* jsobj_borderValue = NULL;
    Scalar borderValue=Scalar(0);
    GMat retval;

    const char* keywords[] = { "src", "ddepth", "dx", "dy", "ksize", "scale", "delta", "borderType", "borderValue", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOOOO:Sobel", (char**)keywords, &jsobj_src, &jsobj_ddepth, &jsobj_dx, &jsobj_dy, &jsobj_ksize, &jsobj_scale, &jsobj_delta, &jsobj_borderType, &jsobj_borderValue) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_ddepth, ddepth, ArgInfo("ddepth", 0)) &&
        jsopencv_to_safe(jsobj_dx, dx, ArgInfo("dx", 0)) &&
        jsopencv_to_safe(jsobj_dy, dy, ArgInfo("dy", 0)) &&
        jsopencv_to_safe(jsobj_ksize, ksize, ArgInfo("ksize", 0)) &&
        jsopencv_to_safe(jsobj_scale, scale, ArgInfo("scale", 0)) &&
        jsopencv_to_safe(jsobj_delta, delta, ArgInfo("delta", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)) &&
        jsopencv_to_safe(jsobj_borderValue, borderValue, ArgInfo("borderValue", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::Sobel(src, ddepth, dx, dy, ksize, scale, delta, borderType, borderValue));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_SobelXY(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    Napi::Value* jsobj_ddepth = NULL;
    int ddepth=0;
    Napi::Value* jsobj_order = NULL;
    int order=0;
    Napi::Value* jsobj_ksize = NULL;
    int ksize=3;
    Napi::Value* jsobj_scale = NULL;
    double scale=1;
    Napi::Value* jsobj_delta = NULL;
    double delta=0;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_DEFAULT;
    Napi::Value* jsobj_borderValue = NULL;
    Scalar borderValue=Scalar(0);
    std::tuple<GMat, GMat> retval;

    const char* keywords[] = { "src", "ddepth", "order", "ksize", "scale", "delta", "borderType", "borderValue", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOOOO:SobelXY", (char**)keywords, &jsobj_src, &jsobj_ddepth, &jsobj_order, &jsobj_ksize, &jsobj_scale, &jsobj_delta, &jsobj_borderType, &jsobj_borderValue) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_ddepth, ddepth, ArgInfo("ddepth", 0)) &&
        jsopencv_to_safe(jsobj_order, order, ArgInfo("order", 0)) &&
        jsopencv_to_safe(jsobj_ksize, ksize, ArgInfo("ksize", 0)) &&
        jsopencv_to_safe(jsobj_scale, scale, ArgInfo("scale", 0)) &&
        jsopencv_to_safe(jsobj_delta, delta, ArgInfo("delta", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)) &&
        jsopencv_to_safe(jsobj_borderValue, borderValue, ArgInfo("borderValue", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::SobelXY(src, ddepth, order, ksize, scale, delta, borderType, borderValue));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_YUV2BGR(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    GMat retval;

    const char* keywords[] = { "src", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:YUV2BGR", (char**)keywords, &jsobj_src) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::YUV2BGR(src));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_YUV2RGB(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    GMat retval;

    const char* keywords[] = { "src", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:YUV2RGB", (char**)keywords, &jsobj_src) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::YUV2RGB(src));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_absDiff(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src1 = NULL;
    cv::GMat src1;
    Napi::Value* jsobj_src2 = NULL;
    cv::GMat src2;
    GMat retval;

    const char* keywords[] = { "src1", "src2", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:absDiff", (char**)keywords, &jsobj_src1, &jsobj_src2) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::absDiff(src1, src2));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_absDiffC(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    Napi::Value* jsobj_c = NULL;
    cv::GScalar c;
    GMat retval;

    const char* keywords[] = { "src", "c", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:absDiffC", (char**)keywords, &jsobj_src, &jsobj_c) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_c, c, ArgInfo("c", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::absDiffC(src, c));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_add(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src1 = NULL;
    cv::GMat src1;
    Napi::Value* jsobj_src2 = NULL;
    cv::GMat src2;
    Napi::Value* jsobj_ddepth = NULL;
    int ddepth=-1;
    GMat retval;

    const char* keywords[] = { "src1", "src2", "ddepth", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:add", (char**)keywords, &jsobj_src1, &jsobj_src2, &jsobj_ddepth) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_ddepth, ddepth, ArgInfo("ddepth", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::add(src1, src2, ddepth));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_addC(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src1 = NULL;
    cv::GMat src1;
    Napi::Value* jsobj_c = NULL;
    cv::GScalar c;
    Napi::Value* jsobj_ddepth = NULL;
    int ddepth=-1;
    GMat retval;

    const char* keywords[] = { "src1", "c", "ddepth", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:addC", (char**)keywords, &jsobj_src1, &jsobj_c, &jsobj_ddepth) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_c, c, ArgInfo("c", 0)) &&
        jsopencv_to_safe(jsobj_ddepth, ddepth, ArgInfo("ddepth", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::addC(src1, c, ddepth));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_c = NULL;
    cv::GScalar c;
    Napi::Value* jsobj_src1 = NULL;
    cv::GMat src1;
    Napi::Value* jsobj_ddepth = NULL;
    int ddepth=-1;
    GMat retval;

    const char* keywords[] = { "c", "src1", "ddepth", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:addC", (char**)keywords, &jsobj_c, &jsobj_src1, &jsobj_ddepth) &&
        jsopencv_to_safe(jsobj_c, c, ArgInfo("c", 0)) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_ddepth, ddepth, ArgInfo("ddepth", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::addC(c, src1, ddepth));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "addC");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_addWeighted(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src1 = NULL;
    cv::GMat src1;
    Napi::Value* jsobj_alpha = NULL;
    double alpha=0;
    Napi::Value* jsobj_src2 = NULL;
    cv::GMat src2;
    Napi::Value* jsobj_beta = NULL;
    double beta=0;
    Napi::Value* jsobj_gamma = NULL;
    double gamma=0;
    Napi::Value* jsobj_ddepth = NULL;
    int ddepth=-1;
    GMat retval;

    const char* keywords[] = { "src1", "alpha", "src2", "beta", "gamma", "ddepth", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOO|O:addWeighted", (char**)keywords, &jsobj_src1, &jsobj_alpha, &jsobj_src2, &jsobj_beta, &jsobj_gamma, &jsobj_ddepth) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_alpha, alpha, ArgInfo("alpha", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_beta, beta, ArgInfo("beta", 0)) &&
        jsopencv_to_safe(jsobj_gamma, gamma, ArgInfo("gamma", 0)) &&
        jsopencv_to_safe(jsobj_ddepth, ddepth, ArgInfo("ddepth", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::addWeighted(src1, alpha, src2, beta, gamma, ddepth));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_bilateralFilter(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    Napi::Value* jsobj_d = NULL;
    int d=0;
    Napi::Value* jsobj_sigmaColor = NULL;
    double sigmaColor=0;
    Napi::Value* jsobj_sigmaSpace = NULL;
    double sigmaSpace=0;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_DEFAULT;
    GMat retval;

    const char* keywords[] = { "src", "d", "sigmaColor", "sigmaSpace", "borderType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|O:bilateralFilter", (char**)keywords, &jsobj_src, &jsobj_d, &jsobj_sigmaColor, &jsobj_sigmaSpace, &jsobj_borderType) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_d, d, ArgInfo("d", 0)) &&
        jsopencv_to_safe(jsobj_sigmaColor, sigmaColor, ArgInfo("sigmaColor", 0)) &&
        jsopencv_to_safe(jsobj_sigmaSpace, sigmaSpace, ArgInfo("sigmaSpace", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::bilateralFilter(src, d, sigmaColor, sigmaSpace, borderType));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_bitwise_and(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src1 = NULL;
    cv::GMat src1;
    Napi::Value* jsobj_src2 = NULL;
    cv::GMat src2;
    GMat retval;

    const char* keywords[] = { "src1", "src2", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:bitwise_and", (char**)keywords, &jsobj_src1, &jsobj_src2) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::bitwise_and(src1, src2));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src1 = NULL;
    cv::GMat src1;
    Napi::Value* jsobj_src2 = NULL;
    cv::GScalar src2;
    GMat retval;

    const char* keywords[] = { "src1", "src2", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:bitwise_and", (char**)keywords, &jsobj_src1, &jsobj_src2) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::bitwise_and(src1, src2));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "bitwise_and");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_bitwise_not(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    GMat retval;

    const char* keywords[] = { "src", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:bitwise_not", (char**)keywords, &jsobj_src) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::bitwise_not(src));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_bitwise_or(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src1 = NULL;
    cv::GMat src1;
    Napi::Value* jsobj_src2 = NULL;
    cv::GMat src2;
    GMat retval;

    const char* keywords[] = { "src1", "src2", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:bitwise_or", (char**)keywords, &jsobj_src1, &jsobj_src2) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::bitwise_or(src1, src2));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src1 = NULL;
    cv::GMat src1;
    Napi::Value* jsobj_src2 = NULL;
    cv::GScalar src2;
    GMat retval;

    const char* keywords[] = { "src1", "src2", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:bitwise_or", (char**)keywords, &jsobj_src1, &jsobj_src2) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::bitwise_or(src1, src2));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "bitwise_or");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_bitwise_xor(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src1 = NULL;
    cv::GMat src1;
    Napi::Value* jsobj_src2 = NULL;
    cv::GMat src2;
    GMat retval;

    const char* keywords[] = { "src1", "src2", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:bitwise_xor", (char**)keywords, &jsobj_src1, &jsobj_src2) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::bitwise_xor(src1, src2));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src1 = NULL;
    cv::GMat src1;
    Napi::Value* jsobj_src2 = NULL;
    cv::GScalar src2;
    GMat retval;

    const char* keywords[] = { "src1", "src2", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:bitwise_xor", (char**)keywords, &jsobj_src1, &jsobj_src2) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::bitwise_xor(src1, src2));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "bitwise_xor");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_blur(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    Napi::Value* jsobj_ksize = NULL;
    Size ksize;
    Napi::Value* jsobj_anchor = NULL;
    Point anchor=Point(-1,-1);
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_DEFAULT;
    Napi::Value* jsobj_borderValue = NULL;
    Scalar borderValue=Scalar(0);
    GMat retval;

    const char* keywords[] = { "src", "ksize", "anchor", "borderType", "borderValue", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOO:blur", (char**)keywords, &jsobj_src, &jsobj_ksize, &jsobj_anchor, &jsobj_borderType, &jsobj_borderValue) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_ksize, ksize, ArgInfo("ksize", 0)) &&
        jsopencv_to_safe(jsobj_anchor, anchor, ArgInfo("anchor", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)) &&
        jsopencv_to_safe(jsobj_borderValue, borderValue, ArgInfo("borderValue", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::blur(src, ksize, anchor, borderType, borderValue));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_boundingRect(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    jsPrepareArgumentConversionErrorsStorage(3);

    {
    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    GOpaque<Rect> retval;

    const char* keywords[] = { "src", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:boundingRect", (char**)keywords, &jsobj_src) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::boundingRect(src));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    GArray_Point2i src;
    GOpaque<Rect> retval;

    const char* keywords[] = { "src", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:boundingRect", (char**)keywords, &jsobj_src) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::boundingRect(src));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    GArray_Point2f src;
    GOpaque<Rect> retval;

    const char* keywords[] = { "src", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:boundingRect", (char**)keywords, &jsobj_src) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::boundingRect(src));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "boundingRect");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_boxFilter(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    Napi::Value* jsobj_dtype = NULL;
    int dtype=0;
    Napi::Value* jsobj_ksize = NULL;
    Size ksize;
    Napi::Value* jsobj_anchor = NULL;
    Point anchor=Point(-1,-1);
    Napi::Value* jsobj_normalize = NULL;
    bool normalize=true;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_DEFAULT;
    Napi::Value* jsobj_borderValue = NULL;
    Scalar borderValue=Scalar(0);
    GMat retval;

    const char* keywords[] = { "src", "dtype", "ksize", "anchor", "normalize", "borderType", "borderValue", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOOO:boxFilter", (char**)keywords, &jsobj_src, &jsobj_dtype, &jsobj_ksize, &jsobj_anchor, &jsobj_normalize, &jsobj_borderType, &jsobj_borderValue) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dtype, dtype, ArgInfo("dtype", 0)) &&
        jsopencv_to_safe(jsobj_ksize, ksize, ArgInfo("ksize", 0)) &&
        jsopencv_to_safe(jsobj_anchor, anchor, ArgInfo("anchor", 0)) &&
        jsopencv_to_safe(jsobj_normalize, normalize, ArgInfo("normalize", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)) &&
        jsopencv_to_safe(jsobj_borderValue, borderValue, ArgInfo("borderValue", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::boxFilter(src, dtype, ksize, anchor, normalize, borderType, borderValue));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_cartToPolar(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_x = NULL;
    cv::GMat x;
    Napi::Value* jsobj_y = NULL;
    cv::GMat y;
    Napi::Value* jsobj_angleInDegrees = NULL;
    bool angleInDegrees=false;
    std::tuple<GMat, GMat> retval;

    const char* keywords[] = { "x", "y", "angleInDegrees", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:cartToPolar", (char**)keywords, &jsobj_x, &jsobj_y, &jsobj_angleInDegrees) &&
        jsopencv_to_safe(jsobj_x, x, ArgInfo("x", 0)) &&
        jsopencv_to_safe(jsobj_y, y, ArgInfo("y", 0)) &&
        jsopencv_to_safe(jsobj_angleInDegrees, angleInDegrees, ArgInfo("angleInDegrees", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::cartToPolar(x, y, angleInDegrees));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_cmpEQ(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src1 = NULL;
    cv::GMat src1;
    Napi::Value* jsobj_src2 = NULL;
    cv::GMat src2;
    GMat retval;

    const char* keywords[] = { "src1", "src2", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:cmpEQ", (char**)keywords, &jsobj_src1, &jsobj_src2) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::cmpEQ(src1, src2));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src1 = NULL;
    cv::GMat src1;
    Napi::Value* jsobj_src2 = NULL;
    cv::GScalar src2;
    GMat retval;

    const char* keywords[] = { "src1", "src2", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:cmpEQ", (char**)keywords, &jsobj_src1, &jsobj_src2) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::cmpEQ(src1, src2));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "cmpEQ");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_cmpGE(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src1 = NULL;
    cv::GMat src1;
    Napi::Value* jsobj_src2 = NULL;
    cv::GMat src2;
    GMat retval;

    const char* keywords[] = { "src1", "src2", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:cmpGE", (char**)keywords, &jsobj_src1, &jsobj_src2) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::cmpGE(src1, src2));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src1 = NULL;
    cv::GMat src1;
    Napi::Value* jsobj_src2 = NULL;
    cv::GScalar src2;
    GMat retval;

    const char* keywords[] = { "src1", "src2", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:cmpGE", (char**)keywords, &jsobj_src1, &jsobj_src2) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::cmpGE(src1, src2));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "cmpGE");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_cmpGT(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src1 = NULL;
    cv::GMat src1;
    Napi::Value* jsobj_src2 = NULL;
    cv::GMat src2;
    GMat retval;

    const char* keywords[] = { "src1", "src2", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:cmpGT", (char**)keywords, &jsobj_src1, &jsobj_src2) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::cmpGT(src1, src2));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src1 = NULL;
    cv::GMat src1;
    Napi::Value* jsobj_src2 = NULL;
    cv::GScalar src2;
    GMat retval;

    const char* keywords[] = { "src1", "src2", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:cmpGT", (char**)keywords, &jsobj_src1, &jsobj_src2) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::cmpGT(src1, src2));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "cmpGT");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_cmpLE(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src1 = NULL;
    cv::GMat src1;
    Napi::Value* jsobj_src2 = NULL;
    cv::GMat src2;
    GMat retval;

    const char* keywords[] = { "src1", "src2", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:cmpLE", (char**)keywords, &jsobj_src1, &jsobj_src2) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::cmpLE(src1, src2));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src1 = NULL;
    cv::GMat src1;
    Napi::Value* jsobj_src2 = NULL;
    cv::GScalar src2;
    GMat retval;

    const char* keywords[] = { "src1", "src2", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:cmpLE", (char**)keywords, &jsobj_src1, &jsobj_src2) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::cmpLE(src1, src2));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "cmpLE");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_cmpLT(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src1 = NULL;
    cv::GMat src1;
    Napi::Value* jsobj_src2 = NULL;
    cv::GMat src2;
    GMat retval;

    const char* keywords[] = { "src1", "src2", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:cmpLT", (char**)keywords, &jsobj_src1, &jsobj_src2) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::cmpLT(src1, src2));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src1 = NULL;
    cv::GMat src1;
    Napi::Value* jsobj_src2 = NULL;
    cv::GScalar src2;
    GMat retval;

    const char* keywords[] = { "src1", "src2", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:cmpLT", (char**)keywords, &jsobj_src1, &jsobj_src2) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::cmpLT(src1, src2));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "cmpLT");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_cmpNE(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src1 = NULL;
    cv::GMat src1;
    Napi::Value* jsobj_src2 = NULL;
    cv::GMat src2;
    GMat retval;

    const char* keywords[] = { "src1", "src2", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:cmpNE", (char**)keywords, &jsobj_src1, &jsobj_src2) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::cmpNE(src1, src2));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src1 = NULL;
    cv::GMat src1;
    Napi::Value* jsobj_src2 = NULL;
    cv::GScalar src2;
    GMat retval;

    const char* keywords[] = { "src1", "src2", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:cmpNE", (char**)keywords, &jsobj_src1, &jsobj_src2) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::cmpNE(src1, src2));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "cmpNE");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_concatHor(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src1 = NULL;
    cv::GMat src1;
    Napi::Value* jsobj_src2 = NULL;
    cv::GMat src2;
    GMat retval;

    const char* keywords[] = { "src1", "src2", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:concatHor", (char**)keywords, &jsobj_src1, &jsobj_src2) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::concatHor(src1, src2));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_v = NULL;
    vector_GMat v;
    GMat retval;

    const char* keywords[] = { "v", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:concatHor", (char**)keywords, &jsobj_v) &&
        jsopencv_to_safe(jsobj_v, v, ArgInfo("v", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::concatHor(v));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "concatHor");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_concatVert(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src1 = NULL;
    cv::GMat src1;
    Napi::Value* jsobj_src2 = NULL;
    cv::GMat src2;
    GMat retval;

    const char* keywords[] = { "src1", "src2", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:concatVert", (char**)keywords, &jsobj_src1, &jsobj_src2) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::concatVert(src1, src2));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_v = NULL;
    vector_GMat v;
    GMat retval;

    const char* keywords[] = { "v", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:concatVert", (char**)keywords, &jsobj_v) &&
        jsopencv_to_safe(jsobj_v, v, ArgInfo("v", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::concatVert(v));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "concatVert");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_convertTo(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    Napi::Value* jsobj_rdepth = NULL;
    int rdepth=0;
    Napi::Value* jsobj_alpha = NULL;
    double alpha=1;
    Napi::Value* jsobj_beta = NULL;
    double beta=0;
    GMat retval;

    const char* keywords[] = { "src", "rdepth", "alpha", "beta", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:convertTo", (char**)keywords, &jsobj_src, &jsobj_rdepth, &jsobj_alpha, &jsobj_beta) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_rdepth, rdepth, ArgInfo("rdepth", 0)) &&
        jsopencv_to_safe(jsobj_alpha, alpha, ArgInfo("alpha", 0)) &&
        jsopencv_to_safe(jsobj_beta, beta, ArgInfo("beta", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::convertTo(src, rdepth, alpha, beta));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_copy(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_in = NULL;
    cv::GMat in;
    GMat retval;

    const char* keywords[] = { "in_", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:copy", (char**)keywords, &jsobj_in) &&
        jsopencv_to_safe(jsobj_in, in, ArgInfo("in", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::copy(in));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_countNonZero(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    GOpaque<int> retval;

    const char* keywords[] = { "src", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:countNonZero", (char**)keywords, &jsobj_src) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::countNonZero(src));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_crop(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    Napi::Value* jsobj_rect = NULL;
    Rect rect;
    GMat retval;

    const char* keywords[] = { "src", "rect", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:crop", (char**)keywords, &jsobj_src, &jsobj_rect) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_rect, rect, ArgInfo("rect", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::crop(src, rect));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_dilate(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    Napi::Value* jsobj_kernel = NULL;
    Mat kernel;
    Napi::Value* jsobj_anchor = NULL;
    Point anchor=Point(-1,-1);
    Napi::Value* jsobj_iterations = NULL;
    int iterations=1;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_CONSTANT;
    Napi::Value* jsobj_borderValue = NULL;
    Scalar borderValue=morphologyDefaultBorderValue();
    GMat retval;

    const char* keywords[] = { "src", "kernel", "anchor", "iterations", "borderType", "borderValue", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOOO:dilate", (char**)keywords, &jsobj_src, &jsobj_kernel, &jsobj_anchor, &jsobj_iterations, &jsobj_borderType, &jsobj_borderValue) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_kernel, kernel, ArgInfo("kernel", 0)) &&
        jsopencv_to_safe(jsobj_anchor, anchor, ArgInfo("anchor", 0)) &&
        jsopencv_to_safe(jsobj_iterations, iterations, ArgInfo("iterations", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)) &&
        jsopencv_to_safe(jsobj_borderValue, borderValue, ArgInfo("borderValue", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::dilate(src, kernel, anchor, iterations, borderType, borderValue));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_dilate3x3(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    Napi::Value* jsobj_iterations = NULL;
    int iterations=1;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_CONSTANT;
    Napi::Value* jsobj_borderValue = NULL;
    Scalar borderValue=morphologyDefaultBorderValue();
    GMat retval;

    const char* keywords[] = { "src", "iterations", "borderType", "borderValue", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOO:dilate3x3", (char**)keywords, &jsobj_src, &jsobj_iterations, &jsobj_borderType, &jsobj_borderValue) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_iterations, iterations, ArgInfo("iterations", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)) &&
        jsopencv_to_safe(jsobj_borderValue, borderValue, ArgInfo("borderValue", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::dilate3x3(src, iterations, borderType, borderValue));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_div(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src1 = NULL;
    cv::GMat src1;
    Napi::Value* jsobj_src2 = NULL;
    cv::GMat src2;
    Napi::Value* jsobj_scale = NULL;
    double scale=0;
    Napi::Value* jsobj_ddepth = NULL;
    int ddepth=-1;
    GMat retval;

    const char* keywords[] = { "src1", "src2", "scale", "ddepth", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:div", (char**)keywords, &jsobj_src1, &jsobj_src2, &jsobj_scale, &jsobj_ddepth) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_scale, scale, ArgInfo("scale", 0)) &&
        jsopencv_to_safe(jsobj_ddepth, ddepth, ArgInfo("ddepth", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::div(src1, src2, scale, ddepth));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_divC(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    Napi::Value* jsobj_divisor = NULL;
    cv::GScalar divisor;
    Napi::Value* jsobj_scale = NULL;
    double scale=0;
    Napi::Value* jsobj_ddepth = NULL;
    int ddepth=-1;
    GMat retval;

    const char* keywords[] = { "src", "divisor", "scale", "ddepth", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:divC", (char**)keywords, &jsobj_src, &jsobj_divisor, &jsobj_scale, &jsobj_ddepth) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_divisor, divisor, ArgInfo("divisor", 0)) &&
        jsopencv_to_safe(jsobj_scale, scale, ArgInfo("scale", 0)) &&
        jsopencv_to_safe(jsobj_ddepth, ddepth, ArgInfo("ddepth", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::divC(src, divisor, scale, ddepth));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_divRC(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_divident = NULL;
    cv::GScalar divident;
    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    Napi::Value* jsobj_scale = NULL;
    double scale=0;
    Napi::Value* jsobj_ddepth = NULL;
    int ddepth=-1;
    GMat retval;

    const char* keywords[] = { "divident", "src", "scale", "ddepth", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:divRC", (char**)keywords, &jsobj_divident, &jsobj_src, &jsobj_scale, &jsobj_ddepth) &&
        jsopencv_to_safe(jsobj_divident, divident, ArgInfo("divident", 0)) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_scale, scale, ArgInfo("scale", 0)) &&
        jsopencv_to_safe(jsobj_ddepth, ddepth, ArgInfo("ddepth", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::divRC(divident, src, scale, ddepth));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_equalizeHist(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    GMat retval;

    const char* keywords[] = { "src", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:equalizeHist", (char**)keywords, &jsobj_src) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::equalizeHist(src));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_erode(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    Napi::Value* jsobj_kernel = NULL;
    Mat kernel;
    Napi::Value* jsobj_anchor = NULL;
    Point anchor=Point(-1,-1);
    Napi::Value* jsobj_iterations = NULL;
    int iterations=1;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_CONSTANT;
    Napi::Value* jsobj_borderValue = NULL;
    Scalar borderValue=morphologyDefaultBorderValue();
    GMat retval;

    const char* keywords[] = { "src", "kernel", "anchor", "iterations", "borderType", "borderValue", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOOO:erode", (char**)keywords, &jsobj_src, &jsobj_kernel, &jsobj_anchor, &jsobj_iterations, &jsobj_borderType, &jsobj_borderValue) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_kernel, kernel, ArgInfo("kernel", 0)) &&
        jsopencv_to_safe(jsobj_anchor, anchor, ArgInfo("anchor", 0)) &&
        jsopencv_to_safe(jsobj_iterations, iterations, ArgInfo("iterations", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)) &&
        jsopencv_to_safe(jsobj_borderValue, borderValue, ArgInfo("borderValue", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::erode(src, kernel, anchor, iterations, borderType, borderValue));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_erode3x3(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    Napi::Value* jsobj_iterations = NULL;
    int iterations=1;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_CONSTANT;
    Napi::Value* jsobj_borderValue = NULL;
    Scalar borderValue=morphologyDefaultBorderValue();
    GMat retval;

    const char* keywords[] = { "src", "iterations", "borderType", "borderValue", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOO:erode3x3", (char**)keywords, &jsobj_src, &jsobj_iterations, &jsobj_borderType, &jsobj_borderValue) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_iterations, iterations, ArgInfo("iterations", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)) &&
        jsopencv_to_safe(jsobj_borderValue, borderValue, ArgInfo("borderValue", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::erode3x3(src, iterations, borderType, borderValue));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_filter2D(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    Napi::Value* jsobj_ddepth = NULL;
    int ddepth=0;
    Napi::Value* jsobj_kernel = NULL;
    Mat kernel;
    Napi::Value* jsobj_anchor = NULL;
    Point anchor=Point(-1,-1);
    Napi::Value* jsobj_delta = NULL;
    Scalar delta=Scalar(0);
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_DEFAULT;
    Napi::Value* jsobj_borderValue = NULL;
    Scalar borderValue=Scalar(0);
    GMat retval;

    const char* keywords[] = { "src", "ddepth", "kernel", "anchor", "delta", "borderType", "borderValue", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOOO:filter2D", (char**)keywords, &jsobj_src, &jsobj_ddepth, &jsobj_kernel, &jsobj_anchor, &jsobj_delta, &jsobj_borderType, &jsobj_borderValue) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_ddepth, ddepth, ArgInfo("ddepth", 0)) &&
        jsopencv_to_safe(jsobj_kernel, kernel, ArgInfo("kernel", 0)) &&
        jsopencv_to_safe(jsobj_anchor, anchor, ArgInfo("anchor", 0)) &&
        jsopencv_to_safe(jsobj_delta, delta, ArgInfo("delta", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)) &&
        jsopencv_to_safe(jsobj_borderValue, borderValue, ArgInfo("borderValue", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::filter2D(src, ddepth, kernel, anchor, delta, borderType, borderValue));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_flip(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    Napi::Value* jsobj_flipCode = NULL;
    int flipCode=0;
    GMat retval;

    const char* keywords[] = { "src", "flipCode", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:flip", (char**)keywords, &jsobj_src, &jsobj_flipCode) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_flipCode, flipCode, ArgInfo("flipCode", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::flip(src, flipCode));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_gaussianBlur(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    Napi::Value* jsobj_ksize = NULL;
    Size ksize;
    Napi::Value* jsobj_sigmaX = NULL;
    double sigmaX=0;
    Napi::Value* jsobj_sigmaY = NULL;
    double sigmaY=0;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_DEFAULT;
    Napi::Value* jsobj_borderValue = NULL;
    Scalar borderValue=Scalar(0);
    GMat retval;

    const char* keywords[] = { "src", "ksize", "sigmaX", "sigmaY", "borderType", "borderValue", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOO:gaussianBlur", (char**)keywords, &jsobj_src, &jsobj_ksize, &jsobj_sigmaX, &jsobj_sigmaY, &jsobj_borderType, &jsobj_borderValue) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_ksize, ksize, ArgInfo("ksize", 0)) &&
        jsopencv_to_safe(jsobj_sigmaX, sigmaX, ArgInfo("sigmaX", 0)) &&
        jsopencv_to_safe(jsobj_sigmaY, sigmaY, ArgInfo("sigmaY", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)) &&
        jsopencv_to_safe(jsobj_borderValue, borderValue, ArgInfo("borderValue", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::gaussianBlur(src, ksize, sigmaX, sigmaY, borderType, borderValue));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_goodFeaturesToTrack(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_image = NULL;
    cv::GMat image;
    Napi::Value* jsobj_maxCorners = NULL;
    int maxCorners=0;
    Napi::Value* jsobj_qualityLevel = NULL;
    double qualityLevel=0;
    Napi::Value* jsobj_minDistance = NULL;
    double minDistance=0;
    Napi::Value* jsobj_mask = NULL;
    Mat mask;
    Napi::Value* jsobj_blockSize = NULL;
    int blockSize=3;
    Napi::Value* jsobj_useHarrisDetector = NULL;
    bool useHarrisDetector=false;
    Napi::Value* jsobj_k = NULL;
    double k=0.04;
    GArray<Point2f> retval;

    const char* keywords[] = { "image", "maxCorners", "qualityLevel", "minDistance", "mask", "blockSize", "useHarrisDetector", "k", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOOO:goodFeaturesToTrack", (char**)keywords, &jsobj_image, &jsobj_maxCorners, &jsobj_qualityLevel, &jsobj_minDistance, &jsobj_mask, &jsobj_blockSize, &jsobj_useHarrisDetector, &jsobj_k) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_maxCorners, maxCorners, ArgInfo("maxCorners", 0)) &&
        jsopencv_to_safe(jsobj_qualityLevel, qualityLevel, ArgInfo("qualityLevel", 0)) &&
        jsopencv_to_safe(jsobj_minDistance, minDistance, ArgInfo("minDistance", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)) &&
        jsopencv_to_safe(jsobj_blockSize, blockSize, ArgInfo("blockSize", 0)) &&
        jsopencv_to_safe(jsobj_useHarrisDetector, useHarrisDetector, ArgInfo("useHarrisDetector", 0)) &&
        jsopencv_to_safe(jsobj_k, k, ArgInfo("k", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::goodFeaturesToTrack(image, maxCorners, qualityLevel, minDistance, mask, blockSize, useHarrisDetector, k));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_inRange(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    Napi::Value* jsobj_threshLow = NULL;
    cv::GScalar threshLow;
    Napi::Value* jsobj_threshUp = NULL;
    cv::GScalar threshUp;
    GMat retval;

    const char* keywords[] = { "src", "threshLow", "threshUp", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:inRange", (char**)keywords, &jsobj_src, &jsobj_threshLow, &jsobj_threshUp) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_threshLow, threshLow, ArgInfo("threshLow", 0)) &&
        jsopencv_to_safe(jsobj_threshUp, threshUp, ArgInfo("threshUp", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::inRange(src, threshLow, threshUp));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_infer(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    jsPrepareArgumentConversionErrorsStorage(3);

    {
    Napi::Value* jsobj_name = NULL;
    String name;
    Napi::Value* jsobj_inputs = NULL;
    cv::GInferInputs inputs;
    cv::GInferOutputs retval;

    const char* keywords[] = { "name", "inputs", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:infer", (char**)keywords, &jsobj_name, &jsobj_inputs) &&
        jsopencv_to_safe(jsobj_name, name, ArgInfo("name", 0)) &&
        jsopencv_to_safe(jsobj_inputs, inputs, ArgInfo("inputs", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::infer(name, inputs));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_name = NULL;
    std::string name;
    Napi::Value* jsobj_roi = NULL;
    GOpaque_Rect roi;
    Napi::Value* jsobj_inputs = NULL;
    cv::GInferInputs inputs;
    GInferOutputs retval;

    const char* keywords[] = { "name", "roi", "inputs", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:infer", (char**)keywords, &jsobj_name, &jsobj_roi, &jsobj_inputs) &&
        jsopencv_to_safe(jsobj_name, name, ArgInfo("name", 0)) &&
        jsopencv_to_safe(jsobj_roi, roi, ArgInfo("roi", 0)) &&
        jsopencv_to_safe(jsobj_inputs, inputs, ArgInfo("inputs", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::infer(name, roi, inputs));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_name = NULL;
    std::string name;
    Napi::Value* jsobj_rois = NULL;
    GArray_Rect rois;
    Napi::Value* jsobj_inputs = NULL;
    cv::GInferInputs inputs;
    GInferListOutputs retval;

    const char* keywords[] = { "name", "rois", "inputs", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:infer", (char**)keywords, &jsobj_name, &jsobj_rois, &jsobj_inputs) &&
        jsopencv_to_safe(jsobj_name, name, ArgInfo("name", 0)) &&
        jsopencv_to_safe(jsobj_rois, rois, ArgInfo("rois", 0)) &&
        jsopencv_to_safe(jsobj_inputs, inputs, ArgInfo("inputs", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::infer(name, rois, inputs));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "infer");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_infer2(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_name = NULL;
    std::string name;
    Napi::Value* jsobj_in = NULL;
    cv::GMat in;
    Napi::Value* jsobj_inputs = NULL;
    cv::GInferListInputs inputs;
    GInferListOutputs retval;

    const char* keywords[] = { "name", "in_", "inputs", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:infer2", (char**)keywords, &jsobj_name, &jsobj_in, &jsobj_inputs) &&
        jsopencv_to_safe(jsobj_name, name, ArgInfo("name", 0)) &&
        jsopencv_to_safe(jsobj_in, in, ArgInfo("in", 0)) &&
        jsopencv_to_safe(jsobj_inputs, inputs, ArgInfo("inputs", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::infer2(name, in, inputs));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_integral(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    Napi::Value* jsobj_sdepth = NULL;
    int sdepth=-1;
    Napi::Value* jsobj_sqdepth = NULL;
    int sqdepth=-1;
    std::tuple<GMat, GMat> retval;

    const char* keywords[] = { "src", "sdepth", "sqdepth", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OO:integral", (char**)keywords, &jsobj_src, &jsobj_sdepth, &jsobj_sqdepth) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_sdepth, sdepth, ArgInfo("sdepth", 0)) &&
        jsopencv_to_safe(jsobj_sqdepth, sqdepth, ArgInfo("sqdepth", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::integral(src, sdepth, sqdepth));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_kmeans(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    jsPrepareArgumentConversionErrorsStorage(4);

    {
    Napi::Value* jsobj_data = NULL;
    cv::GMat data;
    Napi::Value* jsobj_K = NULL;
    int K=0;
    Napi::Value* jsobj_bestLabels = NULL;
    cv::GMat bestLabels;
    Napi::Value* jsobj_criteria = NULL;
    TermCriteria criteria;
    Napi::Value* jsobj_attempts = NULL;
    int attempts=0;
    Napi::Value* jsobj_flags = NULL;
    KmeansFlags flags=static_cast<KmeansFlags>(0);
    std::tuple<GOpaque<double>,GMat,GMat> retval;

    const char* keywords[] = { "data", "K", "bestLabels", "criteria", "attempts", "flags", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOO:kmeans", (char**)keywords, &jsobj_data, &jsobj_K, &jsobj_bestLabels, &jsobj_criteria, &jsobj_attempts, &jsobj_flags) &&
        jsopencv_to_safe(jsobj_data, data, ArgInfo("data", 0)) &&
        jsopencv_to_safe(jsobj_K, K, ArgInfo("K", 0)) &&
        jsopencv_to_safe(jsobj_bestLabels, bestLabels, ArgInfo("bestLabels", 0)) &&
        jsopencv_to_safe(jsobj_criteria, criteria, ArgInfo("criteria", 0)) &&
        jsopencv_to_safe(jsobj_attempts, attempts, ArgInfo("attempts", 0)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::kmeans(data, K, bestLabels, criteria, attempts, flags));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_data = NULL;
    cv::GMat data;
    Napi::Value* jsobj_K = NULL;
    int K=0;
    Napi::Value* jsobj_criteria = NULL;
    TermCriteria criteria;
    Napi::Value* jsobj_attempts = NULL;
    int attempts=0;
    Napi::Value* jsobj_flags = NULL;
    KmeansFlags flags=static_cast<KmeansFlags>(0);
    std::tuple<GOpaque<double>,GMat,GMat> retval;

    const char* keywords[] = { "data", "K", "criteria", "attempts", "flags", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOO:kmeans", (char**)keywords, &jsobj_data, &jsobj_K, &jsobj_criteria, &jsobj_attempts, &jsobj_flags) &&
        jsopencv_to_safe(jsobj_data, data, ArgInfo("data", 0)) &&
        jsopencv_to_safe(jsobj_K, K, ArgInfo("K", 0)) &&
        jsopencv_to_safe(jsobj_criteria, criteria, ArgInfo("criteria", 0)) &&
        jsopencv_to_safe(jsobj_attempts, attempts, ArgInfo("attempts", 0)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::kmeans(data, K, criteria, attempts, flags));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_data = NULL;
    GArray_Point2f data;
    Napi::Value* jsobj_K = NULL;
    int K=0;
    Napi::Value* jsobj_bestLabels = NULL;
    GArray_int bestLabels;
    Napi::Value* jsobj_criteria = NULL;
    TermCriteria criteria;
    Napi::Value* jsobj_attempts = NULL;
    int attempts=0;
    Napi::Value* jsobj_flags = NULL;
    KmeansFlags flags=static_cast<KmeansFlags>(0);
    std::tuple<GOpaque<double>,GArray<int>,GArray<Point2f>> retval;

    const char* keywords[] = { "data", "K", "bestLabels", "criteria", "attempts", "flags", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOO:kmeans", (char**)keywords, &jsobj_data, &jsobj_K, &jsobj_bestLabels, &jsobj_criteria, &jsobj_attempts, &jsobj_flags) &&
        jsopencv_to_safe(jsobj_data, data, ArgInfo("data", 0)) &&
        jsopencv_to_safe(jsobj_K, K, ArgInfo("K", 0)) &&
        jsopencv_to_safe(jsobj_bestLabels, bestLabels, ArgInfo("bestLabels", 0)) &&
        jsopencv_to_safe(jsobj_criteria, criteria, ArgInfo("criteria", 0)) &&
        jsopencv_to_safe(jsobj_attempts, attempts, ArgInfo("attempts", 0)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::kmeans(data, K, bestLabels, criteria, attempts, flags));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_data = NULL;
    GArray_Point3f data;
    Napi::Value* jsobj_K = NULL;
    int K=0;
    Napi::Value* jsobj_bestLabels = NULL;
    GArray_int bestLabels;
    Napi::Value* jsobj_criteria = NULL;
    TermCriteria criteria;
    Napi::Value* jsobj_attempts = NULL;
    int attempts=0;
    Napi::Value* jsobj_flags = NULL;
    KmeansFlags flags=static_cast<KmeansFlags>(0);
    std::tuple<GOpaque<double>,GArray<int>,GArray<Point3f>> retval;

    const char* keywords[] = { "data", "K", "bestLabels", "criteria", "attempts", "flags", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOO:kmeans", (char**)keywords, &jsobj_data, &jsobj_K, &jsobj_bestLabels, &jsobj_criteria, &jsobj_attempts, &jsobj_flags) &&
        jsopencv_to_safe(jsobj_data, data, ArgInfo("data", 0)) &&
        jsopencv_to_safe(jsobj_K, K, ArgInfo("K", 0)) &&
        jsopencv_to_safe(jsobj_bestLabels, bestLabels, ArgInfo("bestLabels", 0)) &&
        jsopencv_to_safe(jsobj_criteria, criteria, ArgInfo("criteria", 0)) &&
        jsopencv_to_safe(jsobj_attempts, attempts, ArgInfo("attempts", 0)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::kmeans(data, K, bestLabels, criteria, attempts, flags));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "kmeans");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_mask(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    Napi::Value* jsobj_mask = NULL;
    cv::GMat mask;
    GMat retval;

    const char* keywords[] = { "src", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:mask", (char**)keywords, &jsobj_src, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::mask(src, mask));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_max(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src1 = NULL;
    cv::GMat src1;
    Napi::Value* jsobj_src2 = NULL;
    cv::GMat src2;
    GMat retval;

    const char* keywords[] = { "src1", "src2", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:max", (char**)keywords, &jsobj_src1, &jsobj_src2) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::max(src1, src2));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_mean(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    GScalar retval;

    const char* keywords[] = { "src", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:mean", (char**)keywords, &jsobj_src) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::mean(src));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_medianBlur(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    Napi::Value* jsobj_ksize = NULL;
    int ksize=0;
    GMat retval;

    const char* keywords[] = { "src", "ksize", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:medianBlur", (char**)keywords, &jsobj_src, &jsobj_ksize) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_ksize, ksize, ArgInfo("ksize", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::medianBlur(src, ksize));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_merge3(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src1 = NULL;
    cv::GMat src1;
    Napi::Value* jsobj_src2 = NULL;
    cv::GMat src2;
    Napi::Value* jsobj_src3 = NULL;
    cv::GMat src3;
    GMat retval;

    const char* keywords[] = { "src1", "src2", "src3", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:merge3", (char**)keywords, &jsobj_src1, &jsobj_src2, &jsobj_src3) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_src3, src3, ArgInfo("src3", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::merge3(src1, src2, src3));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_merge4(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src1 = NULL;
    cv::GMat src1;
    Napi::Value* jsobj_src2 = NULL;
    cv::GMat src2;
    Napi::Value* jsobj_src3 = NULL;
    cv::GMat src3;
    Napi::Value* jsobj_src4 = NULL;
    cv::GMat src4;
    GMat retval;

    const char* keywords[] = { "src1", "src2", "src3", "src4", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO:merge4", (char**)keywords, &jsobj_src1, &jsobj_src2, &jsobj_src3, &jsobj_src4) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_src3, src3, ArgInfo("src3", 0)) &&
        jsopencv_to_safe(jsobj_src4, src4, ArgInfo("src4", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::merge4(src1, src2, src3, src4));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_min(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src1 = NULL;
    cv::GMat src1;
    Napi::Value* jsobj_src2 = NULL;
    cv::GMat src2;
    GMat retval;

    const char* keywords[] = { "src1", "src2", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:min", (char**)keywords, &jsobj_src1, &jsobj_src2) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::min(src1, src2));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_morphologyEx(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    Napi::Value* jsobj_op = NULL;
    MorphTypes op=static_cast<MorphTypes>(0);
    Napi::Value* jsobj_kernel = NULL;
    Mat kernel;
    Napi::Value* jsobj_anchor = NULL;
    Point anchor=Point(-1,-1);
    Napi::Value* jsobj_iterations = NULL;
    int iterations=1;
    Napi::Value* jsobj_borderType = NULL;
    BorderTypes borderType=BORDER_CONSTANT;
    Napi::Value* jsobj_borderValue = NULL;
    Scalar borderValue=morphologyDefaultBorderValue();
    GMat retval;

    const char* keywords[] = { "src", "op", "kernel", "anchor", "iterations", "borderType", "borderValue", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOOO:morphologyEx", (char**)keywords, &jsobj_src, &jsobj_op, &jsobj_kernel, &jsobj_anchor, &jsobj_iterations, &jsobj_borderType, &jsobj_borderValue) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_op, op, ArgInfo("op", 0)) &&
        jsopencv_to_safe(jsobj_kernel, kernel, ArgInfo("kernel", 0)) &&
        jsopencv_to_safe(jsobj_anchor, anchor, ArgInfo("anchor", 0)) &&
        jsopencv_to_safe(jsobj_iterations, iterations, ArgInfo("iterations", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)) &&
        jsopencv_to_safe(jsobj_borderValue, borderValue, ArgInfo("borderValue", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::morphologyEx(src, op, kernel, anchor, iterations, borderType, borderValue));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_mul(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src1 = NULL;
    cv::GMat src1;
    Napi::Value* jsobj_src2 = NULL;
    cv::GMat src2;
    Napi::Value* jsobj_scale = NULL;
    double scale=1.0;
    Napi::Value* jsobj_ddepth = NULL;
    int ddepth=-1;
    GMat retval;

    const char* keywords[] = { "src1", "src2", "scale", "ddepth", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:mul", (char**)keywords, &jsobj_src1, &jsobj_src2, &jsobj_scale, &jsobj_ddepth) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_scale, scale, ArgInfo("scale", 0)) &&
        jsopencv_to_safe(jsobj_ddepth, ddepth, ArgInfo("ddepth", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::mul(src1, src2, scale, ddepth));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_mulC(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    jsPrepareArgumentConversionErrorsStorage(3);

    {
    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    Napi::Value* jsobj_multiplier = NULL;
    double multiplier=0;
    Napi::Value* jsobj_ddepth = NULL;
    int ddepth=-1;
    GMat retval;

    const char* keywords[] = { "src", "multiplier", "ddepth", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:mulC", (char**)keywords, &jsobj_src, &jsobj_multiplier, &jsobj_ddepth) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_multiplier, multiplier, ArgInfo("multiplier", 0)) &&
        jsopencv_to_safe(jsobj_ddepth, ddepth, ArgInfo("ddepth", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::mulC(src, multiplier, ddepth));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    Napi::Value* jsobj_multiplier = NULL;
    cv::GScalar multiplier;
    Napi::Value* jsobj_ddepth = NULL;
    int ddepth=-1;
    GMat retval;

    const char* keywords[] = { "src", "multiplier", "ddepth", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:mulC", (char**)keywords, &jsobj_src, &jsobj_multiplier, &jsobj_ddepth) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_multiplier, multiplier, ArgInfo("multiplier", 0)) &&
        jsopencv_to_safe(jsobj_ddepth, ddepth, ArgInfo("ddepth", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::mulC(src, multiplier, ddepth));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_multiplier = NULL;
    cv::GScalar multiplier;
    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    Napi::Value* jsobj_ddepth = NULL;
    int ddepth=-1;
    GMat retval;

    const char* keywords[] = { "multiplier", "src", "ddepth", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:mulC", (char**)keywords, &jsobj_multiplier, &jsobj_src, &jsobj_ddepth) &&
        jsopencv_to_safe(jsobj_multiplier, multiplier, ArgInfo("multiplier", 0)) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_ddepth, ddepth, ArgInfo("ddepth", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::mulC(multiplier, src, ddepth));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "mulC");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_normInf(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    GScalar retval;

    const char* keywords[] = { "src", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:normInf", (char**)keywords, &jsobj_src) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::normInf(src));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_normL1(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    GScalar retval;

    const char* keywords[] = { "src", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:normL1", (char**)keywords, &jsobj_src) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::normL1(src));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_normL2(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    GScalar retval;

    const char* keywords[] = { "src", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:normL2", (char**)keywords, &jsobj_src) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::normL2(src));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_normalize(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    Napi::Value* jsobj_alpha = NULL;
    double alpha=0;
    Napi::Value* jsobj_beta = NULL;
    double beta=0;
    Napi::Value* jsobj_norm_type = NULL;
    int norm_type=0;
    Napi::Value* jsobj_ddepth = NULL;
    int ddepth=-1;
    GMat retval;

    const char* keywords[] = { "src", "alpha", "beta", "norm_type", "ddepth", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|O:normalize", (char**)keywords, &jsobj_src, &jsobj_alpha, &jsobj_beta, &jsobj_norm_type, &jsobj_ddepth) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_alpha, alpha, ArgInfo("alpha", 0)) &&
        jsopencv_to_safe(jsobj_beta, beta, ArgInfo("beta", 0)) &&
        jsopencv_to_safe(jsobj_norm_type, norm_type, ArgInfo("norm_type", 0)) &&
        jsopencv_to_safe(jsobj_ddepth, ddepth, ArgInfo("ddepth", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::normalize(src, alpha, beta, norm_type, ddepth));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_parseSSD(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_in = NULL;
    cv::GMat in;
    Napi::Value* jsobj_inSz = NULL;
    GOpaque_Size inSz;
    Napi::Value* jsobj_confidenceThreshold = NULL;
    float confidenceThreshold=0.5f;
    Napi::Value* jsobj_filterLabel = NULL;
    int filterLabel=-1;
    std::tuple<GArray<Rect>, GArray<int>> retval;

    const char* keywords[] = { "in_", "inSz", "confidenceThreshold", "filterLabel", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:parseSSD", (char**)keywords, &jsobj_in, &jsobj_inSz, &jsobj_confidenceThreshold, &jsobj_filterLabel) &&
        jsopencv_to_safe(jsobj_in, in, ArgInfo("in", 0)) &&
        jsopencv_to_safe(jsobj_inSz, inSz, ArgInfo("inSz", 0)) &&
        jsopencv_to_safe(jsobj_confidenceThreshold, confidenceThreshold, ArgInfo("confidenceThreshold", 0)) &&
        jsopencv_to_safe(jsobj_filterLabel, filterLabel, ArgInfo("filterLabel", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::parseSSD(in, inSz, confidenceThreshold, filterLabel));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_in = NULL;
    cv::GMat in;
    Napi::Value* jsobj_inSz = NULL;
    GOpaque_Size inSz;
    Napi::Value* jsobj_confidenceThreshold = NULL;
    float confidenceThreshold=0.f;
    Napi::Value* jsobj_alignmentToSquare = NULL;
    bool alignmentToSquare=0;
    Napi::Value* jsobj_filterOutOfBounds = NULL;
    bool filterOutOfBounds=0;
    GArray<Rect> retval;

    const char* keywords[] = { "in_", "inSz", "confidenceThreshold", "alignmentToSquare", "filterOutOfBounds", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOO:parseSSD", (char**)keywords, &jsobj_in, &jsobj_inSz, &jsobj_confidenceThreshold, &jsobj_alignmentToSquare, &jsobj_filterOutOfBounds) &&
        jsopencv_to_safe(jsobj_in, in, ArgInfo("in", 0)) &&
        jsopencv_to_safe(jsobj_inSz, inSz, ArgInfo("inSz", 0)) &&
        jsopencv_to_safe(jsobj_confidenceThreshold, confidenceThreshold, ArgInfo("confidenceThreshold", 0)) &&
        jsopencv_to_safe(jsobj_alignmentToSquare, alignmentToSquare, ArgInfo("alignmentToSquare", 0)) &&
        jsopencv_to_safe(jsobj_filterOutOfBounds, filterOutOfBounds, ArgInfo("filterOutOfBounds", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::parseSSD(in, inSz, confidenceThreshold, alignmentToSquare, filterOutOfBounds));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "parseSSD");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_parseYolo(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_in = NULL;
    cv::GMat in;
    Napi::Value* jsobj_inSz = NULL;
    GOpaque_Size inSz;
    Napi::Value* jsobj_confidenceThreshold = NULL;
    float confidenceThreshold=0.5f;
    Napi::Value* jsobj_nmsThreshold = NULL;
    float nmsThreshold=0.5f;
    Napi::Value* jsobj_anchors = NULL;
    vector_float anchors=nn::parsers::GParseYolo::defaultAnchors();
    std::tuple<GArray<Rect>, GArray<int>> retval;

    const char* keywords[] = { "in_", "inSz", "confidenceThreshold", "nmsThreshold", "anchors", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOO:parseYolo", (char**)keywords, &jsobj_in, &jsobj_inSz, &jsobj_confidenceThreshold, &jsobj_nmsThreshold, &jsobj_anchors) &&
        jsopencv_to_safe(jsobj_in, in, ArgInfo("in", 0)) &&
        jsopencv_to_safe(jsobj_inSz, inSz, ArgInfo("inSz", 0)) &&
        jsopencv_to_safe(jsobj_confidenceThreshold, confidenceThreshold, ArgInfo("confidenceThreshold", 0)) &&
        jsopencv_to_safe(jsobj_nmsThreshold, nmsThreshold, ArgInfo("nmsThreshold", 0)) &&
        jsopencv_to_safe(jsobj_anchors, anchors, ArgInfo("anchors", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::parseYolo(in, inSz, confidenceThreshold, nmsThreshold, anchors));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_phase(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_x = NULL;
    cv::GMat x;
    Napi::Value* jsobj_y = NULL;
    cv::GMat y;
    Napi::Value* jsobj_angleInDegrees = NULL;
    bool angleInDegrees=false;
    GMat retval;

    const char* keywords[] = { "x", "y", "angleInDegrees", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:phase", (char**)keywords, &jsobj_x, &jsobj_y, &jsobj_angleInDegrees) &&
        jsopencv_to_safe(jsobj_x, x, ArgInfo("x", 0)) &&
        jsopencv_to_safe(jsobj_y, y, ArgInfo("y", 0)) &&
        jsopencv_to_safe(jsobj_angleInDegrees, angleInDegrees, ArgInfo("angleInDegrees", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::phase(x, y, angleInDegrees));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_polarToCart(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_magnitude = NULL;
    cv::GMat magnitude;
    Napi::Value* jsobj_angle = NULL;
    cv::GMat angle;
    Napi::Value* jsobj_angleInDegrees = NULL;
    bool angleInDegrees=false;
    std::tuple<GMat, GMat> retval;

    const char* keywords[] = { "magnitude", "angle", "angleInDegrees", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:polarToCart", (char**)keywords, &jsobj_magnitude, &jsobj_angle, &jsobj_angleInDegrees) &&
        jsopencv_to_safe(jsobj_magnitude, magnitude, ArgInfo("magnitude", 0)) &&
        jsopencv_to_safe(jsobj_angle, angle, ArgInfo("angle", 0)) &&
        jsopencv_to_safe(jsobj_angleInDegrees, angleInDegrees, ArgInfo("angleInDegrees", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::polarToCart(magnitude, angle, angleInDegrees));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_remap(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    Napi::Value* jsobj_map1 = NULL;
    Mat map1;
    Napi::Value* jsobj_map2 = NULL;
    Mat map2;
    Napi::Value* jsobj_interpolation = NULL;
    int interpolation=0;
    Napi::Value* jsobj_borderMode = NULL;
    int borderMode=BORDER_CONSTANT;
    Napi::Value* jsobj_borderValue = NULL;
    Scalar borderValue;
    GMat retval;

    const char* keywords[] = { "src", "map1", "map2", "interpolation", "borderMode", "borderValue", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OO:remap", (char**)keywords, &jsobj_src, &jsobj_map1, &jsobj_map2, &jsobj_interpolation, &jsobj_borderMode, &jsobj_borderValue) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_map1, map1, ArgInfo("map1", 0)) &&
        jsopencv_to_safe(jsobj_map2, map2, ArgInfo("map2", 0)) &&
        jsopencv_to_safe(jsobj_interpolation, interpolation, ArgInfo("interpolation", 0)) &&
        jsopencv_to_safe(jsobj_borderMode, borderMode, ArgInfo("borderMode", 0)) &&
        jsopencv_to_safe(jsobj_borderValue, borderValue, ArgInfo("borderValue", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::remap(src, map1, map2, interpolation, borderMode, borderValue));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_resize(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    Napi::Value* jsobj_dsize = NULL;
    Size dsize;
    Napi::Value* jsobj_fx = NULL;
    double fx=0;
    Napi::Value* jsobj_fy = NULL;
    double fy=0;
    Napi::Value* jsobj_interpolation = NULL;
    int interpolation=INTER_LINEAR;
    GMat retval;

    const char* keywords[] = { "src", "dsize", "fx", "fy", "interpolation", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOO:resize", (char**)keywords, &jsobj_src, &jsobj_dsize, &jsobj_fx, &jsobj_fy, &jsobj_interpolation) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dsize, dsize, ArgInfo("dsize", 0)) &&
        jsopencv_to_safe(jsobj_fx, fx, ArgInfo("fx", 0)) &&
        jsopencv_to_safe(jsobj_fy, fy, ArgInfo("fy", 0)) &&
        jsopencv_to_safe(jsobj_interpolation, interpolation, ArgInfo("interpolation", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::resize(src, dsize, fx, fy, interpolation));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_select(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src1 = NULL;
    cv::GMat src1;
    Napi::Value* jsobj_src2 = NULL;
    cv::GMat src2;
    Napi::Value* jsobj_mask = NULL;
    cv::GMat mask;
    GMat retval;

    const char* keywords[] = { "src1", "src2", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:select", (char**)keywords, &jsobj_src1, &jsobj_src2, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::select(src1, src2, mask));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_sepFilter(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    Napi::Value* jsobj_ddepth = NULL;
    int ddepth=0;
    Napi::Value* jsobj_kernelX = NULL;
    Mat kernelX;
    Napi::Value* jsobj_kernelY = NULL;
    Mat kernelY;
    Napi::Value* jsobj_anchor = NULL;
    Point anchor;
    Napi::Value* jsobj_delta = NULL;
    Scalar delta;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_DEFAULT;
    Napi::Value* jsobj_borderValue = NULL;
    Scalar borderValue=Scalar(0);
    GMat retval;

    const char* keywords[] = { "src", "ddepth", "kernelX", "kernelY", "anchor", "delta", "borderType", "borderValue", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOO|OO:sepFilter", (char**)keywords, &jsobj_src, &jsobj_ddepth, &jsobj_kernelX, &jsobj_kernelY, &jsobj_anchor, &jsobj_delta, &jsobj_borderType, &jsobj_borderValue) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_ddepth, ddepth, ArgInfo("ddepth", 0)) &&
        jsopencv_to_safe(jsobj_kernelX, kernelX, ArgInfo("kernelX", 0)) &&
        jsopencv_to_safe(jsobj_kernelY, kernelY, ArgInfo("kernelY", 0)) &&
        jsopencv_to_safe(jsobj_anchor, anchor, ArgInfo("anchor", 0)) &&
        jsopencv_to_safe(jsobj_delta, delta, ArgInfo("delta", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)) &&
        jsopencv_to_safe(jsobj_borderValue, borderValue, ArgInfo("borderValue", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::sepFilter(src, ddepth, kernelX, kernelY, anchor, delta, borderType, borderValue));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_split3(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    std::tuple<GMat, GMat, GMat> retval;

    const char* keywords[] = { "src", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:split3", (char**)keywords, &jsobj_src) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::split3(src));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_split4(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    std::tuple<GMat, GMat, GMat,GMat> retval;

    const char* keywords[] = { "src", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:split4", (char**)keywords, &jsobj_src) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::split4(src));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_sqrt(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    GMat retval;

    const char* keywords[] = { "src", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:sqrt", (char**)keywords, &jsobj_src) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::sqrt(src));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_sub(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src1 = NULL;
    cv::GMat src1;
    Napi::Value* jsobj_src2 = NULL;
    cv::GMat src2;
    Napi::Value* jsobj_ddepth = NULL;
    int ddepth=-1;
    GMat retval;

    const char* keywords[] = { "src1", "src2", "ddepth", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:sub", (char**)keywords, &jsobj_src1, &jsobj_src2, &jsobj_ddepth) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_ddepth, ddepth, ArgInfo("ddepth", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::sub(src1, src2, ddepth));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_subC(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    Napi::Value* jsobj_c = NULL;
    cv::GScalar c;
    Napi::Value* jsobj_ddepth = NULL;
    int ddepth=-1;
    GMat retval;

    const char* keywords[] = { "src", "c", "ddepth", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:subC", (char**)keywords, &jsobj_src, &jsobj_c, &jsobj_ddepth) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_c, c, ArgInfo("c", 0)) &&
        jsopencv_to_safe(jsobj_ddepth, ddepth, ArgInfo("ddepth", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::subC(src, c, ddepth));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_subRC(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_c = NULL;
    cv::GScalar c;
    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    Napi::Value* jsobj_ddepth = NULL;
    int ddepth=-1;
    GMat retval;

    const char* keywords[] = { "c", "src", "ddepth", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:subRC", (char**)keywords, &jsobj_c, &jsobj_src, &jsobj_ddepth) &&
        jsopencv_to_safe(jsobj_c, c, ArgInfo("c", 0)) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_ddepth, ddepth, ArgInfo("ddepth", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::subRC(c, src, ddepth));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_sum(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    GScalar retval;

    const char* keywords[] = { "src", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:sum", (char**)keywords, &jsobj_src) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::sum(src));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_threshold(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    Napi::Value* jsobj_thresh = NULL;
    cv::GScalar thresh;
    Napi::Value* jsobj_maxval = NULL;
    cv::GScalar maxval;
    Napi::Value* jsobj_type = NULL;
    int type=0;
    GMat retval;

    const char* keywords[] = { "src", "thresh", "maxval", "type", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO:threshold", (char**)keywords, &jsobj_src, &jsobj_thresh, &jsobj_maxval, &jsobj_type) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_thresh, thresh, ArgInfo("thresh", 0)) &&
        jsopencv_to_safe(jsobj_maxval, maxval, ArgInfo("maxval", 0)) &&
        jsopencv_to_safe(jsobj_type, type, ArgInfo("type", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::threshold(src, thresh, maxval, type));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    Napi::Value* jsobj_maxval = NULL;
    cv::GScalar maxval;
    Napi::Value* jsobj_type = NULL;
    int type=0;
    std::tuple<GMat, GScalar> retval;

    const char* keywords[] = { "src", "maxval", "type", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:threshold", (char**)keywords, &jsobj_src, &jsobj_maxval, &jsobj_type) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_maxval, maxval, ArgInfo("maxval", 0)) &&
        jsopencv_to_safe(jsobj_type, type, ArgInfo("type", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::threshold(src, maxval, type));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "threshold");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_transpose(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    GMat retval;

    const char* keywords[] = { "src", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:transpose", (char**)keywords, &jsobj_src) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::transpose(src));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_warpAffine(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    Napi::Value* jsobj_M = NULL;
    Mat M;
    Napi::Value* jsobj_dsize = NULL;
    Size dsize;
    Napi::Value* jsobj_flags = NULL;
    int flags=cv::INTER_LINEAR;
    Napi::Value* jsobj_borderMode = NULL;
    int borderMode=cv::BORDER_CONSTANT;
    Napi::Value* jsobj_borderValue = NULL;
    Scalar borderValue;
    GMat retval;

    const char* keywords[] = { "src", "M", "dsize", "flags", "borderMode", "borderValue", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOO:warpAffine", (char**)keywords, &jsobj_src, &jsobj_M, &jsobj_dsize, &jsobj_flags, &jsobj_borderMode, &jsobj_borderValue) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_M, M, ArgInfo("M", 0)) &&
        jsopencv_to_safe(jsobj_dsize, dsize, ArgInfo("dsize", 0)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_borderMode, borderMode, ArgInfo("borderMode", 0)) &&
        jsopencv_to_safe(jsobj_borderValue, borderValue, ArgInfo("borderValue", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::warpAffine(src, M, dsize, flags, borderMode, borderValue));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_warpPerspective(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    Napi::Value* jsobj_M = NULL;
    Mat M;
    Napi::Value* jsobj_dsize = NULL;
    Size dsize;
    Napi::Value* jsobj_flags = NULL;
    int flags=cv::INTER_LINEAR;
    Napi::Value* jsobj_borderMode = NULL;
    int borderMode=cv::BORDER_CONSTANT;
    Napi::Value* jsobj_borderValue = NULL;
    Scalar borderValue;
    GMat retval;

    const char* keywords[] = { "src", "M", "dsize", "flags", "borderMode", "borderValue", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOO:warpPerspective", (char**)keywords, &jsobj_src, &jsobj_M, &jsobj_dsize, &jsobj_flags, &jsobj_borderMode, &jsobj_borderValue) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_M, M, ArgInfo("M", 0)) &&
        jsopencv_to_safe(jsobj_dsize, dsize, ArgInfo("dsize", 0)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_borderMode, borderMode, ArgInfo("borderMode", 0)) &&
        jsopencv_to_safe(jsobj_borderValue, borderValue, ArgInfo("borderValue", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::warpPerspective(src, M, dsize, flags, borderMode, borderValue));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_core_cpu_kernels(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi::core::cpu;

    cv::GKernelPackage retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::core::cpu::kernels());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_core_fluid_kernels(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi::core::fluid;

    cv::GKernelPackage retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::core::fluid::kernels());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_core_ocl_kernels(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi::core::ocl;

    cv::GKernelPackage retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::core::ocl::kernels());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_ie_params(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi::ie;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_tag = NULL;
    std::string tag;
    Napi::Value* jsobj_model = NULL;
    std::string model;
    Napi::Value* jsobj_weights = NULL;
    std::string weights;
    Napi::Value* jsobj_device = NULL;
    std::string device;
    PyParams retval;

    const char* keywords[] = { "tag", "model", "weights", "device", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO:params", (char**)keywords, &jsobj_tag, &jsobj_model, &jsobj_weights, &jsobj_device) &&
        jsopencv_to_safe(jsobj_tag, tag, ArgInfo("tag", 0)) &&
        jsopencv_to_safe(jsobj_model, model, ArgInfo("model", 0)) &&
        jsopencv_to_safe(jsobj_weights, weights, ArgInfo("weights", 0)) &&
        jsopencv_to_safe(jsobj_device, device, ArgInfo("device", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::ie::params(tag, model, weights, device));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_tag = NULL;
    std::string tag;
    Napi::Value* jsobj_model = NULL;
    std::string model;
    Napi::Value* jsobj_device = NULL;
    std::string device;
    PyParams retval;

    const char* keywords[] = { "tag", "model", "device", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:params", (char**)keywords, &jsobj_tag, &jsobj_model, &jsobj_device) &&
        jsopencv_to_safe(jsobj_tag, tag, ArgInfo("tag", 0)) &&
        jsopencv_to_safe(jsobj_model, model, ArgInfo("model", 0)) &&
        jsopencv_to_safe(jsobj_device, device, ArgInfo("device", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::ie::params(tag, model, device));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "params");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_onnx_params(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi::onnx;

    Napi::Value* jsobj_tag = NULL;
    std::string tag;
    Napi::Value* jsobj_model_path = NULL;
    std::string model_path;
    PyParams retval;

    const char* keywords[] = { "tag", "model_path", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:params", (char**)keywords, &jsobj_tag, &jsobj_model_path) &&
        jsopencv_to_safe(jsobj_tag, tag, ArgInfo("tag", 0)) &&
        jsopencv_to_safe(jsobj_model_path, model_path, ArgInfo("model_path", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::onnx::params(tag, model_path));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_render_ocv_kernels(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi::render::ocv;

    cv::GKernelPackage retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::render::ocv::kernels());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_streaming_desync(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi::streaming;

    Napi::Value* jsobj_g = NULL;
    cv::GMat g;
    cv::GMat retval;

    const char* keywords[] = { "g", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:desync", (char**)keywords, &jsobj_g) &&
        jsopencv_to_safe(jsobj_g, g, ArgInfo("g", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::streaming::desync(g));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_streaming_seqNo(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi::streaming;

    Napi::Value* jsobj_arg1 = NULL;
    cv::GMat arg1;
    cv::GOpaque<int64_t> retval;

    const char* keywords[] = { "arg1", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:seqNo", (char**)keywords, &jsobj_arg1) &&
        jsopencv_to_safe(jsobj_arg1, arg1, ArgInfo("arg1", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::streaming::seqNo(arg1));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_streaming_seq_id(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi::streaming;

    Napi::Value* jsobj_arg1 = NULL;
    cv::GMat arg1;
    cv::GOpaque<int64_t> retval;

    const char* keywords[] = { "arg1", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:seq_id", (char**)keywords, &jsobj_arg1) &&
        jsopencv_to_safe(jsobj_arg1, arg1, ArgInfo("arg1", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::streaming::seq_id(arg1));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_streaming_size(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi::streaming;

    jsPrepareArgumentConversionErrorsStorage(3);

    {
    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    GOpaque<Size> retval;

    const char* keywords[] = { "src", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:size", (char**)keywords, &jsobj_src) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::streaming::size(src));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_r = NULL;
    GOpaque_Rect r;
    GOpaque<Size> retval;

    const char* keywords[] = { "r", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:size", (char**)keywords, &jsobj_r) &&
        jsopencv_to_safe(jsobj_r, r, ArgInfo("r", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::streaming::size(r));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    cv::GFrame src;
    GOpaque<Size> retval;

    const char* keywords[] = { "src", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:size", (char**)keywords, &jsobj_src) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::streaming::size(src));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "size");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_streaming_timestamp(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi::streaming;

    Napi::Value* jsobj_arg1 = NULL;
    cv::GMat arg1;
    cv::GOpaque<int64_t> retval;

    const char* keywords[] = { "arg1", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:timestamp", (char**)keywords, &jsobj_arg1) &&
        jsopencv_to_safe(jsobj_arg1, arg1, ArgInfo("arg1", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::streaming::timestamp(arg1));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_wip_get_streaming_source(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi::wip;

    Napi::Value* jsobj_pipeline = NULL;
    Ptr<GStreamerPipeline> pipeline;
    Napi::Value* jsobj_appsinkName = NULL;
    std::string appsinkName;
    Napi::Value* jsobj_outputType = NULL;
    GStreamerSource_OutputType outputType=GStreamerSource::OutputType::MAT;
    cv::Ptr<IStreamSource> retval;

    const char* keywords[] = { "pipeline", "appsinkName", "outputType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:get_streaming_source", (char**)keywords, &jsobj_pipeline, &jsobj_appsinkName, &jsobj_outputType) &&
        jsopencv_to_safe(jsobj_pipeline, pipeline, ArgInfo("pipeline", 0)) &&
        jsopencv_to_safe(jsobj_appsinkName, appsinkName, ArgInfo("appsinkName", 0)) &&
        jsopencv_to_safe(jsobj_outputType, outputType, ArgInfo("outputType", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::wip::get_streaming_source(pipeline, appsinkName, outputType));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_wip_make_capture_src(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi::wip;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_path = NULL;
    std::string path;
    cv::Ptr<IStreamSource> retval;

    const char* keywords[] = { "path", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:make_capture_src", (char**)keywords, &jsobj_path) &&
        jsopencv_to_safe(jsobj_path, path, ArgInfo("path", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::wip::make_capture_src(path));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_id = NULL;
    int id=0;
    cv::Ptr<IStreamSource> retval;

    const char* keywords[] = { "id", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:make_capture_src", (char**)keywords, &jsobj_id) &&
        jsopencv_to_safe(jsobj_id, id, ArgInfo("id", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::wip::make_capture_src(id));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "make_capture_src");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_wip_make_gst_src(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi::wip;

    Napi::Value* jsobj_pipeline = NULL;
    std::string pipeline;
    Napi::Value* jsobj_outputType = NULL;
    GStreamerSource_OutputType outputType=GStreamerSource::OutputType::MAT;
    cv::Ptr<IStreamSource> retval;

    const char* keywords[] = { "pipeline", "outputType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:make_gst_src", (char**)keywords, &jsobj_pipeline, &jsobj_outputType) &&
        jsopencv_to_safe(jsobj_pipeline, pipeline, ArgInfo("pipeline", 0)) &&
        jsopencv_to_safe(jsobj_outputType, outputType, ArgInfo("outputType", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::wip::make_gst_src(pipeline, outputType));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_wip_draw_render(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi::wip::draw;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_bgr = NULL;
    Mat bgr;
    Napi::Value* jsobj_prims = NULL;
    Prims prims;
    Napi::Value* jsobj_args = NULL;
    GCompileArgs args={};

    const char* keywords[] = { "bgr", "prims", "args", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:render", (char**)keywords, &jsobj_bgr, &jsobj_prims, &jsobj_args) &&
        jsopencv_to_safe(jsobj_bgr, bgr, ArgInfo("bgr", 0)) &&
        jsopencv_to_safe(jsobj_prims, prims, ArgInfo("prims", 0)) &&
        jsopencv_to_safe(jsobj_args, args, ArgInfo("args", 0)))
    {
        ERRWRAP2_NAPI(info, cv::gapi::wip::draw::render(bgr, prims, std::move(args)));
        return info.Env().Null();;
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_y_plane = NULL;
    Mat y_plane;
    Napi::Value* jsobj_uv_plane = NULL;
    Mat uv_plane;
    Napi::Value* jsobj_prims = NULL;
    Prims prims;
    Napi::Value* jsobj_args = NULL;
    GCompileArgs args={};

    const char* keywords[] = { "y_plane", "uv_plane", "prims", "args", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:render", (char**)keywords, &jsobj_y_plane, &jsobj_uv_plane, &jsobj_prims, &jsobj_args) &&
        jsopencv_to_safe(jsobj_y_plane, y_plane, ArgInfo("y_plane", 0)) &&
        jsopencv_to_safe(jsobj_uv_plane, uv_plane, ArgInfo("uv_plane", 0)) &&
        jsopencv_to_safe(jsobj_prims, prims, ArgInfo("prims", 0)) &&
        jsopencv_to_safe(jsobj_args, args, ArgInfo("args", 0)))
    {
        ERRWRAP2_NAPI(info, cv::gapi::wip::draw::render(y_plane, uv_plane, prims, std::move(args)));
        return info.Env().Null();;
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "render");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_wip_draw_render3ch(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi::wip::draw;

    Napi::Value* jsobj_src = NULL;
    cv::GMat src;
    Napi::Value* jsobj_prims = NULL;
    GArray_Prim prims;
    GMat retval;

    const char* keywords[] = { "src", "prims", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:render3ch", (char**)keywords, &jsobj_src, &jsobj_prims) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_prims, prims, ArgInfo("prims", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::wip::draw::render3ch(src, prims));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_gapi_wip_draw_renderNV12(const Napi::CallbackInfo &info)
{
    using namespace cv::gapi::wip::draw;

    Napi::Value* jsobj_y = NULL;
    cv::GMat y;
    Napi::Value* jsobj_uv = NULL;
    cv::GMat uv;
    Napi::Value* jsobj_prims = NULL;
    GArray_Prim prims;
    GMat2 retval;

    const char* keywords[] = { "y", "uv", "prims", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:renderNV12", (char**)keywords, &jsobj_y, &jsobj_uv, &jsobj_prims) &&
        jsopencv_to_safe(jsobj_y, y, ArgInfo("y", 0)) &&
        jsopencv_to_safe(jsobj_uv, uv, ArgInfo("uv", 0)) &&
        jsopencv_to_safe(jsobj_prims, prims, ArgInfo("prims", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::gapi::wip::draw::renderNV12(y, uv, prims));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_img_hash_AverageHash_create(const Napi::CallbackInfo &info)
{
    using namespace cv::img_hash;

    Ptr<AverageHash> retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::img_hash::AverageHash::create());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_img_hash_BlockMeanHash_create(const Napi::CallbackInfo &info)
{
    using namespace cv::img_hash;

    Napi::Value* jsobj_mode = NULL;
    int mode=BLOCK_MEAN_HASH_MODE_0;
    Ptr<BlockMeanHash> retval;

    const char* keywords[] = { "mode", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|O:BlockMeanHash_create", (char**)keywords, &jsobj_mode) &&
        jsopencv_to_safe(jsobj_mode, mode, ArgInfo("mode", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::img_hash::BlockMeanHash::create(mode));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_img_hash_ColorMomentHash_create(const Napi::CallbackInfo &info)
{
    using namespace cv::img_hash;

    Ptr<ColorMomentHash> retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::img_hash::ColorMomentHash::create());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_img_hash_MarrHildrethHash_create(const Napi::CallbackInfo &info)
{
    using namespace cv::img_hash;

    Napi::Value* jsobj_alpha = NULL;
    float alpha=2.0f;
    Napi::Value* jsobj_scale = NULL;
    float scale=1.0f;
    Ptr<MarrHildrethHash> retval;

    const char* keywords[] = { "alpha", "scale", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OO:MarrHildrethHash_create", (char**)keywords, &jsobj_alpha, &jsobj_scale) &&
        jsopencv_to_safe(jsobj_alpha, alpha, ArgInfo("alpha", 0)) &&
        jsopencv_to_safe(jsobj_scale, scale, ArgInfo("scale", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::img_hash::MarrHildrethHash::create(alpha, scale));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_img_hash_PHash_create(const Napi::CallbackInfo &info)
{
    using namespace cv::img_hash;

    Ptr<PHash> retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::img_hash::PHash::create());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_img_hash_RadialVarianceHash_create(const Napi::CallbackInfo &info)
{
    using namespace cv::img_hash;

    Napi::Value* jsobj_sigma = NULL;
    double sigma=1;
    Napi::Value* jsobj_numOfAngleLine = NULL;
    int numOfAngleLine=180;
    Ptr<RadialVarianceHash> retval;

    const char* keywords[] = { "sigma", "numOfAngleLine", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OO:RadialVarianceHash_create", (char**)keywords, &jsobj_sigma, &jsobj_numOfAngleLine) &&
        jsopencv_to_safe(jsobj_sigma, sigma, ArgInfo("sigma", 0)) &&
        jsopencv_to_safe(jsobj_numOfAngleLine, numOfAngleLine, ArgInfo("numOfAngleLine", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::img_hash::RadialVarianceHash::create(sigma, numOfAngleLine));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_img_hash_averageHash(const Napi::CallbackInfo &info)
{
    using namespace cv::img_hash;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_inputArr = NULL;
    Mat inputArr;
    Napi::Value* jsobj_outputArr = NULL;
    Mat outputArr;

    const char* keywords[] = { "inputArr", "outputArr", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:averageHash", (char**)keywords, &jsobj_inputArr, &jsobj_outputArr) &&
        jsopencv_to_safe(jsobj_inputArr, inputArr, ArgInfo("inputArr", 0)) &&
        jsopencv_to_safe(jsobj_outputArr, outputArr, ArgInfo("outputArr", 1)))
    {
        ERRWRAP2_NAPI(info, cv::img_hash::averageHash(inputArr, outputArr));
        return jsopencv_from(info, outputArr);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_inputArr = NULL;
    UMat inputArr;
    Napi::Value* jsobj_outputArr = NULL;
    UMat outputArr;

    const char* keywords[] = { "inputArr", "outputArr", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:averageHash", (char**)keywords, &jsobj_inputArr, &jsobj_outputArr) &&
        jsopencv_to_safe(jsobj_inputArr, inputArr, ArgInfo("inputArr", 0)) &&
        jsopencv_to_safe(jsobj_outputArr, outputArr, ArgInfo("outputArr", 1)))
    {
        ERRWRAP2_NAPI(info, cv::img_hash::averageHash(inputArr, outputArr));
        return jsopencv_from(info, outputArr);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "averageHash");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_img_hash_blockMeanHash(const Napi::CallbackInfo &info)
{
    using namespace cv::img_hash;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_inputArr = NULL;
    Mat inputArr;
    Napi::Value* jsobj_outputArr = NULL;
    Mat outputArr;
    Napi::Value* jsobj_mode = NULL;
    int mode=BLOCK_MEAN_HASH_MODE_0;

    const char* keywords[] = { "inputArr", "outputArr", "mode", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OO:blockMeanHash", (char**)keywords, &jsobj_inputArr, &jsobj_outputArr, &jsobj_mode) &&
        jsopencv_to_safe(jsobj_inputArr, inputArr, ArgInfo("inputArr", 0)) &&
        jsopencv_to_safe(jsobj_outputArr, outputArr, ArgInfo("outputArr", 1)) &&
        jsopencv_to_safe(jsobj_mode, mode, ArgInfo("mode", 0)))
    {
        ERRWRAP2_NAPI(info, cv::img_hash::blockMeanHash(inputArr, outputArr, mode));
        return jsopencv_from(info, outputArr);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_inputArr = NULL;
    UMat inputArr;
    Napi::Value* jsobj_outputArr = NULL;
    UMat outputArr;
    Napi::Value* jsobj_mode = NULL;
    int mode=BLOCK_MEAN_HASH_MODE_0;

    const char* keywords[] = { "inputArr", "outputArr", "mode", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OO:blockMeanHash", (char**)keywords, &jsobj_inputArr, &jsobj_outputArr, &jsobj_mode) &&
        jsopencv_to_safe(jsobj_inputArr, inputArr, ArgInfo("inputArr", 0)) &&
        jsopencv_to_safe(jsobj_outputArr, outputArr, ArgInfo("outputArr", 1)) &&
        jsopencv_to_safe(jsobj_mode, mode, ArgInfo("mode", 0)))
    {
        ERRWRAP2_NAPI(info, cv::img_hash::blockMeanHash(inputArr, outputArr, mode));
        return jsopencv_from(info, outputArr);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "blockMeanHash");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_img_hash_colorMomentHash(const Napi::CallbackInfo &info)
{
    using namespace cv::img_hash;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_inputArr = NULL;
    Mat inputArr;
    Napi::Value* jsobj_outputArr = NULL;
    Mat outputArr;

    const char* keywords[] = { "inputArr", "outputArr", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:colorMomentHash", (char**)keywords, &jsobj_inputArr, &jsobj_outputArr) &&
        jsopencv_to_safe(jsobj_inputArr, inputArr, ArgInfo("inputArr", 0)) &&
        jsopencv_to_safe(jsobj_outputArr, outputArr, ArgInfo("outputArr", 1)))
    {
        ERRWRAP2_NAPI(info, cv::img_hash::colorMomentHash(inputArr, outputArr));
        return jsopencv_from(info, outputArr);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_inputArr = NULL;
    UMat inputArr;
    Napi::Value* jsobj_outputArr = NULL;
    UMat outputArr;

    const char* keywords[] = { "inputArr", "outputArr", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:colorMomentHash", (char**)keywords, &jsobj_inputArr, &jsobj_outputArr) &&
        jsopencv_to_safe(jsobj_inputArr, inputArr, ArgInfo("inputArr", 0)) &&
        jsopencv_to_safe(jsobj_outputArr, outputArr, ArgInfo("outputArr", 1)))
    {
        ERRWRAP2_NAPI(info, cv::img_hash::colorMomentHash(inputArr, outputArr));
        return jsopencv_from(info, outputArr);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "colorMomentHash");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_img_hash_marrHildrethHash(const Napi::CallbackInfo &info)
{
    using namespace cv::img_hash;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_inputArr = NULL;
    Mat inputArr;
    Napi::Value* jsobj_outputArr = NULL;
    Mat outputArr;
    Napi::Value* jsobj_alpha = NULL;
    float alpha=2.0f;
    Napi::Value* jsobj_scale = NULL;
    float scale=1.0f;

    const char* keywords[] = { "inputArr", "outputArr", "alpha", "scale", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOO:marrHildrethHash", (char**)keywords, &jsobj_inputArr, &jsobj_outputArr, &jsobj_alpha, &jsobj_scale) &&
        jsopencv_to_safe(jsobj_inputArr, inputArr, ArgInfo("inputArr", 0)) &&
        jsopencv_to_safe(jsobj_outputArr, outputArr, ArgInfo("outputArr", 1)) &&
        jsopencv_to_safe(jsobj_alpha, alpha, ArgInfo("alpha", 0)) &&
        jsopencv_to_safe(jsobj_scale, scale, ArgInfo("scale", 0)))
    {
        ERRWRAP2_NAPI(info, cv::img_hash::marrHildrethHash(inputArr, outputArr, alpha, scale));
        return jsopencv_from(info, outputArr);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_inputArr = NULL;
    UMat inputArr;
    Napi::Value* jsobj_outputArr = NULL;
    UMat outputArr;
    Napi::Value* jsobj_alpha = NULL;
    float alpha=2.0f;
    Napi::Value* jsobj_scale = NULL;
    float scale=1.0f;

    const char* keywords[] = { "inputArr", "outputArr", "alpha", "scale", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOO:marrHildrethHash", (char**)keywords, &jsobj_inputArr, &jsobj_outputArr, &jsobj_alpha, &jsobj_scale) &&
        jsopencv_to_safe(jsobj_inputArr, inputArr, ArgInfo("inputArr", 0)) &&
        jsopencv_to_safe(jsobj_outputArr, outputArr, ArgInfo("outputArr", 1)) &&
        jsopencv_to_safe(jsobj_alpha, alpha, ArgInfo("alpha", 0)) &&
        jsopencv_to_safe(jsobj_scale, scale, ArgInfo("scale", 0)))
    {
        ERRWRAP2_NAPI(info, cv::img_hash::marrHildrethHash(inputArr, outputArr, alpha, scale));
        return jsopencv_from(info, outputArr);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "marrHildrethHash");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_img_hash_pHash(const Napi::CallbackInfo &info)
{
    using namespace cv::img_hash;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_inputArr = NULL;
    Mat inputArr;
    Napi::Value* jsobj_outputArr = NULL;
    Mat outputArr;

    const char* keywords[] = { "inputArr", "outputArr", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:pHash", (char**)keywords, &jsobj_inputArr, &jsobj_outputArr) &&
        jsopencv_to_safe(jsobj_inputArr, inputArr, ArgInfo("inputArr", 0)) &&
        jsopencv_to_safe(jsobj_outputArr, outputArr, ArgInfo("outputArr", 1)))
    {
        ERRWRAP2_NAPI(info, cv::img_hash::pHash(inputArr, outputArr));
        return jsopencv_from(info, outputArr);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_inputArr = NULL;
    UMat inputArr;
    Napi::Value* jsobj_outputArr = NULL;
    UMat outputArr;

    const char* keywords[] = { "inputArr", "outputArr", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:pHash", (char**)keywords, &jsobj_inputArr, &jsobj_outputArr) &&
        jsopencv_to_safe(jsobj_inputArr, inputArr, ArgInfo("inputArr", 0)) &&
        jsopencv_to_safe(jsobj_outputArr, outputArr, ArgInfo("outputArr", 1)))
    {
        ERRWRAP2_NAPI(info, cv::img_hash::pHash(inputArr, outputArr));
        return jsopencv_from(info, outputArr);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "pHash");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_img_hash_radialVarianceHash(const Napi::CallbackInfo &info)
{
    using namespace cv::img_hash;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_inputArr = NULL;
    Mat inputArr;
    Napi::Value* jsobj_outputArr = NULL;
    Mat outputArr;
    Napi::Value* jsobj_sigma = NULL;
    double sigma=1;
    Napi::Value* jsobj_numOfAngleLine = NULL;
    int numOfAngleLine=180;

    const char* keywords[] = { "inputArr", "outputArr", "sigma", "numOfAngleLine", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOO:radialVarianceHash", (char**)keywords, &jsobj_inputArr, &jsobj_outputArr, &jsobj_sigma, &jsobj_numOfAngleLine) &&
        jsopencv_to_safe(jsobj_inputArr, inputArr, ArgInfo("inputArr", 0)) &&
        jsopencv_to_safe(jsobj_outputArr, outputArr, ArgInfo("outputArr", 1)) &&
        jsopencv_to_safe(jsobj_sigma, sigma, ArgInfo("sigma", 0)) &&
        jsopencv_to_safe(jsobj_numOfAngleLine, numOfAngleLine, ArgInfo("numOfAngleLine", 0)))
    {
        ERRWRAP2_NAPI(info, cv::img_hash::radialVarianceHash(inputArr, outputArr, sigma, numOfAngleLine));
        return jsopencv_from(info, outputArr);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_inputArr = NULL;
    UMat inputArr;
    Napi::Value* jsobj_outputArr = NULL;
    UMat outputArr;
    Napi::Value* jsobj_sigma = NULL;
    double sigma=1;
    Napi::Value* jsobj_numOfAngleLine = NULL;
    int numOfAngleLine=180;

    const char* keywords[] = { "inputArr", "outputArr", "sigma", "numOfAngleLine", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOO:radialVarianceHash", (char**)keywords, &jsobj_inputArr, &jsobj_outputArr, &jsobj_sigma, &jsobj_numOfAngleLine) &&
        jsopencv_to_safe(jsobj_inputArr, inputArr, ArgInfo("inputArr", 0)) &&
        jsopencv_to_safe(jsobj_outputArr, outputArr, ArgInfo("outputArr", 1)) &&
        jsopencv_to_safe(jsobj_sigma, sigma, ArgInfo("sigma", 0)) &&
        jsopencv_to_safe(jsobj_numOfAngleLine, numOfAngleLine, ArgInfo("numOfAngleLine", 0)))
    {
        ERRWRAP2_NAPI(info, cv::img_hash::radialVarianceHash(inputArr, outputArr, sigma, numOfAngleLine));
        return jsopencv_from(info, outputArr);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "radialVarianceHash");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_intensity_transform_BIMEF(const Napi::CallbackInfo &info)
{
    using namespace cv::intensity_transform;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_input = NULL;
    Mat input;
    Napi::Value* jsobj_output = NULL;
    Mat output;
    Napi::Value* jsobj_mu = NULL;
    float mu=0.5f;
    Napi::Value* jsobj_a = NULL;
    float a=-0.3293f;
    Napi::Value* jsobj_b = NULL;
    float b=1.1258f;

    const char* keywords[] = { "input", "output", "mu", "a", "b", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOOO:BIMEF", (char**)keywords, &jsobj_input, &jsobj_output, &jsobj_mu, &jsobj_a, &jsobj_b) &&
        jsopencv_to_safe(jsobj_input, input, ArgInfo("input", 0)) &&
        jsopencv_to_safe(jsobj_output, output, ArgInfo("output", 1)) &&
        jsopencv_to_safe(jsobj_mu, mu, ArgInfo("mu", 0)) &&
        jsopencv_to_safe(jsobj_a, a, ArgInfo("a", 0)) &&
        jsopencv_to_safe(jsobj_b, b, ArgInfo("b", 0)))
    {
        ERRWRAP2_NAPI(info, cv::intensity_transform::BIMEF(input, output, mu, a, b));
        return jsopencv_from(info, output);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_input = NULL;
    UMat input;
    Napi::Value* jsobj_output = NULL;
    UMat output;
    Napi::Value* jsobj_mu = NULL;
    float mu=0.5f;
    Napi::Value* jsobj_a = NULL;
    float a=-0.3293f;
    Napi::Value* jsobj_b = NULL;
    float b=1.1258f;

    const char* keywords[] = { "input", "output", "mu", "a", "b", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOOO:BIMEF", (char**)keywords, &jsobj_input, &jsobj_output, &jsobj_mu, &jsobj_a, &jsobj_b) &&
        jsopencv_to_safe(jsobj_input, input, ArgInfo("input", 0)) &&
        jsopencv_to_safe(jsobj_output, output, ArgInfo("output", 1)) &&
        jsopencv_to_safe(jsobj_mu, mu, ArgInfo("mu", 0)) &&
        jsopencv_to_safe(jsobj_a, a, ArgInfo("a", 0)) &&
        jsopencv_to_safe(jsobj_b, b, ArgInfo("b", 0)))
    {
        ERRWRAP2_NAPI(info, cv::intensity_transform::BIMEF(input, output, mu, a, b));
        return jsopencv_from(info, output);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "BIMEF");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_intensity_transform_BIMEF2(const Napi::CallbackInfo &info)
{
    using namespace cv::intensity_transform;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_input = NULL;
    Mat input;
    Napi::Value* jsobj_output = NULL;
    Mat output;
    Napi::Value* jsobj_k = NULL;
    float k=0.f;
    Napi::Value* jsobj_mu = NULL;
    float mu=0.f;
    Napi::Value* jsobj_a = NULL;
    float a=0.f;
    Napi::Value* jsobj_b = NULL;
    float b=0.f;

    const char* keywords[] = { "input", "k", "mu", "a", "b", "output", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOO|O:BIMEF2", (char**)keywords, &jsobj_input, &jsobj_k, &jsobj_mu, &jsobj_a, &jsobj_b, &jsobj_output) &&
        jsopencv_to_safe(jsobj_input, input, ArgInfo("input", 0)) &&
        jsopencv_to_safe(jsobj_output, output, ArgInfo("output", 1)) &&
        jsopencv_to_safe(jsobj_k, k, ArgInfo("k", 0)) &&
        jsopencv_to_safe(jsobj_mu, mu, ArgInfo("mu", 0)) &&
        jsopencv_to_safe(jsobj_a, a, ArgInfo("a", 0)) &&
        jsopencv_to_safe(jsobj_b, b, ArgInfo("b", 0)))
    {
        ERRWRAP2_NAPI(info, cv::intensity_transform::BIMEF(input, output, k, mu, a, b));
        return jsopencv_from(info, output);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_input = NULL;
    UMat input;
    Napi::Value* jsobj_output = NULL;
    UMat output;
    Napi::Value* jsobj_k = NULL;
    float k=0.f;
    Napi::Value* jsobj_mu = NULL;
    float mu=0.f;
    Napi::Value* jsobj_a = NULL;
    float a=0.f;
    Napi::Value* jsobj_b = NULL;
    float b=0.f;

    const char* keywords[] = { "input", "k", "mu", "a", "b", "output", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOO|O:BIMEF2", (char**)keywords, &jsobj_input, &jsobj_k, &jsobj_mu, &jsobj_a, &jsobj_b, &jsobj_output) &&
        jsopencv_to_safe(jsobj_input, input, ArgInfo("input", 0)) &&
        jsopencv_to_safe(jsobj_output, output, ArgInfo("output", 1)) &&
        jsopencv_to_safe(jsobj_k, k, ArgInfo("k", 0)) &&
        jsopencv_to_safe(jsobj_mu, mu, ArgInfo("mu", 0)) &&
        jsopencv_to_safe(jsobj_a, a, ArgInfo("a", 0)) &&
        jsopencv_to_safe(jsobj_b, b, ArgInfo("b", 0)))
    {
        ERRWRAP2_NAPI(info, cv::intensity_transform::BIMEF(input, output, k, mu, a, b));
        return jsopencv_from(info, output);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "BIMEF2");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_intensity_transform_autoscaling(const Napi::CallbackInfo &info)
{
    using namespace cv::intensity_transform;

    Napi::Value* jsobj_input = NULL;
    Mat input;
    Napi::Value* jsobj_output = NULL;
    Mat output;

    const char* keywords[] = { "input", "output", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:autoscaling", (char**)keywords, &jsobj_input, &jsobj_output) &&
        jsopencv_to_safe(jsobj_input, input, ArgInfo("input", 0)) &&
        jsopencv_to_safe(jsobj_output, output, ArgInfo("output", 0)))
    {
        ERRWRAP2_NAPI(info, cv::intensity_transform::autoscaling(input, output));
        return info.Env().Null();;
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_intensity_transform_contrastStretching(const Napi::CallbackInfo &info)
{
    using namespace cv::intensity_transform;

    Napi::Value* jsobj_input = NULL;
    Mat input;
    Napi::Value* jsobj_output = NULL;
    Mat output;
    Napi::Value* jsobj_r1 = NULL;
    int r1=0;
    Napi::Value* jsobj_s1 = NULL;
    int s1=0;
    Napi::Value* jsobj_r2 = NULL;
    int r2=0;
    Napi::Value* jsobj_s2 = NULL;
    int s2=0;

    const char* keywords[] = { "input", "output", "r1", "s1", "r2", "s2", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOO:contrastStretching", (char**)keywords, &jsobj_input, &jsobj_output, &jsobj_r1, &jsobj_s1, &jsobj_r2, &jsobj_s2) &&
        jsopencv_to_safe(jsobj_input, input, ArgInfo("input", 0)) &&
        jsopencv_to_safe(jsobj_output, output, ArgInfo("output", 0)) &&
        jsopencv_to_safe(jsobj_r1, r1, ArgInfo("r1", 0)) &&
        jsopencv_to_safe(jsobj_s1, s1, ArgInfo("s1", 0)) &&
        jsopencv_to_safe(jsobj_r2, r2, ArgInfo("r2", 0)) &&
        jsopencv_to_safe(jsobj_s2, s2, ArgInfo("s2", 0)))
    {
        ERRWRAP2_NAPI(info, cv::intensity_transform::contrastStretching(input, output, r1, s1, r2, s2));
        return info.Env().Null();;
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_intensity_transform_gammaCorrection(const Napi::CallbackInfo &info)
{
    using namespace cv::intensity_transform;

    Napi::Value* jsobj_input = NULL;
    Mat input;
    Napi::Value* jsobj_output = NULL;
    Mat output;
    Napi::Value* jsobj_gamma = NULL;
    float gamma=0.f;

    const char* keywords[] = { "input", "output", "gamma", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:gammaCorrection", (char**)keywords, &jsobj_input, &jsobj_output, &jsobj_gamma) &&
        jsopencv_to_safe(jsobj_input, input, ArgInfo("input", 0)) &&
        jsopencv_to_safe(jsobj_output, output, ArgInfo("output", 0)) &&
        jsopencv_to_safe(jsobj_gamma, gamma, ArgInfo("gamma", 0)))
    {
        ERRWRAP2_NAPI(info, cv::intensity_transform::gammaCorrection(input, output, gamma));
        return info.Env().Null();;
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_intensity_transform_logTransform(const Napi::CallbackInfo &info)
{
    using namespace cv::intensity_transform;

    Napi::Value* jsobj_input = NULL;
    Mat input;
    Napi::Value* jsobj_output = NULL;
    Mat output;

    const char* keywords[] = { "input", "output", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:logTransform", (char**)keywords, &jsobj_input, &jsobj_output) &&
        jsopencv_to_safe(jsobj_input, input, ArgInfo("input", 0)) &&
        jsopencv_to_safe(jsobj_output, output, ArgInfo("output", 0)))
    {
        ERRWRAP2_NAPI(info, cv::intensity_transform::logTransform(input, output));
        return info.Env().Null();;
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ipp_getIppVersion(const Napi::CallbackInfo &info)
{
    using namespace cv::ipp;

    String retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::ipp::getIppVersion());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ipp_setUseIPP(const Napi::CallbackInfo &info)
{
    using namespace cv::ipp;

    Napi::Value* jsobj_flag = NULL;
    bool flag=0;

    const char* keywords[] = { "flag", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:setUseIPP", (char**)keywords, &jsobj_flag) &&
        jsopencv_to_safe(jsobj_flag, flag, ArgInfo("flag", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ipp::setUseIPP(flag));
        return info.Env().Null();;
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ipp_setUseIPP_NotExact(const Napi::CallbackInfo &info)
{
    using namespace cv::ipp;

    Napi::Value* jsobj_flag = NULL;
    bool flag=0;

    const char* keywords[] = { "flag", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:setUseIPP_NotExact", (char**)keywords, &jsobj_flag) &&
        jsopencv_to_safe(jsobj_flag, flag, ArgInfo("flag", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ipp::setUseIPP_NotExact(flag));
        return info.Env().Null();;
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ipp_useIPP(const Napi::CallbackInfo &info)
{
    using namespace cv::ipp;

    bool retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::ipp::useIPP());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ipp_useIPP_NotExact(const Napi::CallbackInfo &info)
{
    using namespace cv::ipp;

    bool retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::ipp::useIPP_NotExact());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_legacy_MultiTracker_create(const Napi::CallbackInfo &info)
{
    using namespace cv::legacy;

    Ptr<MultiTracker> retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::legacy::MultiTracker::create());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_legacy_TrackerBoosting_create(const Napi::CallbackInfo &info)
{
    using namespace cv::legacy;

    Ptr<legacy::TrackerBoosting> retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::legacy::TrackerBoosting::create());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_legacy_TrackerCSRT_create(const Napi::CallbackInfo &info)
{
    using namespace cv::legacy;

    Ptr<legacy::TrackerCSRT> retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::legacy::TrackerCSRT::create());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_legacy_TrackerKCF_create(const Napi::CallbackInfo &info)
{
    using namespace cv::legacy;

    Ptr<legacy::TrackerKCF> retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::legacy::TrackerKCF::create());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_legacy_TrackerMIL_create(const Napi::CallbackInfo &info)
{
    using namespace cv::legacy;

    Ptr<legacy::TrackerMIL> retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::legacy::TrackerMIL::create());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_legacy_TrackerMOSSE_create(const Napi::CallbackInfo &info)
{
    using namespace cv::legacy;

    Ptr<legacy::TrackerMOSSE> retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::legacy::TrackerMOSSE::create());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_legacy_TrackerMedianFlow_create(const Napi::CallbackInfo &info)
{
    using namespace cv::legacy;

    Ptr<legacy::TrackerMedianFlow> retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::legacy::TrackerMedianFlow::create());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_legacy_TrackerTLD_create(const Napi::CallbackInfo &info)
{
    using namespace cv::legacy;

    Ptr<legacy::TrackerTLD> retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::legacy::TrackerTLD::create());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_legacy_upgradeTrackingAPI(const Napi::CallbackInfo &info)
{
    using namespace cv::legacy;

    Napi::Value* jsobj_legacy_tracker = NULL;
    Ptr<legacy::Tracker> legacy_tracker;
    Ptr<cv::Tracker> retval;

    const char* keywords[] = { "legacy_tracker", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:upgradeTrackingAPI", (char**)keywords, &jsobj_legacy_tracker) &&
        jsopencv_to_safe(jsobj_legacy_tracker, legacy_tracker, ArgInfo("legacy_tracker", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::legacy::upgradeTrackingAPI(legacy_tracker));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_mcc_CCheckerDetector_create(const Napi::CallbackInfo &info)
{
    using namespace cv::mcc;

    Ptr<CCheckerDetector> retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::mcc::CCheckerDetector::create());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_mcc_CCheckerDraw_create(const Napi::CallbackInfo &info)
{
    using namespace cv::mcc;

    Napi::Value* jsobj_pChecker = NULL;
    Ptr<CChecker> pChecker;
    Napi::Value* jsobj_color = NULL;
    Scalar color=CV_RGB(0, 250, 0);
    Napi::Value* jsobj_thickness = NULL;
    int thickness=2;
    Ptr<CCheckerDraw> retval;

    const char* keywords[] = { "pChecker", "color", "thickness", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OO:CCheckerDraw_create", (char**)keywords, &jsobj_pChecker, &jsobj_color, &jsobj_thickness) &&
        jsopencv_to_safe(jsobj_pChecker, pChecker, ArgInfo("pChecker", 0)) &&
        jsopencv_to_safe(jsobj_color, color, ArgInfo("color", 0)) &&
        jsopencv_to_safe(jsobj_thickness, thickness, ArgInfo("thickness", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::mcc::CCheckerDraw::create(pChecker, color, thickness));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_mcc_CChecker_create(const Napi::CallbackInfo &info)
{
    using namespace cv::mcc;

    Ptr<CChecker> retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::mcc::CChecker::create());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_mcc_DetectorParameters_create(const Napi::CallbackInfo &info)
{
    using namespace cv::mcc;

    Ptr<DetectorParameters> retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::mcc::DetectorParameters::create());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ml_ANN_MLP_create(const Napi::CallbackInfo &info)
{
    using namespace cv::ml;

    Ptr<ANN_MLP> retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::ml::ANN_MLP::create());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ml_ANN_MLP_load(const Napi::CallbackInfo &info)
{
    using namespace cv::ml;

    Napi::Value* jsobj_filepath = NULL;
    String filepath;
    Ptr<ANN_MLP> retval;

    const char* keywords[] = { "filepath", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:ANN_MLP_load", (char**)keywords, &jsobj_filepath) &&
        jsopencv_to_safe(jsobj_filepath, filepath, ArgInfo("filepath", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ml::ANN_MLP::load(filepath));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ml_Boost_create(const Napi::CallbackInfo &info)
{
    using namespace cv::ml;

    Ptr<Boost> retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::ml::Boost::create());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ml_Boost_load(const Napi::CallbackInfo &info)
{
    using namespace cv::ml;

    Napi::Value* jsobj_filepath = NULL;
    String filepath;
    Napi::Value* jsobj_nodeName = NULL;
    String nodeName;
    Ptr<Boost> retval;

    const char* keywords[] = { "filepath", "nodeName", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:Boost_load", (char**)keywords, &jsobj_filepath, &jsobj_nodeName) &&
        jsopencv_to_safe(jsobj_filepath, filepath, ArgInfo("filepath", 0)) &&
        jsopencv_to_safe(jsobj_nodeName, nodeName, ArgInfo("nodeName", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ml::Boost::load(filepath, nodeName));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ml_DTrees_create(const Napi::CallbackInfo &info)
{
    using namespace cv::ml;

    Ptr<DTrees> retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::ml::DTrees::create());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ml_DTrees_load(const Napi::CallbackInfo &info)
{
    using namespace cv::ml;

    Napi::Value* jsobj_filepath = NULL;
    String filepath;
    Napi::Value* jsobj_nodeName = NULL;
    String nodeName;
    Ptr<DTrees> retval;

    const char* keywords[] = { "filepath", "nodeName", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:DTrees_load", (char**)keywords, &jsobj_filepath, &jsobj_nodeName) &&
        jsopencv_to_safe(jsobj_filepath, filepath, ArgInfo("filepath", 0)) &&
        jsopencv_to_safe(jsobj_nodeName, nodeName, ArgInfo("nodeName", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ml::DTrees::load(filepath, nodeName));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ml_EM_create(const Napi::CallbackInfo &info)
{
    using namespace cv::ml;

    Ptr<EM> retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::ml::EM::create());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ml_EM_load(const Napi::CallbackInfo &info)
{
    using namespace cv::ml;

    Napi::Value* jsobj_filepath = NULL;
    String filepath;
    Napi::Value* jsobj_nodeName = NULL;
    String nodeName;
    Ptr<EM> retval;

    const char* keywords[] = { "filepath", "nodeName", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:EM_load", (char**)keywords, &jsobj_filepath, &jsobj_nodeName) &&
        jsopencv_to_safe(jsobj_filepath, filepath, ArgInfo("filepath", 0)) &&
        jsopencv_to_safe(jsobj_nodeName, nodeName, ArgInfo("nodeName", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ml::EM::load(filepath, nodeName));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ml_KNearest_create(const Napi::CallbackInfo &info)
{
    using namespace cv::ml;

    Ptr<KNearest> retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::ml::KNearest::create());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ml_KNearest_load(const Napi::CallbackInfo &info)
{
    using namespace cv::ml;

    Napi::Value* jsobj_filepath = NULL;
    String filepath;
    Ptr<KNearest> retval;

    const char* keywords[] = { "filepath", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:KNearest_load", (char**)keywords, &jsobj_filepath) &&
        jsopencv_to_safe(jsobj_filepath, filepath, ArgInfo("filepath", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ml::KNearest::load(filepath));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ml_LogisticRegression_create(const Napi::CallbackInfo &info)
{
    using namespace cv::ml;

    Ptr<LogisticRegression> retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::ml::LogisticRegression::create());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ml_LogisticRegression_load(const Napi::CallbackInfo &info)
{
    using namespace cv::ml;

    Napi::Value* jsobj_filepath = NULL;
    String filepath;
    Napi::Value* jsobj_nodeName = NULL;
    String nodeName;
    Ptr<LogisticRegression> retval;

    const char* keywords[] = { "filepath", "nodeName", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:LogisticRegression_load", (char**)keywords, &jsobj_filepath, &jsobj_nodeName) &&
        jsopencv_to_safe(jsobj_filepath, filepath, ArgInfo("filepath", 0)) &&
        jsopencv_to_safe(jsobj_nodeName, nodeName, ArgInfo("nodeName", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ml::LogisticRegression::load(filepath, nodeName));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ml_NormalBayesClassifier_create(const Napi::CallbackInfo &info)
{
    using namespace cv::ml;

    Ptr<NormalBayesClassifier> retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::ml::NormalBayesClassifier::create());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ml_NormalBayesClassifier_load(const Napi::CallbackInfo &info)
{
    using namespace cv::ml;

    Napi::Value* jsobj_filepath = NULL;
    String filepath;
    Napi::Value* jsobj_nodeName = NULL;
    String nodeName;
    Ptr<NormalBayesClassifier> retval;

    const char* keywords[] = { "filepath", "nodeName", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:NormalBayesClassifier_load", (char**)keywords, &jsobj_filepath, &jsobj_nodeName) &&
        jsopencv_to_safe(jsobj_filepath, filepath, ArgInfo("filepath", 0)) &&
        jsopencv_to_safe(jsobj_nodeName, nodeName, ArgInfo("nodeName", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ml::NormalBayesClassifier::load(filepath, nodeName));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ml_ParamGrid_create(const Napi::CallbackInfo &info)
{
    using namespace cv::ml;

    Napi::Value* jsobj_minVal = NULL;
    double minVal=0.;
    Napi::Value* jsobj_maxVal = NULL;
    double maxVal=0.;
    Napi::Value* jsobj_logstep = NULL;
    double logstep=1.;
    Ptr<ParamGrid> retval;

    const char* keywords[] = { "minVal", "maxVal", "logstep", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OOO:ParamGrid_create", (char**)keywords, &jsobj_minVal, &jsobj_maxVal, &jsobj_logstep) &&
        jsopencv_to_safe(jsobj_minVal, minVal, ArgInfo("minVal", 0)) &&
        jsopencv_to_safe(jsobj_maxVal, maxVal, ArgInfo("maxVal", 0)) &&
        jsopencv_to_safe(jsobj_logstep, logstep, ArgInfo("logstep", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ml::ParamGrid::create(minVal, maxVal, logstep));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ml_RTrees_create(const Napi::CallbackInfo &info)
{
    using namespace cv::ml;

    Ptr<RTrees> retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::ml::RTrees::create());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ml_RTrees_load(const Napi::CallbackInfo &info)
{
    using namespace cv::ml;

    Napi::Value* jsobj_filepath = NULL;
    String filepath;
    Napi::Value* jsobj_nodeName = NULL;
    String nodeName;
    Ptr<RTrees> retval;

    const char* keywords[] = { "filepath", "nodeName", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:RTrees_load", (char**)keywords, &jsobj_filepath, &jsobj_nodeName) &&
        jsopencv_to_safe(jsobj_filepath, filepath, ArgInfo("filepath", 0)) &&
        jsopencv_to_safe(jsobj_nodeName, nodeName, ArgInfo("nodeName", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ml::RTrees::load(filepath, nodeName));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ml_SVMSGD_create(const Napi::CallbackInfo &info)
{
    using namespace cv::ml;

    Ptr<SVMSGD> retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::ml::SVMSGD::create());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ml_SVMSGD_load(const Napi::CallbackInfo &info)
{
    using namespace cv::ml;

    Napi::Value* jsobj_filepath = NULL;
    String filepath;
    Napi::Value* jsobj_nodeName = NULL;
    String nodeName;
    Ptr<SVMSGD> retval;

    const char* keywords[] = { "filepath", "nodeName", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:SVMSGD_load", (char**)keywords, &jsobj_filepath, &jsobj_nodeName) &&
        jsopencv_to_safe(jsobj_filepath, filepath, ArgInfo("filepath", 0)) &&
        jsopencv_to_safe(jsobj_nodeName, nodeName, ArgInfo("nodeName", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ml::SVMSGD::load(filepath, nodeName));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ml_SVM_create(const Napi::CallbackInfo &info)
{
    using namespace cv::ml;

    Ptr<SVM> retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::ml::SVM::create());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ml_SVM_getDefaultGridPtr(const Napi::CallbackInfo &info)
{
    using namespace cv::ml;

    Napi::Value* jsobj_param_id = NULL;
    int param_id=0;
    Ptr<ParamGrid> retval;

    const char* keywords[] = { "param_id", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:SVM_getDefaultGridPtr", (char**)keywords, &jsobj_param_id) &&
        jsopencv_to_safe(jsobj_param_id, param_id, ArgInfo("param_id", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ml::SVM::getDefaultGridPtr(param_id));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ml_SVM_load(const Napi::CallbackInfo &info)
{
    using namespace cv::ml;

    Napi::Value* jsobj_filepath = NULL;
    String filepath;
    Ptr<SVM> retval;

    const char* keywords[] = { "filepath", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:SVM_load", (char**)keywords, &jsobj_filepath) &&
        jsopencv_to_safe(jsobj_filepath, filepath, ArgInfo("filepath", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ml::SVM::load(filepath));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ml_TrainData_create(const Napi::CallbackInfo &info)
{
    using namespace cv::ml;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_samples = NULL;
    Mat samples;
    Napi::Value* jsobj_layout = NULL;
    int layout=0;
    Napi::Value* jsobj_responses = NULL;
    Mat responses;
    Napi::Value* jsobj_varIdx = NULL;
    Mat varIdx;
    Napi::Value* jsobj_sampleIdx = NULL;
    Mat sampleIdx;
    Napi::Value* jsobj_sampleWeights = NULL;
    Mat sampleWeights;
    Napi::Value* jsobj_varType = NULL;
    Mat varType;
    Ptr<TrainData> retval;

    const char* keywords[] = { "samples", "layout", "responses", "varIdx", "sampleIdx", "sampleWeights", "varType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOOO:TrainData_create", (char**)keywords, &jsobj_samples, &jsobj_layout, &jsobj_responses, &jsobj_varIdx, &jsobj_sampleIdx, &jsobj_sampleWeights, &jsobj_varType) &&
        jsopencv_to_safe(jsobj_samples, samples, ArgInfo("samples", 0)) &&
        jsopencv_to_safe(jsobj_layout, layout, ArgInfo("layout", 0)) &&
        jsopencv_to_safe(jsobj_responses, responses, ArgInfo("responses", 0)) &&
        jsopencv_to_safe(jsobj_varIdx, varIdx, ArgInfo("varIdx", 0)) &&
        jsopencv_to_safe(jsobj_sampleIdx, sampleIdx, ArgInfo("sampleIdx", 0)) &&
        jsopencv_to_safe(jsobj_sampleWeights, sampleWeights, ArgInfo("sampleWeights", 0)) &&
        jsopencv_to_safe(jsobj_varType, varType, ArgInfo("varType", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ml::TrainData::create(samples, layout, responses, varIdx, sampleIdx, sampleWeights, varType));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_samples = NULL;
    UMat samples;
    Napi::Value* jsobj_layout = NULL;
    int layout=0;
    Napi::Value* jsobj_responses = NULL;
    UMat responses;
    Napi::Value* jsobj_varIdx = NULL;
    UMat varIdx;
    Napi::Value* jsobj_sampleIdx = NULL;
    UMat sampleIdx;
    Napi::Value* jsobj_sampleWeights = NULL;
    UMat sampleWeights;
    Napi::Value* jsobj_varType = NULL;
    UMat varType;
    Ptr<TrainData> retval;

    const char* keywords[] = { "samples", "layout", "responses", "varIdx", "sampleIdx", "sampleWeights", "varType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOOO:TrainData_create", (char**)keywords, &jsobj_samples, &jsobj_layout, &jsobj_responses, &jsobj_varIdx, &jsobj_sampleIdx, &jsobj_sampleWeights, &jsobj_varType) &&
        jsopencv_to_safe(jsobj_samples, samples, ArgInfo("samples", 0)) &&
        jsopencv_to_safe(jsobj_layout, layout, ArgInfo("layout", 0)) &&
        jsopencv_to_safe(jsobj_responses, responses, ArgInfo("responses", 0)) &&
        jsopencv_to_safe(jsobj_varIdx, varIdx, ArgInfo("varIdx", 0)) &&
        jsopencv_to_safe(jsobj_sampleIdx, sampleIdx, ArgInfo("sampleIdx", 0)) &&
        jsopencv_to_safe(jsobj_sampleWeights, sampleWeights, ArgInfo("sampleWeights", 0)) &&
        jsopencv_to_safe(jsobj_varType, varType, ArgInfo("varType", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ml::TrainData::create(samples, layout, responses, varIdx, sampleIdx, sampleWeights, varType));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "TrainData_create");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ml_TrainData_getSubMatrix(const Napi::CallbackInfo &info)
{
    using namespace cv::ml;

    Napi::Value* jsobj_matrix = NULL;
    Mat matrix;
    Napi::Value* jsobj_idx = NULL;
    Mat idx;
    Napi::Value* jsobj_layout = NULL;
    int layout=0;
    Mat retval;

    const char* keywords[] = { "matrix", "idx", "layout", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:TrainData_getSubMatrix", (char**)keywords, &jsobj_matrix, &jsobj_idx, &jsobj_layout) &&
        jsopencv_to_safe(jsobj_matrix, matrix, ArgInfo("matrix", 0)) &&
        jsopencv_to_safe(jsobj_idx, idx, ArgInfo("idx", 0)) &&
        jsopencv_to_safe(jsobj_layout, layout, ArgInfo("layout", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ml::TrainData::getSubMatrix(matrix, idx, layout));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ml_TrainData_getSubVector(const Napi::CallbackInfo &info)
{
    using namespace cv::ml;

    Napi::Value* jsobj_vec = NULL;
    Mat vec;
    Napi::Value* jsobj_idx = NULL;
    Mat idx;
    Mat retval;

    const char* keywords[] = { "vec", "idx", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:TrainData_getSubVector", (char**)keywords, &jsobj_vec, &jsobj_idx) &&
        jsopencv_to_safe(jsobj_vec, vec, ArgInfo("vec", 0)) &&
        jsopencv_to_safe(jsobj_idx, idx, ArgInfo("idx", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ml::TrainData::getSubVector(vec, idx));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ocl_Device_getDefault(const Napi::CallbackInfo &info)
{
    using namespace cv::ocl;

    Device retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::ocl::Device::getDefault());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ocl_finish(const Napi::CallbackInfo &info)
{
    using namespace cv::ocl;


    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, cv::ocl::finish());
        return info.Env().Null();;
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ocl_haveAmdBlas(const Napi::CallbackInfo &info)
{
    using namespace cv::ocl;

    bool retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::ocl::haveAmdBlas());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ocl_haveAmdFft(const Napi::CallbackInfo &info)
{
    using namespace cv::ocl;

    bool retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::ocl::haveAmdFft());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ocl_haveOpenCL(const Napi::CallbackInfo &info)
{
    using namespace cv::ocl;

    bool retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::ocl::haveOpenCL());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ocl_setUseOpenCL(const Napi::CallbackInfo &info)
{
    using namespace cv::ocl;

    Napi::Value* jsobj_flag = NULL;
    bool flag=0;

    const char* keywords[] = { "flag", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:setUseOpenCL", (char**)keywords, &jsobj_flag) &&
        jsopencv_to_safe(jsobj_flag, flag, ArgInfo("flag", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ocl::setUseOpenCL(flag));
        return info.Env().Null();;
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ocl_useOpenCL(const Napi::CallbackInfo &info)
{
    using namespace cv::ocl;

    bool retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::ocl::useOpenCL());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_parallel_setParallelForBackend(const Napi::CallbackInfo &info)
{
    using namespace cv::parallel;

    Napi::Value* jsobj_backendName = NULL;
    std::string backendName;
    Napi::Value* jsobj_propagateNumThreads = NULL;
    bool propagateNumThreads=true;
    bool retval;

    const char* keywords[] = { "backendName", "propagateNumThreads", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:setParallelForBackend", (char**)keywords, &jsobj_backendName, &jsobj_propagateNumThreads) &&
        jsopencv_to_safe(jsobj_backendName, backendName, ArgInfo("backendName", 0)) &&
        jsopencv_to_safe(jsobj_propagateNumThreads, propagateNumThreads, ArgInfo("propagateNumThreads", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::parallel::setParallelForBackend(backendName, propagateNumThreads));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_plot_Plot2d_create(const Napi::CallbackInfo &info)
{
    using namespace cv::plot;

    jsPrepareArgumentConversionErrorsStorage(4);

    {
    Napi::Value* jsobj_data = NULL;
    Mat data;
    Ptr<Plot2d> retval;

    const char* keywords[] = { "data", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:Plot2d_create", (char**)keywords, &jsobj_data) &&
        jsopencv_to_safe(jsobj_data, data, ArgInfo("data", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::plot::Plot2d::create(data));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_data = NULL;
    UMat data;
    Ptr<Plot2d> retval;

    const char* keywords[] = { "data", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:Plot2d_create", (char**)keywords, &jsobj_data) &&
        jsopencv_to_safe(jsobj_data, data, ArgInfo("data", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::plot::Plot2d::create(data));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_dataX = NULL;
    Mat dataX;
    Napi::Value* jsobj_dataY = NULL;
    Mat dataY;
    Ptr<Plot2d> retval;

    const char* keywords[] = { "dataX", "dataY", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:Plot2d_create", (char**)keywords, &jsobj_dataX, &jsobj_dataY) &&
        jsopencv_to_safe(jsobj_dataX, dataX, ArgInfo("dataX", 0)) &&
        jsopencv_to_safe(jsobj_dataY, dataY, ArgInfo("dataY", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::plot::Plot2d::create(dataX, dataY));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_dataX = NULL;
    UMat dataX;
    Napi::Value* jsobj_dataY = NULL;
    UMat dataY;
    Ptr<Plot2d> retval;

    const char* keywords[] = { "dataX", "dataY", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:Plot2d_create", (char**)keywords, &jsobj_dataX, &jsobj_dataY) &&
        jsopencv_to_safe(jsobj_dataX, dataX, ArgInfo("dataX", 0)) &&
        jsopencv_to_safe(jsobj_dataY, dataY, ArgInfo("dataY", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::plot::Plot2d::create(dataX, dataY));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "Plot2d_create");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_quality_QualityBRISQUE_compute(const Napi::CallbackInfo &info)
{
    using namespace cv::quality;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_img = NULL;
    Mat img;
    Napi::Value* jsobj_model_file_path = NULL;
    String model_file_path;
    Napi::Value* jsobj_range_file_path = NULL;
    String range_file_path;
    cv::Scalar retval;

    const char* keywords[] = { "img", "model_file_path", "range_file_path", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:QualityBRISQUE_compute", (char**)keywords, &jsobj_img, &jsobj_model_file_path, &jsobj_range_file_path) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 0)) &&
        jsopencv_to_safe(jsobj_model_file_path, model_file_path, ArgInfo("model_file_path", 0)) &&
        jsopencv_to_safe(jsobj_range_file_path, range_file_path, ArgInfo("range_file_path", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::quality::QualityBRISQUE::compute(img, model_file_path, range_file_path));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_img = NULL;
    UMat img;
    Napi::Value* jsobj_model_file_path = NULL;
    String model_file_path;
    Napi::Value* jsobj_range_file_path = NULL;
    String range_file_path;
    cv::Scalar retval;

    const char* keywords[] = { "img", "model_file_path", "range_file_path", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:QualityBRISQUE_compute", (char**)keywords, &jsobj_img, &jsobj_model_file_path, &jsobj_range_file_path) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 0)) &&
        jsopencv_to_safe(jsobj_model_file_path, model_file_path, ArgInfo("model_file_path", 0)) &&
        jsopencv_to_safe(jsobj_range_file_path, range_file_path, ArgInfo("range_file_path", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::quality::QualityBRISQUE::compute(img, model_file_path, range_file_path));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "QualityBRISQUE_compute");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_quality_QualityBRISQUE_computeFeatures(const Napi::CallbackInfo &info)
{
    using namespace cv::quality;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_img = NULL;
    Mat img;
    Napi::Value* jsobj_features = NULL;
    Mat features;

    const char* keywords[] = { "img", "features", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:QualityBRISQUE_computeFeatures", (char**)keywords, &jsobj_img, &jsobj_features) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 0)) &&
        jsopencv_to_safe(jsobj_features, features, ArgInfo("features", 1)))
    {
        ERRWRAP2_NAPI(info, cv::quality::QualityBRISQUE::computeFeatures(img, features));
        return jsopencv_from(info, features);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_img = NULL;
    UMat img;
    Napi::Value* jsobj_features = NULL;
    UMat features;

    const char* keywords[] = { "img", "features", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:QualityBRISQUE_computeFeatures", (char**)keywords, &jsobj_img, &jsobj_features) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 0)) &&
        jsopencv_to_safe(jsobj_features, features, ArgInfo("features", 1)))
    {
        ERRWRAP2_NAPI(info, cv::quality::QualityBRISQUE::computeFeatures(img, features));
        return jsopencv_from(info, features);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "QualityBRISQUE_computeFeatures");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_quality_QualityBRISQUE_create(const Napi::CallbackInfo &info)
{
    using namespace cv::quality;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_model_file_path = NULL;
    String model_file_path;
    Napi::Value* jsobj_range_file_path = NULL;
    String range_file_path;
    Ptr<QualityBRISQUE> retval;

    const char* keywords[] = { "model_file_path", "range_file_path", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:QualityBRISQUE_create", (char**)keywords, &jsobj_model_file_path, &jsobj_range_file_path) &&
        jsopencv_to_safe(jsobj_model_file_path, model_file_path, ArgInfo("model_file_path", 0)) &&
        jsopencv_to_safe(jsobj_range_file_path, range_file_path, ArgInfo("range_file_path", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::quality::QualityBRISQUE::create(model_file_path, range_file_path));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_model = NULL;
    Ptr<ml::SVM> model;
    Napi::Value* jsobj_range = NULL;
    Mat range;
    Ptr<QualityBRISQUE> retval;

    const char* keywords[] = { "model", "range", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:QualityBRISQUE_create", (char**)keywords, &jsobj_model, &jsobj_range) &&
        jsopencv_to_safe(jsobj_model, model, ArgInfo("model", 0)) &&
        jsopencv_to_safe(jsobj_range, range, ArgInfo("range", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::quality::QualityBRISQUE::create(model, range));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "QualityBRISQUE_create");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_quality_QualityGMSD_compute(const Napi::CallbackInfo &info)
{
    using namespace cv::quality;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_ref = NULL;
    Mat ref;
    Napi::Value* jsobj_cmp = NULL;
    Mat cmp;
    Napi::Value* jsobj_qualityMap = NULL;
    Mat qualityMap;
    cv::Scalar retval;

    const char* keywords[] = { "ref", "cmp", "qualityMap", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:QualityGMSD_compute", (char**)keywords, &jsobj_ref, &jsobj_cmp, &jsobj_qualityMap) &&
        jsopencv_to_safe(jsobj_ref, ref, ArgInfo("ref", 0)) &&
        jsopencv_to_safe(jsobj_cmp, cmp, ArgInfo("cmp", 0)) &&
        jsopencv_to_safe(jsobj_qualityMap, qualityMap, ArgInfo("qualityMap", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::quality::QualityGMSD::compute(ref, cmp, qualityMap));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, qualityMap));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_ref = NULL;
    UMat ref;
    Napi::Value* jsobj_cmp = NULL;
    UMat cmp;
    Napi::Value* jsobj_qualityMap = NULL;
    UMat qualityMap;
    cv::Scalar retval;

    const char* keywords[] = { "ref", "cmp", "qualityMap", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:QualityGMSD_compute", (char**)keywords, &jsobj_ref, &jsobj_cmp, &jsobj_qualityMap) &&
        jsopencv_to_safe(jsobj_ref, ref, ArgInfo("ref", 0)) &&
        jsopencv_to_safe(jsobj_cmp, cmp, ArgInfo("cmp", 0)) &&
        jsopencv_to_safe(jsobj_qualityMap, qualityMap, ArgInfo("qualityMap", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::quality::QualityGMSD::compute(ref, cmp, qualityMap));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, qualityMap));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "QualityGMSD_compute");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_quality_QualityGMSD_create(const Napi::CallbackInfo &info)
{
    using namespace cv::quality;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_ref = NULL;
    Mat ref;
    Ptr<QualityGMSD> retval;

    const char* keywords[] = { "ref", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:QualityGMSD_create", (char**)keywords, &jsobj_ref) &&
        jsopencv_to_safe(jsobj_ref, ref, ArgInfo("ref", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::quality::QualityGMSD::create(ref));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_ref = NULL;
    UMat ref;
    Ptr<QualityGMSD> retval;

    const char* keywords[] = { "ref", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:QualityGMSD_create", (char**)keywords, &jsobj_ref) &&
        jsopencv_to_safe(jsobj_ref, ref, ArgInfo("ref", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::quality::QualityGMSD::create(ref));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "QualityGMSD_create");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_quality_QualityMSE_compute(const Napi::CallbackInfo &info)
{
    using namespace cv::quality;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_ref = NULL;
    Mat ref;
    Napi::Value* jsobj_cmp = NULL;
    Mat cmp;
    Napi::Value* jsobj_qualityMap = NULL;
    Mat qualityMap;
    cv::Scalar retval;

    const char* keywords[] = { "ref", "cmp", "qualityMap", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:QualityMSE_compute", (char**)keywords, &jsobj_ref, &jsobj_cmp, &jsobj_qualityMap) &&
        jsopencv_to_safe(jsobj_ref, ref, ArgInfo("ref", 0)) &&
        jsopencv_to_safe(jsobj_cmp, cmp, ArgInfo("cmp", 0)) &&
        jsopencv_to_safe(jsobj_qualityMap, qualityMap, ArgInfo("qualityMap", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::quality::QualityMSE::compute(ref, cmp, qualityMap));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, qualityMap));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_ref = NULL;
    UMat ref;
    Napi::Value* jsobj_cmp = NULL;
    UMat cmp;
    Napi::Value* jsobj_qualityMap = NULL;
    UMat qualityMap;
    cv::Scalar retval;

    const char* keywords[] = { "ref", "cmp", "qualityMap", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:QualityMSE_compute", (char**)keywords, &jsobj_ref, &jsobj_cmp, &jsobj_qualityMap) &&
        jsopencv_to_safe(jsobj_ref, ref, ArgInfo("ref", 0)) &&
        jsopencv_to_safe(jsobj_cmp, cmp, ArgInfo("cmp", 0)) &&
        jsopencv_to_safe(jsobj_qualityMap, qualityMap, ArgInfo("qualityMap", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::quality::QualityMSE::compute(ref, cmp, qualityMap));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, qualityMap));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "QualityMSE_compute");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_quality_QualityMSE_create(const Napi::CallbackInfo &info)
{
    using namespace cv::quality;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_ref = NULL;
    Mat ref;
    Ptr<QualityMSE> retval;

    const char* keywords[] = { "ref", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:QualityMSE_create", (char**)keywords, &jsobj_ref) &&
        jsopencv_to_safe(jsobj_ref, ref, ArgInfo("ref", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::quality::QualityMSE::create(ref));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_ref = NULL;
    UMat ref;
    Ptr<QualityMSE> retval;

    const char* keywords[] = { "ref", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:QualityMSE_create", (char**)keywords, &jsobj_ref) &&
        jsopencv_to_safe(jsobj_ref, ref, ArgInfo("ref", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::quality::QualityMSE::create(ref));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "QualityMSE_create");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_quality_QualityPSNR_compute(const Napi::CallbackInfo &info)
{
    using namespace cv::quality;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_ref = NULL;
    Mat ref;
    Napi::Value* jsobj_cmp = NULL;
    Mat cmp;
    Napi::Value* jsobj_qualityMap = NULL;
    Mat qualityMap;
    Napi::Value* jsobj_maxPixelValue = NULL;
    double maxPixelValue=QualityPSNR::MAX_PIXEL_VALUE_DEFAULT;
    cv::Scalar retval;

    const char* keywords[] = { "ref", "cmp", "qualityMap", "maxPixelValue", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:QualityPSNR_compute", (char**)keywords, &jsobj_ref, &jsobj_cmp, &jsobj_qualityMap, &jsobj_maxPixelValue) &&
        jsopencv_to_safe(jsobj_ref, ref, ArgInfo("ref", 0)) &&
        jsopencv_to_safe(jsobj_cmp, cmp, ArgInfo("cmp", 0)) &&
        jsopencv_to_safe(jsobj_qualityMap, qualityMap, ArgInfo("qualityMap", 1)) &&
        jsopencv_to_safe(jsobj_maxPixelValue, maxPixelValue, ArgInfo("maxPixelValue", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::quality::QualityPSNR::compute(ref, cmp, qualityMap, maxPixelValue));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, qualityMap));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_ref = NULL;
    UMat ref;
    Napi::Value* jsobj_cmp = NULL;
    UMat cmp;
    Napi::Value* jsobj_qualityMap = NULL;
    UMat qualityMap;
    Napi::Value* jsobj_maxPixelValue = NULL;
    double maxPixelValue=QualityPSNR::MAX_PIXEL_VALUE_DEFAULT;
    cv::Scalar retval;

    const char* keywords[] = { "ref", "cmp", "qualityMap", "maxPixelValue", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:QualityPSNR_compute", (char**)keywords, &jsobj_ref, &jsobj_cmp, &jsobj_qualityMap, &jsobj_maxPixelValue) &&
        jsopencv_to_safe(jsobj_ref, ref, ArgInfo("ref", 0)) &&
        jsopencv_to_safe(jsobj_cmp, cmp, ArgInfo("cmp", 0)) &&
        jsopencv_to_safe(jsobj_qualityMap, qualityMap, ArgInfo("qualityMap", 1)) &&
        jsopencv_to_safe(jsobj_maxPixelValue, maxPixelValue, ArgInfo("maxPixelValue", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::quality::QualityPSNR::compute(ref, cmp, qualityMap, maxPixelValue));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, qualityMap));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "QualityPSNR_compute");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_quality_QualityPSNR_create(const Napi::CallbackInfo &info)
{
    using namespace cv::quality;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_ref = NULL;
    Mat ref;
    Napi::Value* jsobj_maxPixelValue = NULL;
    double maxPixelValue=QualityPSNR::MAX_PIXEL_VALUE_DEFAULT;
    Ptr<QualityPSNR> retval;

    const char* keywords[] = { "ref", "maxPixelValue", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:QualityPSNR_create", (char**)keywords, &jsobj_ref, &jsobj_maxPixelValue) &&
        jsopencv_to_safe(jsobj_ref, ref, ArgInfo("ref", 0)) &&
        jsopencv_to_safe(jsobj_maxPixelValue, maxPixelValue, ArgInfo("maxPixelValue", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::quality::QualityPSNR::create(ref, maxPixelValue));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_ref = NULL;
    UMat ref;
    Napi::Value* jsobj_maxPixelValue = NULL;
    double maxPixelValue=QualityPSNR::MAX_PIXEL_VALUE_DEFAULT;
    Ptr<QualityPSNR> retval;

    const char* keywords[] = { "ref", "maxPixelValue", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:QualityPSNR_create", (char**)keywords, &jsobj_ref, &jsobj_maxPixelValue) &&
        jsopencv_to_safe(jsobj_ref, ref, ArgInfo("ref", 0)) &&
        jsopencv_to_safe(jsobj_maxPixelValue, maxPixelValue, ArgInfo("maxPixelValue", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::quality::QualityPSNR::create(ref, maxPixelValue));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "QualityPSNR_create");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_quality_QualitySSIM_compute(const Napi::CallbackInfo &info)
{
    using namespace cv::quality;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_ref = NULL;
    Mat ref;
    Napi::Value* jsobj_cmp = NULL;
    Mat cmp;
    Napi::Value* jsobj_qualityMap = NULL;
    Mat qualityMap;
    cv::Scalar retval;

    const char* keywords[] = { "ref", "cmp", "qualityMap", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:QualitySSIM_compute", (char**)keywords, &jsobj_ref, &jsobj_cmp, &jsobj_qualityMap) &&
        jsopencv_to_safe(jsobj_ref, ref, ArgInfo("ref", 0)) &&
        jsopencv_to_safe(jsobj_cmp, cmp, ArgInfo("cmp", 0)) &&
        jsopencv_to_safe(jsobj_qualityMap, qualityMap, ArgInfo("qualityMap", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::quality::QualitySSIM::compute(ref, cmp, qualityMap));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, qualityMap));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_ref = NULL;
    UMat ref;
    Napi::Value* jsobj_cmp = NULL;
    UMat cmp;
    Napi::Value* jsobj_qualityMap = NULL;
    UMat qualityMap;
    cv::Scalar retval;

    const char* keywords[] = { "ref", "cmp", "qualityMap", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:QualitySSIM_compute", (char**)keywords, &jsobj_ref, &jsobj_cmp, &jsobj_qualityMap) &&
        jsopencv_to_safe(jsobj_ref, ref, ArgInfo("ref", 0)) &&
        jsopencv_to_safe(jsobj_cmp, cmp, ArgInfo("cmp", 0)) &&
        jsopencv_to_safe(jsobj_qualityMap, qualityMap, ArgInfo("qualityMap", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::quality::QualitySSIM::compute(ref, cmp, qualityMap));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, qualityMap));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "QualitySSIM_compute");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_quality_QualitySSIM_create(const Napi::CallbackInfo &info)
{
    using namespace cv::quality;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_ref = NULL;
    Mat ref;
    Ptr<QualitySSIM> retval;

    const char* keywords[] = { "ref", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:QualitySSIM_create", (char**)keywords, &jsobj_ref) &&
        jsopencv_to_safe(jsobj_ref, ref, ArgInfo("ref", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::quality::QualitySSIM::create(ref));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_ref = NULL;
    UMat ref;
    Ptr<QualitySSIM> retval;

    const char* keywords[] = { "ref", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:QualitySSIM_create", (char**)keywords, &jsobj_ref) &&
        jsopencv_to_safe(jsobj_ref, ref, ArgInfo("ref", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::quality::QualitySSIM::create(ref));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "QualitySSIM_create");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_rapid_GOSTracker_create(const Napi::CallbackInfo &info)
{
    using namespace cv::rapid;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_pts3d = NULL;
    Mat pts3d;
    Napi::Value* jsobj_tris = NULL;
    Mat tris;
    Napi::Value* jsobj_histBins = NULL;
    int histBins=4;
    Napi::Value* jsobj_sobelThesh = NULL;
    uchar sobelThesh=10;
    Ptr<OLSTracker> retval;

    const char* keywords[] = { "pts3d", "tris", "histBins", "sobelThesh", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:GOSTracker_create", (char**)keywords, &jsobj_pts3d, &jsobj_tris, &jsobj_histBins, &jsobj_sobelThesh) &&
        jsopencv_to_safe(jsobj_pts3d, pts3d, ArgInfo("pts3d", 0)) &&
        jsopencv_to_safe(jsobj_tris, tris, ArgInfo("tris", 0)) &&
        jsopencv_to_safe(jsobj_histBins, histBins, ArgInfo("histBins", 0)) &&
        jsopencv_to_safe(jsobj_sobelThesh, sobelThesh, ArgInfo("sobelThesh", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::rapid::GOSTracker::create(pts3d, tris, histBins, sobelThesh));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_pts3d = NULL;
    UMat pts3d;
    Napi::Value* jsobj_tris = NULL;
    UMat tris;
    Napi::Value* jsobj_histBins = NULL;
    int histBins=4;
    Napi::Value* jsobj_sobelThesh = NULL;
    uchar sobelThesh=10;
    Ptr<OLSTracker> retval;

    const char* keywords[] = { "pts3d", "tris", "histBins", "sobelThesh", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:GOSTracker_create", (char**)keywords, &jsobj_pts3d, &jsobj_tris, &jsobj_histBins, &jsobj_sobelThesh) &&
        jsopencv_to_safe(jsobj_pts3d, pts3d, ArgInfo("pts3d", 0)) &&
        jsopencv_to_safe(jsobj_tris, tris, ArgInfo("tris", 0)) &&
        jsopencv_to_safe(jsobj_histBins, histBins, ArgInfo("histBins", 0)) &&
        jsopencv_to_safe(jsobj_sobelThesh, sobelThesh, ArgInfo("sobelThesh", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::rapid::GOSTracker::create(pts3d, tris, histBins, sobelThesh));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "GOSTracker_create");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_rapid_OLSTracker_create(const Napi::CallbackInfo &info)
{
    using namespace cv::rapid;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_pts3d = NULL;
    Mat pts3d;
    Napi::Value* jsobj_tris = NULL;
    Mat tris;
    Napi::Value* jsobj_histBins = NULL;
    int histBins=8;
    Napi::Value* jsobj_sobelThesh = NULL;
    uchar sobelThesh=10;
    Ptr<OLSTracker> retval;

    const char* keywords[] = { "pts3d", "tris", "histBins", "sobelThesh", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:OLSTracker_create", (char**)keywords, &jsobj_pts3d, &jsobj_tris, &jsobj_histBins, &jsobj_sobelThesh) &&
        jsopencv_to_safe(jsobj_pts3d, pts3d, ArgInfo("pts3d", 0)) &&
        jsopencv_to_safe(jsobj_tris, tris, ArgInfo("tris", 0)) &&
        jsopencv_to_safe(jsobj_histBins, histBins, ArgInfo("histBins", 0)) &&
        jsopencv_to_safe(jsobj_sobelThesh, sobelThesh, ArgInfo("sobelThesh", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::rapid::OLSTracker::create(pts3d, tris, histBins, sobelThesh));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_pts3d = NULL;
    UMat pts3d;
    Napi::Value* jsobj_tris = NULL;
    UMat tris;
    Napi::Value* jsobj_histBins = NULL;
    int histBins=8;
    Napi::Value* jsobj_sobelThesh = NULL;
    uchar sobelThesh=10;
    Ptr<OLSTracker> retval;

    const char* keywords[] = { "pts3d", "tris", "histBins", "sobelThesh", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:OLSTracker_create", (char**)keywords, &jsobj_pts3d, &jsobj_tris, &jsobj_histBins, &jsobj_sobelThesh) &&
        jsopencv_to_safe(jsobj_pts3d, pts3d, ArgInfo("pts3d", 0)) &&
        jsopencv_to_safe(jsobj_tris, tris, ArgInfo("tris", 0)) &&
        jsopencv_to_safe(jsobj_histBins, histBins, ArgInfo("histBins", 0)) &&
        jsopencv_to_safe(jsobj_sobelThesh, sobelThesh, ArgInfo("sobelThesh", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::rapid::OLSTracker::create(pts3d, tris, histBins, sobelThesh));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "OLSTracker_create");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_rapid_Rapid_create(const Napi::CallbackInfo &info)
{
    using namespace cv::rapid;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_pts3d = NULL;
    Mat pts3d;
    Napi::Value* jsobj_tris = NULL;
    Mat tris;
    Ptr<Rapid> retval;

    const char* keywords[] = { "pts3d", "tris", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:Rapid_create", (char**)keywords, &jsobj_pts3d, &jsobj_tris) &&
        jsopencv_to_safe(jsobj_pts3d, pts3d, ArgInfo("pts3d", 0)) &&
        jsopencv_to_safe(jsobj_tris, tris, ArgInfo("tris", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::rapid::Rapid::create(pts3d, tris));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_pts3d = NULL;
    UMat pts3d;
    Napi::Value* jsobj_tris = NULL;
    UMat tris;
    Ptr<Rapid> retval;

    const char* keywords[] = { "pts3d", "tris", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:Rapid_create", (char**)keywords, &jsobj_pts3d, &jsobj_tris) &&
        jsopencv_to_safe(jsobj_pts3d, pts3d, ArgInfo("pts3d", 0)) &&
        jsopencv_to_safe(jsobj_tris, tris, ArgInfo("tris", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::rapid::Rapid::create(pts3d, tris));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "Rapid_create");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_rapid_convertCorrespondencies(const Napi::CallbackInfo &info)
{
    using namespace cv::rapid;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_cols = NULL;
    Mat cols;
    Napi::Value* jsobj_srcLocations = NULL;
    Mat srcLocations;
    Napi::Value* jsobj_pts2d = NULL;
    Mat pts2d;
    Napi::Value* jsobj_pts3d = NULL;
    Mat pts3d;
    Napi::Value* jsobj_mask = NULL;
    Mat mask;

    const char* keywords[] = { "cols", "srcLocations", "pts2d", "pts3d", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOO:convertCorrespondencies", (char**)keywords, &jsobj_cols, &jsobj_srcLocations, &jsobj_pts2d, &jsobj_pts3d, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_cols, cols, ArgInfo("cols", 0)) &&
        jsopencv_to_safe(jsobj_srcLocations, srcLocations, ArgInfo("srcLocations", 0)) &&
        jsopencv_to_safe(jsobj_pts2d, pts2d, ArgInfo("pts2d", 1)) &&
        jsopencv_to_safe(jsobj_pts3d, pts3d, ArgInfo("pts3d", 1)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)))
    {
        ERRWRAP2_NAPI(info, cv::rapid::convertCorrespondencies(cols, srcLocations, pts2d, pts3d, mask));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, pts2d), jsopencv_from(info, pts3d));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_cols = NULL;
    UMat cols;
    Napi::Value* jsobj_srcLocations = NULL;
    UMat srcLocations;
    Napi::Value* jsobj_pts2d = NULL;
    UMat pts2d;
    Napi::Value* jsobj_pts3d = NULL;
    UMat pts3d;
    Napi::Value* jsobj_mask = NULL;
    UMat mask;

    const char* keywords[] = { "cols", "srcLocations", "pts2d", "pts3d", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOO:convertCorrespondencies", (char**)keywords, &jsobj_cols, &jsobj_srcLocations, &jsobj_pts2d, &jsobj_pts3d, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_cols, cols, ArgInfo("cols", 0)) &&
        jsopencv_to_safe(jsobj_srcLocations, srcLocations, ArgInfo("srcLocations", 0)) &&
        jsopencv_to_safe(jsobj_pts2d, pts2d, ArgInfo("pts2d", 1)) &&
        jsopencv_to_safe(jsobj_pts3d, pts3d, ArgInfo("pts3d", 1)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)))
    {
        ERRWRAP2_NAPI(info, cv::rapid::convertCorrespondencies(cols, srcLocations, pts2d, pts3d, mask));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, pts2d), jsopencv_from(info, pts3d));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "convertCorrespondencies");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_rapid_drawCorrespondencies(const Napi::CallbackInfo &info)
{
    using namespace cv::rapid;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_bundle = NULL;
    Mat bundle;
    Napi::Value* jsobj_cols = NULL;
    Mat cols;
    Napi::Value* jsobj_colors = NULL;
    Mat colors;

    const char* keywords[] = { "bundle", "cols", "colors", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:drawCorrespondencies", (char**)keywords, &jsobj_bundle, &jsobj_cols, &jsobj_colors) &&
        jsopencv_to_safe(jsobj_bundle, bundle, ArgInfo("bundle", 1)) &&
        jsopencv_to_safe(jsobj_cols, cols, ArgInfo("cols", 0)) &&
        jsopencv_to_safe(jsobj_colors, colors, ArgInfo("colors", 0)))
    {
        ERRWRAP2_NAPI(info, cv::rapid::drawCorrespondencies(bundle, cols, colors));
        return jsopencv_from(info, bundle);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_bundle = NULL;
    UMat bundle;
    Napi::Value* jsobj_cols = NULL;
    UMat cols;
    Napi::Value* jsobj_colors = NULL;
    UMat colors;

    const char* keywords[] = { "bundle", "cols", "colors", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:drawCorrespondencies", (char**)keywords, &jsobj_bundle, &jsobj_cols, &jsobj_colors) &&
        jsopencv_to_safe(jsobj_bundle, bundle, ArgInfo("bundle", 1)) &&
        jsopencv_to_safe(jsobj_cols, cols, ArgInfo("cols", 0)) &&
        jsopencv_to_safe(jsobj_colors, colors, ArgInfo("colors", 0)))
    {
        ERRWRAP2_NAPI(info, cv::rapid::drawCorrespondencies(bundle, cols, colors));
        return jsopencv_from(info, bundle);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "drawCorrespondencies");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_rapid_drawSearchLines(const Napi::CallbackInfo &info)
{
    using namespace cv::rapid;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_img = NULL;
    Mat img;
    Napi::Value* jsobj_locations = NULL;
    Mat locations;
    Napi::Value* jsobj_color = NULL;
    Scalar color;

    const char* keywords[] = { "img", "locations", "color", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:drawSearchLines", (char**)keywords, &jsobj_img, &jsobj_locations, &jsobj_color) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 1)) &&
        jsopencv_to_safe(jsobj_locations, locations, ArgInfo("locations", 0)) &&
        jsopencv_to_safe(jsobj_color, color, ArgInfo("color", 0)))
    {
        ERRWRAP2_NAPI(info, cv::rapid::drawSearchLines(img, locations, color));
        return jsopencv_from(info, img);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_img = NULL;
    UMat img;
    Napi::Value* jsobj_locations = NULL;
    UMat locations;
    Napi::Value* jsobj_color = NULL;
    Scalar color;

    const char* keywords[] = { "img", "locations", "color", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:drawSearchLines", (char**)keywords, &jsobj_img, &jsobj_locations, &jsobj_color) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 1)) &&
        jsopencv_to_safe(jsobj_locations, locations, ArgInfo("locations", 0)) &&
        jsopencv_to_safe(jsobj_color, color, ArgInfo("color", 0)))
    {
        ERRWRAP2_NAPI(info, cv::rapid::drawSearchLines(img, locations, color));
        return jsopencv_from(info, img);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "drawSearchLines");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_rapid_drawWireframe(const Napi::CallbackInfo &info)
{
    using namespace cv::rapid;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_img = NULL;
    Mat img;
    Napi::Value* jsobj_pts2d = NULL;
    Mat pts2d;
    Napi::Value* jsobj_tris = NULL;
    Mat tris;
    Napi::Value* jsobj_color = NULL;
    Scalar color;
    Napi::Value* jsobj_type = NULL;
    int type=LINE_8;
    Napi::Value* jsobj_cullBackface = NULL;
    bool cullBackface=false;

    const char* keywords[] = { "img", "pts2d", "tris", "color", "type", "cullBackface", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OO:drawWireframe", (char**)keywords, &jsobj_img, &jsobj_pts2d, &jsobj_tris, &jsobj_color, &jsobj_type, &jsobj_cullBackface) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 1)) &&
        jsopencv_to_safe(jsobj_pts2d, pts2d, ArgInfo("pts2d", 0)) &&
        jsopencv_to_safe(jsobj_tris, tris, ArgInfo("tris", 0)) &&
        jsopencv_to_safe(jsobj_color, color, ArgInfo("color", 0)) &&
        jsopencv_to_safe(jsobj_type, type, ArgInfo("type", 0)) &&
        jsopencv_to_safe(jsobj_cullBackface, cullBackface, ArgInfo("cullBackface", 0)))
    {
        ERRWRAP2_NAPI(info, cv::rapid::drawWireframe(img, pts2d, tris, color, type, cullBackface));
        return jsopencv_from(info, img);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_img = NULL;
    UMat img;
    Napi::Value* jsobj_pts2d = NULL;
    UMat pts2d;
    Napi::Value* jsobj_tris = NULL;
    UMat tris;
    Napi::Value* jsobj_color = NULL;
    Scalar color;
    Napi::Value* jsobj_type = NULL;
    int type=LINE_8;
    Napi::Value* jsobj_cullBackface = NULL;
    bool cullBackface=false;

    const char* keywords[] = { "img", "pts2d", "tris", "color", "type", "cullBackface", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OO:drawWireframe", (char**)keywords, &jsobj_img, &jsobj_pts2d, &jsobj_tris, &jsobj_color, &jsobj_type, &jsobj_cullBackface) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 1)) &&
        jsopencv_to_safe(jsobj_pts2d, pts2d, ArgInfo("pts2d", 0)) &&
        jsopencv_to_safe(jsobj_tris, tris, ArgInfo("tris", 0)) &&
        jsopencv_to_safe(jsobj_color, color, ArgInfo("color", 0)) &&
        jsopencv_to_safe(jsobj_type, type, ArgInfo("type", 0)) &&
        jsopencv_to_safe(jsobj_cullBackface, cullBackface, ArgInfo("cullBackface", 0)))
    {
        ERRWRAP2_NAPI(info, cv::rapid::drawWireframe(img, pts2d, tris, color, type, cullBackface));
        return jsopencv_from(info, img);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "drawWireframe");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_rapid_extractControlPoints(const Napi::CallbackInfo &info)
{
    using namespace cv::rapid;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_num = NULL;
    int num=0;
    Napi::Value* jsobj_len = NULL;
    int len=0;
    Napi::Value* jsobj_pts3d = NULL;
    Mat pts3d;
    Napi::Value* jsobj_rvec = NULL;
    Mat rvec;
    Napi::Value* jsobj_tvec = NULL;
    Mat tvec;
    Napi::Value* jsobj_K = NULL;
    Mat K;
    Napi::Value* jsobj_imsize = NULL;
    Size imsize;
    Napi::Value* jsobj_tris = NULL;
    Mat tris;
    Napi::Value* jsobj_ctl2d = NULL;
    Mat ctl2d;
    Napi::Value* jsobj_ctl3d = NULL;
    Mat ctl3d;

    const char* keywords[] = { "num", "len", "pts3d", "rvec", "tvec", "K", "imsize", "tris", "ctl2d", "ctl3d", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOOOO|OO:extractControlPoints", (char**)keywords, &jsobj_num, &jsobj_len, &jsobj_pts3d, &jsobj_rvec, &jsobj_tvec, &jsobj_K, &jsobj_imsize, &jsobj_tris, &jsobj_ctl2d, &jsobj_ctl3d) &&
        jsopencv_to_safe(jsobj_num, num, ArgInfo("num", 0)) &&
        jsopencv_to_safe(jsobj_len, len, ArgInfo("len", 0)) &&
        jsopencv_to_safe(jsobj_pts3d, pts3d, ArgInfo("pts3d", 0)) &&
        jsopencv_to_safe(jsobj_rvec, rvec, ArgInfo("rvec", 0)) &&
        jsopencv_to_safe(jsobj_tvec, tvec, ArgInfo("tvec", 0)) &&
        jsopencv_to_safe(jsobj_K, K, ArgInfo("K", 0)) &&
        jsopencv_to_safe(jsobj_imsize, imsize, ArgInfo("imsize", 0)) &&
        jsopencv_to_safe(jsobj_tris, tris, ArgInfo("tris", 0)) &&
        jsopencv_to_safe(jsobj_ctl2d, ctl2d, ArgInfo("ctl2d", 1)) &&
        jsopencv_to_safe(jsobj_ctl3d, ctl3d, ArgInfo("ctl3d", 1)))
    {
        ERRWRAP2_NAPI(info, cv::rapid::extractControlPoints(num, len, pts3d, rvec, tvec, K, imsize, tris, ctl2d, ctl3d));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, ctl2d), jsopencv_from(info, ctl3d));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_num = NULL;
    int num=0;
    Napi::Value* jsobj_len = NULL;
    int len=0;
    Napi::Value* jsobj_pts3d = NULL;
    UMat pts3d;
    Napi::Value* jsobj_rvec = NULL;
    UMat rvec;
    Napi::Value* jsobj_tvec = NULL;
    UMat tvec;
    Napi::Value* jsobj_K = NULL;
    UMat K;
    Napi::Value* jsobj_imsize = NULL;
    Size imsize;
    Napi::Value* jsobj_tris = NULL;
    UMat tris;
    Napi::Value* jsobj_ctl2d = NULL;
    UMat ctl2d;
    Napi::Value* jsobj_ctl3d = NULL;
    UMat ctl3d;

    const char* keywords[] = { "num", "len", "pts3d", "rvec", "tvec", "K", "imsize", "tris", "ctl2d", "ctl3d", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOOOO|OO:extractControlPoints", (char**)keywords, &jsobj_num, &jsobj_len, &jsobj_pts3d, &jsobj_rvec, &jsobj_tvec, &jsobj_K, &jsobj_imsize, &jsobj_tris, &jsobj_ctl2d, &jsobj_ctl3d) &&
        jsopencv_to_safe(jsobj_num, num, ArgInfo("num", 0)) &&
        jsopencv_to_safe(jsobj_len, len, ArgInfo("len", 0)) &&
        jsopencv_to_safe(jsobj_pts3d, pts3d, ArgInfo("pts3d", 0)) &&
        jsopencv_to_safe(jsobj_rvec, rvec, ArgInfo("rvec", 0)) &&
        jsopencv_to_safe(jsobj_tvec, tvec, ArgInfo("tvec", 0)) &&
        jsopencv_to_safe(jsobj_K, K, ArgInfo("K", 0)) &&
        jsopencv_to_safe(jsobj_imsize, imsize, ArgInfo("imsize", 0)) &&
        jsopencv_to_safe(jsobj_tris, tris, ArgInfo("tris", 0)) &&
        jsopencv_to_safe(jsobj_ctl2d, ctl2d, ArgInfo("ctl2d", 1)) &&
        jsopencv_to_safe(jsobj_ctl3d, ctl3d, ArgInfo("ctl3d", 1)))
    {
        ERRWRAP2_NAPI(info, cv::rapid::extractControlPoints(num, len, pts3d, rvec, tvec, K, imsize, tris, ctl2d, ctl3d));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, ctl2d), jsopencv_from(info, ctl3d));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "extractControlPoints");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_rapid_extractLineBundle(const Napi::CallbackInfo &info)
{
    using namespace cv::rapid;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_len = NULL;
    int len=0;
    Napi::Value* jsobj_ctl2d = NULL;
    Mat ctl2d;
    Napi::Value* jsobj_img = NULL;
    Mat img;
    Napi::Value* jsobj_bundle = NULL;
    Mat bundle;
    Napi::Value* jsobj_srcLocations = NULL;
    Mat srcLocations;

    const char* keywords[] = { "len", "ctl2d", "img", "bundle", "srcLocations", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OO:extractLineBundle", (char**)keywords, &jsobj_len, &jsobj_ctl2d, &jsobj_img, &jsobj_bundle, &jsobj_srcLocations) &&
        jsopencv_to_safe(jsobj_len, len, ArgInfo("len", 0)) &&
        jsopencv_to_safe(jsobj_ctl2d, ctl2d, ArgInfo("ctl2d", 0)) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 0)) &&
        jsopencv_to_safe(jsobj_bundle, bundle, ArgInfo("bundle", 1)) &&
        jsopencv_to_safe(jsobj_srcLocations, srcLocations, ArgInfo("srcLocations", 1)))
    {
        ERRWRAP2_NAPI(info, cv::rapid::extractLineBundle(len, ctl2d, img, bundle, srcLocations));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, bundle), jsopencv_from(info, srcLocations));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_len = NULL;
    int len=0;
    Napi::Value* jsobj_ctl2d = NULL;
    UMat ctl2d;
    Napi::Value* jsobj_img = NULL;
    UMat img;
    Napi::Value* jsobj_bundle = NULL;
    UMat bundle;
    Napi::Value* jsobj_srcLocations = NULL;
    UMat srcLocations;

    const char* keywords[] = { "len", "ctl2d", "img", "bundle", "srcLocations", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OO:extractLineBundle", (char**)keywords, &jsobj_len, &jsobj_ctl2d, &jsobj_img, &jsobj_bundle, &jsobj_srcLocations) &&
        jsopencv_to_safe(jsobj_len, len, ArgInfo("len", 0)) &&
        jsopencv_to_safe(jsobj_ctl2d, ctl2d, ArgInfo("ctl2d", 0)) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 0)) &&
        jsopencv_to_safe(jsobj_bundle, bundle, ArgInfo("bundle", 1)) &&
        jsopencv_to_safe(jsobj_srcLocations, srcLocations, ArgInfo("srcLocations", 1)))
    {
        ERRWRAP2_NAPI(info, cv::rapid::extractLineBundle(len, ctl2d, img, bundle, srcLocations));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, bundle), jsopencv_from(info, srcLocations));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "extractLineBundle");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_rapid_findCorrespondencies(const Napi::CallbackInfo &info)
{
    using namespace cv::rapid;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_bundle = NULL;
    Mat bundle;
    Napi::Value* jsobj_cols = NULL;
    Mat cols;
    Napi::Value* jsobj_response = NULL;
    Mat response;

    const char* keywords[] = { "bundle", "cols", "response", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OO:findCorrespondencies", (char**)keywords, &jsobj_bundle, &jsobj_cols, &jsobj_response) &&
        jsopencv_to_safe(jsobj_bundle, bundle, ArgInfo("bundle", 0)) &&
        jsopencv_to_safe(jsobj_cols, cols, ArgInfo("cols", 1)) &&
        jsopencv_to_safe(jsobj_response, response, ArgInfo("response", 1)))
    {
        ERRWRAP2_NAPI(info, cv::rapid::findCorrespondencies(bundle, cols, response));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, cols), jsopencv_from(info, response));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_bundle = NULL;
    UMat bundle;
    Napi::Value* jsobj_cols = NULL;
    UMat cols;
    Napi::Value* jsobj_response = NULL;
    UMat response;

    const char* keywords[] = { "bundle", "cols", "response", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OO:findCorrespondencies", (char**)keywords, &jsobj_bundle, &jsobj_cols, &jsobj_response) &&
        jsopencv_to_safe(jsobj_bundle, bundle, ArgInfo("bundle", 0)) &&
        jsopencv_to_safe(jsobj_cols, cols, ArgInfo("cols", 1)) &&
        jsopencv_to_safe(jsobj_response, response, ArgInfo("response", 1)))
    {
        ERRWRAP2_NAPI(info, cv::rapid::findCorrespondencies(bundle, cols, response));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, cols), jsopencv_from(info, response));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "findCorrespondencies");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_rapid_rapid(const Napi::CallbackInfo &info)
{
    using namespace cv::rapid;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_img = NULL;
    Mat img;
    Napi::Value* jsobj_num = NULL;
    int num=0;
    Napi::Value* jsobj_len = NULL;
    int len=0;
    Napi::Value* jsobj_pts3d = NULL;
    Mat pts3d;
    Napi::Value* jsobj_tris = NULL;
    Mat tris;
    Napi::Value* jsobj_K = NULL;
    Mat K;
    Napi::Value* jsobj_rvec = NULL;
    Mat rvec;
    Napi::Value* jsobj_tvec = NULL;
    Mat tvec;
    double rmsd;
    float retval;

    const char* keywords[] = { "img", "num", "len", "pts3d", "tris", "K", "rvec", "tvec", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOOOO:rapid", (char**)keywords, &jsobj_img, &jsobj_num, &jsobj_len, &jsobj_pts3d, &jsobj_tris, &jsobj_K, &jsobj_rvec, &jsobj_tvec) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 0)) &&
        jsopencv_to_safe(jsobj_num, num, ArgInfo("num", 0)) &&
        jsopencv_to_safe(jsobj_len, len, ArgInfo("len", 0)) &&
        jsopencv_to_safe(jsobj_pts3d, pts3d, ArgInfo("pts3d", 0)) &&
        jsopencv_to_safe(jsobj_tris, tris, ArgInfo("tris", 0)) &&
        jsopencv_to_safe(jsobj_K, K, ArgInfo("K", 0)) &&
        jsopencv_to_safe(jsobj_rvec, rvec, ArgInfo("rvec", 1)) &&
        jsopencv_to_safe(jsobj_tvec, tvec, ArgInfo("tvec", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::rapid::rapid(img, num, len, pts3d, tris, K, rvec, tvec, &rmsd));
        return Js_BuildValue(info, "(NNNN)", jsopencv_from(info, retval), jsopencv_from(info, rvec), jsopencv_from(info, tvec), jsopencv_from(info, rmsd));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_img = NULL;
    UMat img;
    Napi::Value* jsobj_num = NULL;
    int num=0;
    Napi::Value* jsobj_len = NULL;
    int len=0;
    Napi::Value* jsobj_pts3d = NULL;
    UMat pts3d;
    Napi::Value* jsobj_tris = NULL;
    UMat tris;
    Napi::Value* jsobj_K = NULL;
    UMat K;
    Napi::Value* jsobj_rvec = NULL;
    UMat rvec;
    Napi::Value* jsobj_tvec = NULL;
    UMat tvec;
    double rmsd;
    float retval;

    const char* keywords[] = { "img", "num", "len", "pts3d", "tris", "K", "rvec", "tvec", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOOOOO:rapid", (char**)keywords, &jsobj_img, &jsobj_num, &jsobj_len, &jsobj_pts3d, &jsobj_tris, &jsobj_K, &jsobj_rvec, &jsobj_tvec) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 0)) &&
        jsopencv_to_safe(jsobj_num, num, ArgInfo("num", 0)) &&
        jsopencv_to_safe(jsobj_len, len, ArgInfo("len", 0)) &&
        jsopencv_to_safe(jsobj_pts3d, pts3d, ArgInfo("pts3d", 0)) &&
        jsopencv_to_safe(jsobj_tris, tris, ArgInfo("tris", 0)) &&
        jsopencv_to_safe(jsobj_K, K, ArgInfo("K", 0)) &&
        jsopencv_to_safe(jsobj_rvec, rvec, ArgInfo("rvec", 1)) &&
        jsopencv_to_safe(jsobj_tvec, tvec, ArgInfo("tvec", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::rapid::rapid(img, num, len, pts3d, tris, K, rvec, tvec, &rmsd));
        return Js_BuildValue(info, "(NNNN)", jsopencv_from(info, retval), jsopencv_from(info, rvec), jsopencv_from(info, tvec), jsopencv_from(info, rmsd));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "rapid");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_samples_addSamplesDataSearchPath(const Napi::CallbackInfo &info)
{
    using namespace cv::samples;

    Napi::Value* jsobj_path = NULL;
    String path;

    const char* keywords[] = { "path", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:addSamplesDataSearchPath", (char**)keywords, &jsobj_path) &&
        jsopencv_to_safe(jsobj_path, path, ArgInfo("path", 0)))
    {
        ERRWRAP2_NAPI(info, cv::samples::addSamplesDataSearchPath(path));
        return info.Env().Null();;
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_samples_addSamplesDataSearchSubDirectory(const Napi::CallbackInfo &info)
{
    using namespace cv::samples;

    Napi::Value* jsobj_subdir = NULL;
    String subdir;

    const char* keywords[] = { "subdir", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:addSamplesDataSearchSubDirectory", (char**)keywords, &jsobj_subdir) &&
        jsopencv_to_safe(jsobj_subdir, subdir, ArgInfo("subdir", 0)))
    {
        ERRWRAP2_NAPI(info, cv::samples::addSamplesDataSearchSubDirectory(subdir));
        return info.Env().Null();;
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_samples_findFile(const Napi::CallbackInfo &info)
{
    using namespace cv::samples;

    Napi::Value* jsobj_relative_path = NULL;
    String relative_path;
    Napi::Value* jsobj_required = NULL;
    bool required=true;
    Napi::Value* jsobj_silentMode = NULL;
    bool silentMode=false;
    cv::String retval;

    const char* keywords[] = { "relative_path", "required", "silentMode", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OO:findFile", (char**)keywords, &jsobj_relative_path, &jsobj_required, &jsobj_silentMode) &&
        jsopencv_to_safe(jsobj_relative_path, relative_path, ArgInfo("relative_path", 0)) &&
        jsopencv_to_safe(jsobj_required, required, ArgInfo("required", 0)) &&
        jsopencv_to_safe(jsobj_silentMode, silentMode, ArgInfo("silentMode", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::samples::findFile(relative_path, required, silentMode));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_samples_findFileOrKeep(const Napi::CallbackInfo &info)
{
    using namespace cv::samples;

    Napi::Value* jsobj_relative_path = NULL;
    String relative_path;
    Napi::Value* jsobj_silentMode = NULL;
    bool silentMode=false;
    cv::String retval;

    const char* keywords[] = { "relative_path", "silentMode", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:findFileOrKeep", (char**)keywords, &jsobj_relative_path, &jsobj_silentMode) &&
        jsopencv_to_safe(jsobj_relative_path, relative_path, ArgInfo("relative_path", 0)) &&
        jsopencv_to_safe(jsobj_silentMode, silentMode, ArgInfo("silentMode", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::samples::findFileOrKeep(relative_path, silentMode));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_text_OCRBeamSearchDecoder_create(const Napi::CallbackInfo &info)
{
    using namespace cv::text;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_classifier = NULL;
    Ptr<OCRBeamSearchDecoder::ClassifierCallback> classifier;
    Napi::Value* jsobj_vocabulary = NULL;
    std::string vocabulary;
    Napi::Value* jsobj_transition_probabilities_table = NULL;
    Mat transition_probabilities_table;
    Napi::Value* jsobj_emission_probabilities_table = NULL;
    Mat emission_probabilities_table;
    Napi::Value* jsobj_mode = NULL;
    text_decoder_mode mode=OCR_DECODER_VITERBI;
    Napi::Value* jsobj_beam_size = NULL;
    int beam_size=500;
    Ptr<OCRBeamSearchDecoder> retval;

    const char* keywords[] = { "classifier", "vocabulary", "transition_probabilities_table", "emission_probabilities_table", "mode", "beam_size", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OO:OCRBeamSearchDecoder_create", (char**)keywords, &jsobj_classifier, &jsobj_vocabulary, &jsobj_transition_probabilities_table, &jsobj_emission_probabilities_table, &jsobj_mode, &jsobj_beam_size) &&
        jsopencv_to_safe(jsobj_classifier, classifier, ArgInfo("classifier", 0)) &&
        jsopencv_to_safe(jsobj_vocabulary, vocabulary, ArgInfo("vocabulary", 0)) &&
        jsopencv_to_safe(jsobj_transition_probabilities_table, transition_probabilities_table, ArgInfo("transition_probabilities_table", 0)) &&
        jsopencv_to_safe(jsobj_emission_probabilities_table, emission_probabilities_table, ArgInfo("emission_probabilities_table", 0)) &&
        jsopencv_to_safe(jsobj_mode, mode, ArgInfo("mode", 0)) &&
        jsopencv_to_safe(jsobj_beam_size, beam_size, ArgInfo("beam_size", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::text::OCRBeamSearchDecoder::create(classifier, vocabulary, transition_probabilities_table, emission_probabilities_table, mode, beam_size));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_classifier = NULL;
    Ptr<OCRBeamSearchDecoder::ClassifierCallback> classifier;
    Napi::Value* jsobj_vocabulary = NULL;
    std::string vocabulary;
    Napi::Value* jsobj_transition_probabilities_table = NULL;
    UMat transition_probabilities_table;
    Napi::Value* jsobj_emission_probabilities_table = NULL;
    UMat emission_probabilities_table;
    Napi::Value* jsobj_mode = NULL;
    text_decoder_mode mode=OCR_DECODER_VITERBI;
    Napi::Value* jsobj_beam_size = NULL;
    int beam_size=500;
    Ptr<OCRBeamSearchDecoder> retval;

    const char* keywords[] = { "classifier", "vocabulary", "transition_probabilities_table", "emission_probabilities_table", "mode", "beam_size", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OO:OCRBeamSearchDecoder_create", (char**)keywords, &jsobj_classifier, &jsobj_vocabulary, &jsobj_transition_probabilities_table, &jsobj_emission_probabilities_table, &jsobj_mode, &jsobj_beam_size) &&
        jsopencv_to_safe(jsobj_classifier, classifier, ArgInfo("classifier", 0)) &&
        jsopencv_to_safe(jsobj_vocabulary, vocabulary, ArgInfo("vocabulary", 0)) &&
        jsopencv_to_safe(jsobj_transition_probabilities_table, transition_probabilities_table, ArgInfo("transition_probabilities_table", 0)) &&
        jsopencv_to_safe(jsobj_emission_probabilities_table, emission_probabilities_table, ArgInfo("emission_probabilities_table", 0)) &&
        jsopencv_to_safe(jsobj_mode, mode, ArgInfo("mode", 0)) &&
        jsopencv_to_safe(jsobj_beam_size, beam_size, ArgInfo("beam_size", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::text::OCRBeamSearchDecoder::create(classifier, vocabulary, transition_probabilities_table, emission_probabilities_table, mode, beam_size));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "OCRBeamSearchDecoder_create");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_text_OCRHMMDecoder_create(const Napi::CallbackInfo &info)
{
    using namespace cv::text;

    jsPrepareArgumentConversionErrorsStorage(4);

    {
    Napi::Value* jsobj_classifier = NULL;
    Ptr<OCRHMMDecoder::ClassifierCallback> classifier;
    Napi::Value* jsobj_vocabulary = NULL;
    String vocabulary;
    Napi::Value* jsobj_transition_probabilities_table = NULL;
    Mat transition_probabilities_table;
    Napi::Value* jsobj_emission_probabilities_table = NULL;
    Mat emission_probabilities_table;
    Napi::Value* jsobj_mode = NULL;
    int mode=OCR_DECODER_VITERBI;
    Ptr<OCRHMMDecoder> retval;

    const char* keywords[] = { "classifier", "vocabulary", "transition_probabilities_table", "emission_probabilities_table", "mode", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|O:OCRHMMDecoder_create", (char**)keywords, &jsobj_classifier, &jsobj_vocabulary, &jsobj_transition_probabilities_table, &jsobj_emission_probabilities_table, &jsobj_mode) &&
        jsopencv_to_safe(jsobj_classifier, classifier, ArgInfo("classifier", 0)) &&
        jsopencv_to_safe(jsobj_vocabulary, vocabulary, ArgInfo("vocabulary", 0)) &&
        jsopencv_to_safe(jsobj_transition_probabilities_table, transition_probabilities_table, ArgInfo("transition_probabilities_table", 0)) &&
        jsopencv_to_safe(jsobj_emission_probabilities_table, emission_probabilities_table, ArgInfo("emission_probabilities_table", 0)) &&
        jsopencv_to_safe(jsobj_mode, mode, ArgInfo("mode", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::text::OCRHMMDecoder::create(classifier, vocabulary, transition_probabilities_table, emission_probabilities_table, mode));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_classifier = NULL;
    Ptr<OCRHMMDecoder::ClassifierCallback> classifier;
    Napi::Value* jsobj_vocabulary = NULL;
    String vocabulary;
    Napi::Value* jsobj_transition_probabilities_table = NULL;
    UMat transition_probabilities_table;
    Napi::Value* jsobj_emission_probabilities_table = NULL;
    UMat emission_probabilities_table;
    Napi::Value* jsobj_mode = NULL;
    int mode=OCR_DECODER_VITERBI;
    Ptr<OCRHMMDecoder> retval;

    const char* keywords[] = { "classifier", "vocabulary", "transition_probabilities_table", "emission_probabilities_table", "mode", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|O:OCRHMMDecoder_create", (char**)keywords, &jsobj_classifier, &jsobj_vocabulary, &jsobj_transition_probabilities_table, &jsobj_emission_probabilities_table, &jsobj_mode) &&
        jsopencv_to_safe(jsobj_classifier, classifier, ArgInfo("classifier", 0)) &&
        jsopencv_to_safe(jsobj_vocabulary, vocabulary, ArgInfo("vocabulary", 0)) &&
        jsopencv_to_safe(jsobj_transition_probabilities_table, transition_probabilities_table, ArgInfo("transition_probabilities_table", 0)) &&
        jsopencv_to_safe(jsobj_emission_probabilities_table, emission_probabilities_table, ArgInfo("emission_probabilities_table", 0)) &&
        jsopencv_to_safe(jsobj_mode, mode, ArgInfo("mode", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::text::OCRHMMDecoder::create(classifier, vocabulary, transition_probabilities_table, emission_probabilities_table, mode));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_filename = NULL;
    String filename;
    Napi::Value* jsobj_vocabulary = NULL;
    String vocabulary;
    Napi::Value* jsobj_transition_probabilities_table = NULL;
    Mat transition_probabilities_table;
    Napi::Value* jsobj_emission_probabilities_table = NULL;
    Mat emission_probabilities_table;
    Napi::Value* jsobj_mode = NULL;
    int mode=OCR_DECODER_VITERBI;
    Napi::Value* jsobj_classifier = NULL;
    int classifier=OCR_KNN_CLASSIFIER;
    Ptr<OCRHMMDecoder> retval;

    const char* keywords[] = { "filename", "vocabulary", "transition_probabilities_table", "emission_probabilities_table", "mode", "classifier", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OO:OCRHMMDecoder_create", (char**)keywords, &jsobj_filename, &jsobj_vocabulary, &jsobj_transition_probabilities_table, &jsobj_emission_probabilities_table, &jsobj_mode, &jsobj_classifier) &&
        jsopencv_to_safe(jsobj_filename, filename, ArgInfo("filename", 0)) &&
        jsopencv_to_safe(jsobj_vocabulary, vocabulary, ArgInfo("vocabulary", 0)) &&
        jsopencv_to_safe(jsobj_transition_probabilities_table, transition_probabilities_table, ArgInfo("transition_probabilities_table", 0)) &&
        jsopencv_to_safe(jsobj_emission_probabilities_table, emission_probabilities_table, ArgInfo("emission_probabilities_table", 0)) &&
        jsopencv_to_safe(jsobj_mode, mode, ArgInfo("mode", 0)) &&
        jsopencv_to_safe(jsobj_classifier, classifier, ArgInfo("classifier", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::text::OCRHMMDecoder::create(filename, vocabulary, transition_probabilities_table, emission_probabilities_table, mode, classifier));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_filename = NULL;
    String filename;
    Napi::Value* jsobj_vocabulary = NULL;
    String vocabulary;
    Napi::Value* jsobj_transition_probabilities_table = NULL;
    UMat transition_probabilities_table;
    Napi::Value* jsobj_emission_probabilities_table = NULL;
    UMat emission_probabilities_table;
    Napi::Value* jsobj_mode = NULL;
    int mode=OCR_DECODER_VITERBI;
    Napi::Value* jsobj_classifier = NULL;
    int classifier=OCR_KNN_CLASSIFIER;
    Ptr<OCRHMMDecoder> retval;

    const char* keywords[] = { "filename", "vocabulary", "transition_probabilities_table", "emission_probabilities_table", "mode", "classifier", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OO:OCRHMMDecoder_create", (char**)keywords, &jsobj_filename, &jsobj_vocabulary, &jsobj_transition_probabilities_table, &jsobj_emission_probabilities_table, &jsobj_mode, &jsobj_classifier) &&
        jsopencv_to_safe(jsobj_filename, filename, ArgInfo("filename", 0)) &&
        jsopencv_to_safe(jsobj_vocabulary, vocabulary, ArgInfo("vocabulary", 0)) &&
        jsopencv_to_safe(jsobj_transition_probabilities_table, transition_probabilities_table, ArgInfo("transition_probabilities_table", 0)) &&
        jsopencv_to_safe(jsobj_emission_probabilities_table, emission_probabilities_table, ArgInfo("emission_probabilities_table", 0)) &&
        jsopencv_to_safe(jsobj_mode, mode, ArgInfo("mode", 0)) &&
        jsopencv_to_safe(jsobj_classifier, classifier, ArgInfo("classifier", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::text::OCRHMMDecoder::create(filename, vocabulary, transition_probabilities_table, emission_probabilities_table, mode, classifier));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "OCRHMMDecoder_create");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_text_OCRTesseract_create(const Napi::CallbackInfo &info)
{
    using namespace cv::text;

    char* datapath=0;
    char* language=0;
    char* char_whitelist=0;
    Napi::Value* jsobj_oem = NULL;
    int oem=OEM_DEFAULT;
    Napi::Value* jsobj_psmode = NULL;
    int psmode=PSM_AUTO;
    Ptr<OCRTesseract> retval;

    const char* keywords[] = { "datapath", "language", "char_whitelist", "oem", "psmode", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|sssOO:OCRTesseract_create", (char**)keywords, &datapath, &language, &char_whitelist, &jsobj_oem, &jsobj_psmode) &&
        jsopencv_to_safe(jsobj_oem, oem, ArgInfo("oem", 0)) &&
        jsopencv_to_safe(jsobj_psmode, psmode, ArgInfo("psmode", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::text::OCRTesseract::create(datapath, language, char_whitelist, oem, psmode));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_text_TextDetectorCNN_create(const Napi::CallbackInfo &info)
{
    using namespace cv::text;

    Napi::Value* jsobj_modelArchFilename = NULL;
    String modelArchFilename;
    Napi::Value* jsobj_modelWeightsFilename = NULL;
    String modelWeightsFilename;
    Ptr<TextDetectorCNN> retval;

    const char* keywords[] = { "modelArchFilename", "modelWeightsFilename", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:TextDetectorCNN_create", (char**)keywords, &jsobj_modelArchFilename, &jsobj_modelWeightsFilename) &&
        jsopencv_to_safe(jsobj_modelArchFilename, modelArchFilename, ArgInfo("modelArchFilename", 0)) &&
        jsopencv_to_safe(jsobj_modelWeightsFilename, modelWeightsFilename, ArgInfo("modelWeightsFilename", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::text::TextDetectorCNN::create(modelArchFilename, modelWeightsFilename));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_text_computeNMChannels(const Napi::CallbackInfo &info)
{
    using namespace cv::text;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj__src = NULL;
    Mat _src;
    Napi::Value* jsobj__channels = NULL;
    vector_Mat _channels;
    Napi::Value* jsobj__mode = NULL;
    int _mode=ERFILTER_NM_RGBLGrad;

    const char* keywords[] = { "_src", "_channels", "_mode", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OO:computeNMChannels", (char**)keywords, &jsobj__src, &jsobj__channels, &jsobj__mode) &&
        jsopencv_to_safe(jsobj__src, _src, ArgInfo("_src", 0)) &&
        jsopencv_to_safe(jsobj__channels, _channels, ArgInfo("_channels", 1)) &&
        jsopencv_to_safe(jsobj__mode, _mode, ArgInfo("_mode", 0)))
    {
        ERRWRAP2_NAPI(info, cv::text::computeNMChannels(_src, _channels, _mode));
        return jsopencv_from(info, _channels);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj__src = NULL;
    UMat _src;
    Napi::Value* jsobj__channels = NULL;
    vector_UMat _channels;
    Napi::Value* jsobj__mode = NULL;
    int _mode=ERFILTER_NM_RGBLGrad;

    const char* keywords[] = { "_src", "_channels", "_mode", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OO:computeNMChannels", (char**)keywords, &jsobj__src, &jsobj__channels, &jsobj__mode) &&
        jsopencv_to_safe(jsobj__src, _src, ArgInfo("_src", 0)) &&
        jsopencv_to_safe(jsobj__channels, _channels, ArgInfo("_channels", 1)) &&
        jsopencv_to_safe(jsobj__mode, _mode, ArgInfo("_mode", 0)))
    {
        ERRWRAP2_NAPI(info, cv::text::computeNMChannels(_src, _channels, _mode));
        return jsopencv_from(info, _channels);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "computeNMChannels");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_text_createERFilterNM1(const Napi::CallbackInfo &info)
{
    using namespace cv::text;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_cb = NULL;
    Ptr<ERFilter::Callback> cb;
    Napi::Value* jsobj_thresholdDelta = NULL;
    int thresholdDelta=1;
    Napi::Value* jsobj_minArea = NULL;
    float minArea=(float)0.00025;
    Napi::Value* jsobj_maxArea = NULL;
    float maxArea=(float)0.13;
    Napi::Value* jsobj_minProbability = NULL;
    float minProbability=(float)0.4;
    Napi::Value* jsobj_nonMaxSuppression = NULL;
    bool nonMaxSuppression=true;
    Napi::Value* jsobj_minProbabilityDiff = NULL;
    float minProbabilityDiff=(float)0.1;
    Ptr<ERFilter> retval;

    const char* keywords[] = { "cb", "thresholdDelta", "minArea", "maxArea", "minProbability", "nonMaxSuppression", "minProbabilityDiff", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOOOOO:createERFilterNM1", (char**)keywords, &jsobj_cb, &jsobj_thresholdDelta, &jsobj_minArea, &jsobj_maxArea, &jsobj_minProbability, &jsobj_nonMaxSuppression, &jsobj_minProbabilityDiff) &&
        jsopencv_to_safe(jsobj_cb, cb, ArgInfo("cb", 0)) &&
        jsopencv_to_safe(jsobj_thresholdDelta, thresholdDelta, ArgInfo("thresholdDelta", 0)) &&
        jsopencv_to_safe(jsobj_minArea, minArea, ArgInfo("minArea", 0)) &&
        jsopencv_to_safe(jsobj_maxArea, maxArea, ArgInfo("maxArea", 0)) &&
        jsopencv_to_safe(jsobj_minProbability, minProbability, ArgInfo("minProbability", 0)) &&
        jsopencv_to_safe(jsobj_nonMaxSuppression, nonMaxSuppression, ArgInfo("nonMaxSuppression", 0)) &&
        jsopencv_to_safe(jsobj_minProbabilityDiff, minProbabilityDiff, ArgInfo("minProbabilityDiff", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::text::createERFilterNM1(cb, thresholdDelta, minArea, maxArea, minProbability, nonMaxSuppression, minProbabilityDiff));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_filename = NULL;
    String filename;
    Napi::Value* jsobj_thresholdDelta = NULL;
    int thresholdDelta=1;
    Napi::Value* jsobj_minArea = NULL;
    float minArea=(float)0.00025;
    Napi::Value* jsobj_maxArea = NULL;
    float maxArea=(float)0.13;
    Napi::Value* jsobj_minProbability = NULL;
    float minProbability=(float)0.4;
    Napi::Value* jsobj_nonMaxSuppression = NULL;
    bool nonMaxSuppression=true;
    Napi::Value* jsobj_minProbabilityDiff = NULL;
    float minProbabilityDiff=(float)0.1;
    Ptr<ERFilter> retval;

    const char* keywords[] = { "filename", "thresholdDelta", "minArea", "maxArea", "minProbability", "nonMaxSuppression", "minProbabilityDiff", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOOOOO:createERFilterNM1", (char**)keywords, &jsobj_filename, &jsobj_thresholdDelta, &jsobj_minArea, &jsobj_maxArea, &jsobj_minProbability, &jsobj_nonMaxSuppression, &jsobj_minProbabilityDiff) &&
        jsopencv_to_safe(jsobj_filename, filename, ArgInfo("filename", 0)) &&
        jsopencv_to_safe(jsobj_thresholdDelta, thresholdDelta, ArgInfo("thresholdDelta", 0)) &&
        jsopencv_to_safe(jsobj_minArea, minArea, ArgInfo("minArea", 0)) &&
        jsopencv_to_safe(jsobj_maxArea, maxArea, ArgInfo("maxArea", 0)) &&
        jsopencv_to_safe(jsobj_minProbability, minProbability, ArgInfo("minProbability", 0)) &&
        jsopencv_to_safe(jsobj_nonMaxSuppression, nonMaxSuppression, ArgInfo("nonMaxSuppression", 0)) &&
        jsopencv_to_safe(jsobj_minProbabilityDiff, minProbabilityDiff, ArgInfo("minProbabilityDiff", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::text::createERFilterNM1(filename, thresholdDelta, minArea, maxArea, minProbability, nonMaxSuppression, minProbabilityDiff));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "createERFilterNM1");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_text_createERFilterNM2(const Napi::CallbackInfo &info)
{
    using namespace cv::text;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_cb = NULL;
    Ptr<ERFilter::Callback> cb;
    Napi::Value* jsobj_minProbability = NULL;
    float minProbability=(float)0.3;
    Ptr<ERFilter> retval;

    const char* keywords[] = { "cb", "minProbability", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:createERFilterNM2", (char**)keywords, &jsobj_cb, &jsobj_minProbability) &&
        jsopencv_to_safe(jsobj_cb, cb, ArgInfo("cb", 0)) &&
        jsopencv_to_safe(jsobj_minProbability, minProbability, ArgInfo("minProbability", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::text::createERFilterNM2(cb, minProbability));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_filename = NULL;
    String filename;
    Napi::Value* jsobj_minProbability = NULL;
    float minProbability=(float)0.3;
    Ptr<ERFilter> retval;

    const char* keywords[] = { "filename", "minProbability", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:createERFilterNM2", (char**)keywords, &jsobj_filename, &jsobj_minProbability) &&
        jsopencv_to_safe(jsobj_filename, filename, ArgInfo("filename", 0)) &&
        jsopencv_to_safe(jsobj_minProbability, minProbability, ArgInfo("minProbability", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::text::createERFilterNM2(filename, minProbability));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "createERFilterNM2");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_text_createOCRHMMTransitionsTable(const Napi::CallbackInfo &info)
{
    using namespace cv::text;

    Napi::Value* jsobj_vocabulary = NULL;
    String vocabulary;
    Napi::Value* jsobj_lexicon = NULL;
    vector_String lexicon;
    Mat retval;

    const char* keywords[] = { "vocabulary", "lexicon", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:createOCRHMMTransitionsTable", (char**)keywords, &jsobj_vocabulary, &jsobj_lexicon) &&
        jsopencv_to_safe(jsobj_vocabulary, vocabulary, ArgInfo("vocabulary", 0)) &&
        jsopencv_to_safe(jsobj_lexicon, lexicon, ArgInfo("lexicon", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::text::createOCRHMMTransitionsTable(vocabulary, lexicon));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_text_detectRegions(const Napi::CallbackInfo &info)
{
    using namespace cv::text;

    jsPrepareArgumentConversionErrorsStorage(4);

    {
    Napi::Value* jsobj_image = NULL;
    Mat image;
    Napi::Value* jsobj_er_filter1 = NULL;
    Ptr<ERFilter> er_filter1;
    Napi::Value* jsobj_er_filter2 = NULL;
    Ptr<ERFilter> er_filter2;
    vector_vector_Point regions;

    const char* keywords[] = { "image", "er_filter1", "er_filter2", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:detectRegions", (char**)keywords, &jsobj_image, &jsobj_er_filter1, &jsobj_er_filter2) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_er_filter1, er_filter1, ArgInfo("er_filter1", 0)) &&
        jsopencv_to_safe(jsobj_er_filter2, er_filter2, ArgInfo("er_filter2", 0)))
    {
        ERRWRAP2_NAPI(info, cv::text::detectRegions(image, er_filter1, er_filter2, regions));
        return jsopencv_from(info, regions);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_image = NULL;
    UMat image;
    Napi::Value* jsobj_er_filter1 = NULL;
    Ptr<ERFilter> er_filter1;
    Napi::Value* jsobj_er_filter2 = NULL;
    Ptr<ERFilter> er_filter2;
    vector_vector_Point regions;

    const char* keywords[] = { "image", "er_filter1", "er_filter2", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:detectRegions", (char**)keywords, &jsobj_image, &jsobj_er_filter1, &jsobj_er_filter2) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_er_filter1, er_filter1, ArgInfo("er_filter1", 0)) &&
        jsopencv_to_safe(jsobj_er_filter2, er_filter2, ArgInfo("er_filter2", 0)))
    {
        ERRWRAP2_NAPI(info, cv::text::detectRegions(image, er_filter1, er_filter2, regions));
        return jsopencv_from(info, regions);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_image = NULL;
    Mat image;
    Napi::Value* jsobj_er_filter1 = NULL;
    Ptr<ERFilter> er_filter1;
    Napi::Value* jsobj_er_filter2 = NULL;
    Ptr<ERFilter> er_filter2;
    vector_Rect groups_rects;
    Napi::Value* jsobj_method = NULL;
    int method=ERGROUPING_ORIENTATION_HORIZ;
    Napi::Value* jsobj_filename = NULL;
    String filename;
    Napi::Value* jsobj_minProbability = NULL;
    float minProbability=(float)0.5;

    const char* keywords[] = { "image", "er_filter1", "er_filter2", "method", "filename", "minProbability", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOO:detectRegions", (char**)keywords, &jsobj_image, &jsobj_er_filter1, &jsobj_er_filter2, &jsobj_method, &jsobj_filename, &jsobj_minProbability) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_er_filter1, er_filter1, ArgInfo("er_filter1", 0)) &&
        jsopencv_to_safe(jsobj_er_filter2, er_filter2, ArgInfo("er_filter2", 0)) &&
        jsopencv_to_safe(jsobj_method, method, ArgInfo("method", 0)) &&
        jsopencv_to_safe(jsobj_filename, filename, ArgInfo("filename", 0)) &&
        jsopencv_to_safe(jsobj_minProbability, minProbability, ArgInfo("minProbability", 0)))
    {
        ERRWRAP2_NAPI(info, cv::text::detectRegions(image, er_filter1, er_filter2, groups_rects, method, filename, minProbability));
        return jsopencv_from(info, groups_rects);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_image = NULL;
    UMat image;
    Napi::Value* jsobj_er_filter1 = NULL;
    Ptr<ERFilter> er_filter1;
    Napi::Value* jsobj_er_filter2 = NULL;
    Ptr<ERFilter> er_filter2;
    vector_Rect groups_rects;
    Napi::Value* jsobj_method = NULL;
    int method=ERGROUPING_ORIENTATION_HORIZ;
    Napi::Value* jsobj_filename = NULL;
    String filename;
    Napi::Value* jsobj_minProbability = NULL;
    float minProbability=(float)0.5;

    const char* keywords[] = { "image", "er_filter1", "er_filter2", "method", "filename", "minProbability", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOO:detectRegions", (char**)keywords, &jsobj_image, &jsobj_er_filter1, &jsobj_er_filter2, &jsobj_method, &jsobj_filename, &jsobj_minProbability) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_er_filter1, er_filter1, ArgInfo("er_filter1", 0)) &&
        jsopencv_to_safe(jsobj_er_filter2, er_filter2, ArgInfo("er_filter2", 0)) &&
        jsopencv_to_safe(jsobj_method, method, ArgInfo("method", 0)) &&
        jsopencv_to_safe(jsobj_filename, filename, ArgInfo("filename", 0)) &&
        jsopencv_to_safe(jsobj_minProbability, minProbability, ArgInfo("minProbability", 0)))
    {
        ERRWRAP2_NAPI(info, cv::text::detectRegions(image, er_filter1, er_filter2, groups_rects, method, filename, minProbability));
        return jsopencv_from(info, groups_rects);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "detectRegions");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_text_detectTextSWT(const Napi::CallbackInfo &info)
{
    using namespace cv::text;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_input = NULL;
    Mat input;
    vector_Rect result;
    Napi::Value* jsobj_dark_on_light = NULL;
    bool dark_on_light=0;
    Napi::Value* jsobj_draw = NULL;
    Mat draw;
    Napi::Value* jsobj_chainBBs = NULL;
    Mat chainBBs;

    const char* keywords[] = { "input", "dark_on_light", "draw", "chainBBs", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:detectTextSWT", (char**)keywords, &jsobj_input, &jsobj_dark_on_light, &jsobj_draw, &jsobj_chainBBs) &&
        jsopencv_to_safe(jsobj_input, input, ArgInfo("input", 0)) &&
        jsopencv_to_safe(jsobj_dark_on_light, dark_on_light, ArgInfo("dark_on_light", 0)) &&
        jsopencv_to_safe(jsobj_draw, draw, ArgInfo("draw", 1)) &&
        jsopencv_to_safe(jsobj_chainBBs, chainBBs, ArgInfo("chainBBs", 1)))
    {
        ERRWRAP2_NAPI(info, cv::text::detectTextSWT(input, result, dark_on_light, draw, chainBBs));
        return Js_BuildValue(info, "(NNN)", jsopencv_from(info, result), jsopencv_from(info, draw), jsopencv_from(info, chainBBs));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_input = NULL;
    UMat input;
    vector_Rect result;
    Napi::Value* jsobj_dark_on_light = NULL;
    bool dark_on_light=0;
    Napi::Value* jsobj_draw = NULL;
    UMat draw;
    Napi::Value* jsobj_chainBBs = NULL;
    UMat chainBBs;

    const char* keywords[] = { "input", "dark_on_light", "draw", "chainBBs", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:detectTextSWT", (char**)keywords, &jsobj_input, &jsobj_dark_on_light, &jsobj_draw, &jsobj_chainBBs) &&
        jsopencv_to_safe(jsobj_input, input, ArgInfo("input", 0)) &&
        jsopencv_to_safe(jsobj_dark_on_light, dark_on_light, ArgInfo("dark_on_light", 0)) &&
        jsopencv_to_safe(jsobj_draw, draw, ArgInfo("draw", 1)) &&
        jsopencv_to_safe(jsobj_chainBBs, chainBBs, ArgInfo("chainBBs", 1)))
    {
        ERRWRAP2_NAPI(info, cv::text::detectTextSWT(input, result, dark_on_light, draw, chainBBs));
        return Js_BuildValue(info, "(NNN)", jsopencv_from(info, result), jsopencv_from(info, draw), jsopencv_from(info, chainBBs));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "detectTextSWT");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_text_erGrouping(const Napi::CallbackInfo &info)
{
    using namespace cv::text;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_image = NULL;
    Mat image;
    Napi::Value* jsobj_channel = NULL;
    Mat channel;
    Napi::Value* jsobj_regions = NULL;
    vector_vector_Point regions;
    vector_Rect groups_rects;
    Napi::Value* jsobj_method = NULL;
    int method=ERGROUPING_ORIENTATION_HORIZ;
    Napi::Value* jsobj_filename = NULL;
    String filename;
    Napi::Value* jsobj_minProbablity = NULL;
    float minProbablity=(float)0.5;

    const char* keywords[] = { "image", "channel", "regions", "method", "filename", "minProbablity", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOO:erGrouping", (char**)keywords, &jsobj_image, &jsobj_channel, &jsobj_regions, &jsobj_method, &jsobj_filename, &jsobj_minProbablity) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_channel, channel, ArgInfo("channel", 0)) &&
        jsopencv_to_safe(jsobj_regions, regions, ArgInfo("regions", 0)) &&
        jsopencv_to_safe(jsobj_method, method, ArgInfo("method", 0)) &&
        jsopencv_to_safe(jsobj_filename, filename, ArgInfo("filename", 0)) &&
        jsopencv_to_safe(jsobj_minProbablity, minProbablity, ArgInfo("minProbablity", 0)))
    {
        ERRWRAP2_NAPI(info, cv::text::erGrouping(image, channel, regions, groups_rects, method, filename, minProbablity));
        return jsopencv_from(info, groups_rects);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_image = NULL;
    UMat image;
    Napi::Value* jsobj_channel = NULL;
    UMat channel;
    Napi::Value* jsobj_regions = NULL;
    vector_vector_Point regions;
    vector_Rect groups_rects;
    Napi::Value* jsobj_method = NULL;
    int method=ERGROUPING_ORIENTATION_HORIZ;
    Napi::Value* jsobj_filename = NULL;
    String filename;
    Napi::Value* jsobj_minProbablity = NULL;
    float minProbablity=(float)0.5;

    const char* keywords[] = { "image", "channel", "regions", "method", "filename", "minProbablity", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOO:erGrouping", (char**)keywords, &jsobj_image, &jsobj_channel, &jsobj_regions, &jsobj_method, &jsobj_filename, &jsobj_minProbablity) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_channel, channel, ArgInfo("channel", 0)) &&
        jsopencv_to_safe(jsobj_regions, regions, ArgInfo("regions", 0)) &&
        jsopencv_to_safe(jsobj_method, method, ArgInfo("method", 0)) &&
        jsopencv_to_safe(jsobj_filename, filename, ArgInfo("filename", 0)) &&
        jsopencv_to_safe(jsobj_minProbablity, minProbablity, ArgInfo("minProbablity", 0)))
    {
        ERRWRAP2_NAPI(info, cv::text::erGrouping(image, channel, regions, groups_rects, method, filename, minProbablity));
        return jsopencv_from(info, groups_rects);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "erGrouping");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_text_loadClassifierNM1(const Napi::CallbackInfo &info)
{
    using namespace cv::text;

    Napi::Value* jsobj_filename = NULL;
    String filename;
    Ptr<ERFilter::Callback> retval;

    const char* keywords[] = { "filename", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:loadClassifierNM1", (char**)keywords, &jsobj_filename) &&
        jsopencv_to_safe(jsobj_filename, filename, ArgInfo("filename", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::text::loadClassifierNM1(filename));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_text_loadClassifierNM2(const Napi::CallbackInfo &info)
{
    using namespace cv::text;

    Napi::Value* jsobj_filename = NULL;
    String filename;
    Ptr<ERFilter::Callback> retval;

    const char* keywords[] = { "filename", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:loadClassifierNM2", (char**)keywords, &jsobj_filename) &&
        jsopencv_to_safe(jsobj_filename, filename, ArgInfo("filename", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::text::loadClassifierNM2(filename));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_text_loadOCRBeamSearchClassifierCNN(const Napi::CallbackInfo &info)
{
    using namespace cv::text;

    Napi::Value* jsobj_filename = NULL;
    String filename;
    Ptr<OCRBeamSearchDecoder::ClassifierCallback> retval;

    const char* keywords[] = { "filename", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:loadOCRBeamSearchClassifierCNN", (char**)keywords, &jsobj_filename) &&
        jsopencv_to_safe(jsobj_filename, filename, ArgInfo("filename", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::text::loadOCRBeamSearchClassifierCNN(filename));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_text_loadOCRHMMClassifier(const Napi::CallbackInfo &info)
{
    using namespace cv::text;

    Napi::Value* jsobj_filename = NULL;
    String filename;
    Napi::Value* jsobj_classifier = NULL;
    int classifier=0;
    Ptr<OCRHMMDecoder::ClassifierCallback> retval;

    const char* keywords[] = { "filename", "classifier", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:loadOCRHMMClassifier", (char**)keywords, &jsobj_filename, &jsobj_classifier) &&
        jsopencv_to_safe(jsobj_filename, filename, ArgInfo("filename", 0)) &&
        jsopencv_to_safe(jsobj_classifier, classifier, ArgInfo("classifier", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::text::loadOCRHMMClassifier(filename, classifier));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_text_loadOCRHMMClassifierCNN(const Napi::CallbackInfo &info)
{
    using namespace cv::text;

    Napi::Value* jsobj_filename = NULL;
    String filename;
    Ptr<OCRHMMDecoder::ClassifierCallback> retval;

    const char* keywords[] = { "filename", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:loadOCRHMMClassifierCNN", (char**)keywords, &jsobj_filename) &&
        jsopencv_to_safe(jsobj_filename, filename, ArgInfo("filename", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::text::loadOCRHMMClassifierCNN(filename));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_text_loadOCRHMMClassifierNM(const Napi::CallbackInfo &info)
{
    using namespace cv::text;

    Napi::Value* jsobj_filename = NULL;
    String filename;
    Ptr<OCRHMMDecoder::ClassifierCallback> retval;

    const char* keywords[] = { "filename", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:loadOCRHMMClassifierNM", (char**)keywords, &jsobj_filename) &&
        jsopencv_to_safe(jsobj_filename, filename, ArgInfo("filename", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::text::loadOCRHMMClassifierNM(filename));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_utils_dumpBool(const Napi::CallbackInfo &info)
{
    using namespace cv::utils;

    Napi::Value* jsobj_argument = NULL;
    bool argument=0;
    String retval;

    const char* keywords[] = { "argument", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:dumpBool", (char**)keywords, &jsobj_argument) &&
        jsopencv_to_safe(jsobj_argument, argument, ArgInfo("argument", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::utils::dumpBool(argument));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_utils_dumpCString(const Napi::CallbackInfo &info)
{
    using namespace cv::utils;

    char* argument=(char*)"";
    String retval;

    const char* keywords[] = { "argument", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "s:dumpCString", (char**)keywords, &argument))
    {
        ERRWRAP2_NAPI(info, retval = cv::utils::dumpCString(argument));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_utils_dumpDouble(const Napi::CallbackInfo &info)
{
    using namespace cv::utils;

    Napi::Value* jsobj_argument = NULL;
    double argument=0;
    String retval;

    const char* keywords[] = { "argument", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:dumpDouble", (char**)keywords, &jsobj_argument) &&
        jsopencv_to_safe(jsobj_argument, argument, ArgInfo("argument", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::utils::dumpDouble(argument));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_utils_dumpFloat(const Napi::CallbackInfo &info)
{
    using namespace cv::utils;

    Napi::Value* jsobj_argument = NULL;
    float argument=0.f;
    String retval;

    const char* keywords[] = { "argument", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:dumpFloat", (char**)keywords, &jsobj_argument) &&
        jsopencv_to_safe(jsobj_argument, argument, ArgInfo("argument", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::utils::dumpFloat(argument));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_utils_dumpInputArray(const Napi::CallbackInfo &info)
{
    using namespace cv::utils;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_argument = NULL;
    Mat argument;
    String retval;

    const char* keywords[] = { "argument", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:dumpInputArray", (char**)keywords, &jsobj_argument) &&
        jsopencv_to_safe(jsobj_argument, argument, ArgInfo("argument", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::utils::dumpInputArray(argument));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_argument = NULL;
    UMat argument;
    String retval;

    const char* keywords[] = { "argument", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:dumpInputArray", (char**)keywords, &jsobj_argument) &&
        jsopencv_to_safe(jsobj_argument, argument, ArgInfo("argument", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::utils::dumpInputArray(argument));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "dumpInputArray");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_utils_dumpInputArrayOfArrays(const Napi::CallbackInfo &info)
{
    using namespace cv::utils;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_argument = NULL;
    vector_Mat argument;
    String retval;

    const char* keywords[] = { "argument", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:dumpInputArrayOfArrays", (char**)keywords, &jsobj_argument) &&
        jsopencv_to_safe(jsobj_argument, argument, ArgInfo("argument", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::utils::dumpInputArrayOfArrays(argument));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_argument = NULL;
    vector_UMat argument;
    String retval;

    const char* keywords[] = { "argument", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:dumpInputArrayOfArrays", (char**)keywords, &jsobj_argument) &&
        jsopencv_to_safe(jsobj_argument, argument, ArgInfo("argument", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::utils::dumpInputArrayOfArrays(argument));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "dumpInputArrayOfArrays");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_utils_dumpInputOutputArray(const Napi::CallbackInfo &info)
{
    using namespace cv::utils;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_argument = NULL;
    Mat argument;
    String retval;

    const char* keywords[] = { "argument", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:dumpInputOutputArray", (char**)keywords, &jsobj_argument) &&
        jsopencv_to_safe(jsobj_argument, argument, ArgInfo("argument", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::utils::dumpInputOutputArray(argument));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, argument));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_argument = NULL;
    UMat argument;
    String retval;

    const char* keywords[] = { "argument", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:dumpInputOutputArray", (char**)keywords, &jsobj_argument) &&
        jsopencv_to_safe(jsobj_argument, argument, ArgInfo("argument", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::utils::dumpInputOutputArray(argument));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, argument));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "dumpInputOutputArray");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_utils_dumpInputOutputArrayOfArrays(const Napi::CallbackInfo &info)
{
    using namespace cv::utils;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_argument = NULL;
    vector_Mat argument;
    String retval;

    const char* keywords[] = { "argument", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:dumpInputOutputArrayOfArrays", (char**)keywords, &jsobj_argument) &&
        jsopencv_to_safe(jsobj_argument, argument, ArgInfo("argument", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::utils::dumpInputOutputArrayOfArrays(argument));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, argument));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_argument = NULL;
    vector_UMat argument;
    String retval;

    const char* keywords[] = { "argument", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:dumpInputOutputArrayOfArrays", (char**)keywords, &jsobj_argument) &&
        jsopencv_to_safe(jsobj_argument, argument, ArgInfo("argument", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::utils::dumpInputOutputArrayOfArrays(argument));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, argument));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "dumpInputOutputArrayOfArrays");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_utils_dumpInt(const Napi::CallbackInfo &info)
{
    using namespace cv::utils;

    Napi::Value* jsobj_argument = NULL;
    int argument=0;
    String retval;

    const char* keywords[] = { "argument", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:dumpInt", (char**)keywords, &jsobj_argument) &&
        jsopencv_to_safe(jsobj_argument, argument, ArgInfo("argument", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::utils::dumpInt(argument));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_utils_dumpInt64(const Napi::CallbackInfo &info)
{
    using namespace cv::utils;

    Napi::Value* jsobj_argument = NULL;
    int64 argument;
    String retval;

    const char* keywords[] = { "argument", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:dumpInt64", (char**)keywords, &jsobj_argument) &&
        jsopencv_to_safe(jsobj_argument, argument, ArgInfo("argument", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::utils::dumpInt64(argument));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_utils_dumpRange(const Napi::CallbackInfo &info)
{
    using namespace cv::utils;

    Napi::Value* jsobj_argument = NULL;
    Range argument;
    String retval;

    const char* keywords[] = { "argument", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:dumpRange", (char**)keywords, &jsobj_argument) &&
        jsopencv_to_safe(jsobj_argument, argument, ArgInfo("argument", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::utils::dumpRange(argument));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_utils_dumpRect(const Napi::CallbackInfo &info)
{
    using namespace cv::utils;

    Napi::Value* jsobj_argument = NULL;
    Rect argument;
    String retval;

    const char* keywords[] = { "argument", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:dumpRect", (char**)keywords, &jsobj_argument) &&
        jsopencv_to_safe(jsobj_argument, argument, ArgInfo("argument", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::utils::dumpRect(argument));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_utils_dumpRotatedRect(const Napi::CallbackInfo &info)
{
    using namespace cv::utils;

    Napi::Value* jsobj_argument = NULL;
    RotatedRect argument;
    String retval;

    const char* keywords[] = { "argument", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:dumpRotatedRect", (char**)keywords, &jsobj_argument) &&
        jsopencv_to_safe(jsobj_argument, argument, ArgInfo("argument", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::utils::dumpRotatedRect(argument));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_utils_dumpSizeT(const Napi::CallbackInfo &info)
{
    using namespace cv::utils;

    Napi::Value* jsobj_argument = NULL;
    size_t argument=0;
    String retval;

    const char* keywords[] = { "argument", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:dumpSizeT", (char**)keywords, &jsobj_argument) &&
        jsopencv_to_safe(jsobj_argument, argument, ArgInfo("argument", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::utils::dumpSizeT(argument));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_utils_dumpString(const Napi::CallbackInfo &info)
{
    using namespace cv::utils;

    Napi::Value* jsobj_argument = NULL;
    String argument;
    String retval;

    const char* keywords[] = { "argument", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:dumpString", (char**)keywords, &jsobj_argument) &&
        jsopencv_to_safe(jsobj_argument, argument, ArgInfo("argument", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::utils::dumpString(argument));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_utils_dumpTermCriteria(const Napi::CallbackInfo &info)
{
    using namespace cv::utils;

    Napi::Value* jsobj_argument = NULL;
    TermCriteria argument;
    String retval;

    const char* keywords[] = { "argument", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:dumpTermCriteria", (char**)keywords, &jsobj_argument) &&
        jsopencv_to_safe(jsobj_argument, argument, ArgInfo("argument", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::utils::dumpTermCriteria(argument));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_utils_dumpVec2i(const Napi::CallbackInfo &info)
{
    using namespace cv::utils;

    Napi::Value* jsobj_value = NULL;
    Vec2i value=cv::Vec2i(42, 24);
    String retval;

    const char* keywords[] = { "value", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|O:dumpVec2i", (char**)keywords, &jsobj_value) &&
        jsopencv_to_safe(jsobj_value, value, ArgInfo("value", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::utils::dumpVec2i(value));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_utils_dumpVectorOfDouble(const Napi::CallbackInfo &info)
{
    using namespace cv::utils;

    Napi::Value* jsobj_vec = NULL;
    vector_double vec;
    String retval;

    const char* keywords[] = { "vec", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:dumpVectorOfDouble", (char**)keywords, &jsobj_vec) &&
        jsopencv_to_safe(jsobj_vec, vec, ArgInfo("vec", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::utils::dumpVectorOfDouble(vec));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_utils_dumpVectorOfInt(const Napi::CallbackInfo &info)
{
    using namespace cv::utils;

    Napi::Value* jsobj_vec = NULL;
    vector_int vec;
    String retval;

    const char* keywords[] = { "vec", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:dumpVectorOfInt", (char**)keywords, &jsobj_vec) &&
        jsopencv_to_safe(jsobj_vec, vec, ArgInfo("vec", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::utils::dumpVectorOfInt(vec));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_utils_dumpVectorOfRect(const Napi::CallbackInfo &info)
{
    using namespace cv::utils;

    Napi::Value* jsobj_vec = NULL;
    vector_Rect vec;
    String retval;

    const char* keywords[] = { "vec", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:dumpVectorOfRect", (char**)keywords, &jsobj_vec) &&
        jsopencv_to_safe(jsobj_vec, vec, ArgInfo("vec", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::utils::dumpVectorOfRect(vec));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_utils_generateVectorOfInt(const Napi::CallbackInfo &info)
{
    using namespace cv::utils;

    Napi::Value* jsobj_len = NULL;
    size_t len=0;
    vector_int vec;

    const char* keywords[] = { "len", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:generateVectorOfInt", (char**)keywords, &jsobj_len) &&
        jsopencv_to_safe(jsobj_len, len, ArgInfo("len", 0)))
    {
        ERRWRAP2_NAPI(info, cv::utils::generateVectorOfInt(len, vec));
        return jsopencv_from(info, vec);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_utils_generateVectorOfMat(const Napi::CallbackInfo &info)
{
    using namespace cv::utils;

    Napi::Value* jsobj_len = NULL;
    size_t len=0;
    Napi::Value* jsobj_rows = NULL;
    int rows=0;
    Napi::Value* jsobj_cols = NULL;
    int cols=0;
    Napi::Value* jsobj_dtype = NULL;
    int dtype=0;
    Napi::Value* jsobj_vec = NULL;
    vector_Mat vec;

    const char* keywords[] = { "len", "rows", "cols", "dtype", "vec", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|O:generateVectorOfMat", (char**)keywords, &jsobj_len, &jsobj_rows, &jsobj_cols, &jsobj_dtype, &jsobj_vec) &&
        jsopencv_to_safe(jsobj_len, len, ArgInfo("len", 0)) &&
        jsopencv_to_safe(jsobj_rows, rows, ArgInfo("rows", 0)) &&
        jsopencv_to_safe(jsobj_cols, cols, ArgInfo("cols", 0)) &&
        jsopencv_to_safe(jsobj_dtype, dtype, ArgInfo("dtype", 0)) &&
        jsopencv_to_safe(jsobj_vec, vec, ArgInfo("vec", 1)))
    {
        ERRWRAP2_NAPI(info, cv::utils::generateVectorOfMat(len, rows, cols, dtype, vec));
        return jsopencv_from(info, vec);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_utils_generateVectorOfRect(const Napi::CallbackInfo &info)
{
    using namespace cv::utils;

    Napi::Value* jsobj_len = NULL;
    size_t len=0;
    vector_Rect vec;

    const char* keywords[] = { "len", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:generateVectorOfRect", (char**)keywords, &jsobj_len) &&
        jsopencv_to_safe(jsobj_len, len, ArgInfo("len", 0)))
    {
        ERRWRAP2_NAPI(info, cv::utils::generateVectorOfRect(len, vec));
        return jsopencv_from(info, vec);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_utils_testAsyncArray(const Napi::CallbackInfo &info)
{
    using namespace cv::utils;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_argument = NULL;
    Mat argument;
    AsyncArray retval;

    const char* keywords[] = { "argument", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:testAsyncArray", (char**)keywords, &jsobj_argument) &&
        jsopencv_to_safe(jsobj_argument, argument, ArgInfo("argument", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::utils::testAsyncArray(argument));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_argument = NULL;
    UMat argument;
    AsyncArray retval;

    const char* keywords[] = { "argument", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:testAsyncArray", (char**)keywords, &jsobj_argument) &&
        jsopencv_to_safe(jsobj_argument, argument, ArgInfo("argument", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::utils::testAsyncArray(argument));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "testAsyncArray");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_utils_testAsyncException(const Napi::CallbackInfo &info)
{
    using namespace cv::utils;

    AsyncArray retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::utils::testAsyncException());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_utils_testOverloadResolution(const Napi::CallbackInfo &info)
{
    using namespace cv::utils;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_value = NULL;
    int value=0;
    Napi::Value* jsobj_point = NULL;
    Point point=Point(42, 24);
    String retval;

    const char* keywords[] = { "value", "point", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:testOverloadResolution", (char**)keywords, &jsobj_value, &jsobj_point) &&
        jsopencv_to_safe(jsobj_value, value, ArgInfo("value", 0)) &&
        jsopencv_to_safe(jsobj_point, point, ArgInfo("point", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::utils::testOverloadResolution(value, point));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_rect = NULL;
    Rect rect;
    String retval;

    const char* keywords[] = { "rect", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:testOverloadResolution", (char**)keywords, &jsobj_rect) &&
        jsopencv_to_safe(jsobj_rect, rect, ArgInfo("rect", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::utils::testOverloadResolution(rect));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "testOverloadResolution");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_utils_testOverwriteNativeMethod(const Napi::CallbackInfo &info)
{
    using namespace cv::utils;

    Napi::Value* jsobj_argument = NULL;
    int argument=0;
    int retval;

    const char* keywords[] = { "argument", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:testOverwriteNativeMethod", (char**)keywords, &jsobj_argument) &&
        jsopencv_to_safe(jsobj_argument, argument, ArgInfo("argument", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::utils::testOverwriteNativeMethod(argument));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_utils_testRaiseGeneralException(const Napi::CallbackInfo &info)
{
    using namespace cv::utils;


    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, cv::utils::testRaiseGeneralException());
        return info.Env().Null();;
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_utils_testReservedKeywordConversion(const Napi::CallbackInfo &info)
{
    using namespace cv::utils;

    Napi::Value* jsobj_positional_argument = NULL;
    int positional_argument=0;
    Napi::Value* jsobj_lambda = NULL;
    int lambda=2;
    Napi::Value* jsobj_from = NULL;
    int from=3;
    String retval;

    const char* keywords[] = { "positional_argument", "lambda_", "from_", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OO:testReservedKeywordConversion", (char**)keywords, &jsobj_positional_argument, &jsobj_lambda, &jsobj_from) &&
        jsopencv_to_safe(jsobj_positional_argument, positional_argument, ArgInfo("positional_argument", 0)) &&
        jsopencv_to_safe(jsobj_lambda, lambda, ArgInfo("lambda", 0)) &&
        jsopencv_to_safe(jsobj_from, from, ArgInfo("from", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::utils::testReservedKeywordConversion(positional_argument, lambda, from));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_utils_testRotatedRect(const Napi::CallbackInfo &info)
{
    using namespace cv::utils;

    Napi::Value* jsobj_x = NULL;
    float x=0.f;
    Napi::Value* jsobj_y = NULL;
    float y=0.f;
    Napi::Value* jsobj_w = NULL;
    float w=0.f;
    Napi::Value* jsobj_h = NULL;
    float h=0.f;
    Napi::Value* jsobj_angle = NULL;
    float angle=0.f;
    RotatedRect retval;

    const char* keywords[] = { "x", "y", "w", "h", "angle", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOO:testRotatedRect", (char**)keywords, &jsobj_x, &jsobj_y, &jsobj_w, &jsobj_h, &jsobj_angle) &&
        jsopencv_to_safe(jsobj_x, x, ArgInfo("x", 0)) &&
        jsopencv_to_safe(jsobj_y, y, ArgInfo("y", 0)) &&
        jsopencv_to_safe(jsobj_w, w, ArgInfo("w", 0)) &&
        jsopencv_to_safe(jsobj_h, h, ArgInfo("h", 0)) &&
        jsopencv_to_safe(jsobj_angle, angle, ArgInfo("angle", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::utils::testRotatedRect(x, y, w, h, angle));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_utils_testRotatedRectVector(const Napi::CallbackInfo &info)
{
    using namespace cv::utils;

    Napi::Value* jsobj_x = NULL;
    float x=0.f;
    Napi::Value* jsobj_y = NULL;
    float y=0.f;
    Napi::Value* jsobj_w = NULL;
    float w=0.f;
    Napi::Value* jsobj_h = NULL;
    float h=0.f;
    Napi::Value* jsobj_angle = NULL;
    float angle=0.f;
    std::vector<RotatedRect> retval;

    const char* keywords[] = { "x", "y", "w", "h", "angle", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOO:testRotatedRectVector", (char**)keywords, &jsobj_x, &jsobj_y, &jsobj_w, &jsobj_h, &jsobj_angle) &&
        jsopencv_to_safe(jsobj_x, x, ArgInfo("x", 0)) &&
        jsopencv_to_safe(jsobj_y, y, ArgInfo("y", 0)) &&
        jsopencv_to_safe(jsobj_w, w, ArgInfo("w", 0)) &&
        jsopencv_to_safe(jsobj_h, h, ArgInfo("h", 0)) &&
        jsopencv_to_safe(jsobj_angle, angle, ArgInfo("angle", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::utils::testRotatedRectVector(x, y, w, h, angle));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_utils_fs_getCacheDirectoryForDownloads(const Napi::CallbackInfo &info)
{
    using namespace cv::utils::fs;

    cv::String retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::utils::fs::getCacheDirectoryForDownloads());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_utils_nested_ExportClassName_create(const Napi::CallbackInfo &info)
{
    using namespace cv::utils::nested;

    Napi::Value* jsobj_params = NULL;
    OriginalClassName_Params params=OriginalClassName::Params();
    Ptr<OriginalClassName> retval;

    const char* keywords[] = { "params", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|O:ExportClassName_create", (char**)keywords, &jsobj_params) &&
        jsopencv_to_safe(jsobj_params, params, ArgInfo("params", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::utils::nested::OriginalClassName::create(params));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_utils_nested_ExportClassName_originalName(const Napi::CallbackInfo &info)
{
    using namespace cv::utils::nested;

    std::string retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::utils::nested::OriginalClassName::originalName());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_utils_nested_OriginalClassName_create(const Napi::CallbackInfo &info)
{
    using namespace cv::utils::nested;

    Napi::Value* jsobj_params = NULL;
    OriginalClassName_Params params=OriginalClassName::Params();
    Ptr<OriginalClassName> retval;

    const char* keywords[] = { "params", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|O:OriginalClassName_create", (char**)keywords, &jsobj_params) &&
        jsopencv_to_safe(jsobj_params, params, ArgInfo("params", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::utils::nested::OriginalClassName::create(params));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_utils_nested_OriginalClassName_originalName(const Napi::CallbackInfo &info)
{
    using namespace cv::utils::nested;

    std::string retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::utils::nested::OriginalClassName::originalName());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_utils_nested_testEchoBooleanFunction(const Napi::CallbackInfo &info)
{
    using namespace cv::utils::nested;

    Napi::Value* jsobj_flag = NULL;
    bool flag=0;
    bool retval;

    const char* keywords[] = { "flag", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:testEchoBooleanFunction", (char**)keywords, &jsobj_flag) &&
        jsopencv_to_safe(jsobj_flag, flag, ArgInfo("flag", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::utils::nested::testEchoBooleanFunction(flag));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_videoio_registry_getBackendName(const Napi::CallbackInfo &info)
{
    using namespace cv::videoio_registry;

    Napi::Value* jsobj_api = NULL;
    VideoCaptureAPIs api=static_cast<VideoCaptureAPIs>(0);
    cv::String retval;

    const char* keywords[] = { "api", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:getBackendName", (char**)keywords, &jsobj_api) &&
        jsopencv_to_safe(jsobj_api, api, ArgInfo("api", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::videoio_registry::getBackendName(api));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_videoio_registry_getBackends(const Napi::CallbackInfo &info)
{
    using namespace cv::videoio_registry;

    std::vector<VideoCaptureAPIs> retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::videoio_registry::getBackends());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_videoio_registry_getCameraBackendPluginVersion(const Napi::CallbackInfo &info)
{
    using namespace cv::videoio_registry;

    Napi::Value* jsobj_api = NULL;
    VideoCaptureAPIs api=static_cast<VideoCaptureAPIs>(0);
    int version_ABI;
    int version_API;
    std::string retval;

    const char* keywords[] = { "api", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:getCameraBackendPluginVersion", (char**)keywords, &jsobj_api) &&
        jsopencv_to_safe(jsobj_api, api, ArgInfo("api", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::videoio_registry::getCameraBackendPluginVersion(api, version_ABI, version_API));
        return Js_BuildValue(info, "(NNN)", jsopencv_from(info, retval), jsopencv_from(info, version_ABI), jsopencv_from(info, version_API));
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_videoio_registry_getCameraBackends(const Napi::CallbackInfo &info)
{
    using namespace cv::videoio_registry;

    std::vector<VideoCaptureAPIs> retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::videoio_registry::getCameraBackends());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_videoio_registry_getStreamBackendPluginVersion(const Napi::CallbackInfo &info)
{
    using namespace cv::videoio_registry;

    Napi::Value* jsobj_api = NULL;
    VideoCaptureAPIs api=static_cast<VideoCaptureAPIs>(0);
    int version_ABI;
    int version_API;
    std::string retval;

    const char* keywords[] = { "api", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:getStreamBackendPluginVersion", (char**)keywords, &jsobj_api) &&
        jsopencv_to_safe(jsobj_api, api, ArgInfo("api", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::videoio_registry::getStreamBackendPluginVersion(api, version_ABI, version_API));
        return Js_BuildValue(info, "(NNN)", jsopencv_from(info, retval), jsopencv_from(info, version_ABI), jsopencv_from(info, version_API));
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_videoio_registry_getStreamBackends(const Napi::CallbackInfo &info)
{
    using namespace cv::videoio_registry;

    std::vector<VideoCaptureAPIs> retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::videoio_registry::getStreamBackends());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_videoio_registry_getWriterBackendPluginVersion(const Napi::CallbackInfo &info)
{
    using namespace cv::videoio_registry;

    Napi::Value* jsobj_api = NULL;
    VideoCaptureAPIs api=static_cast<VideoCaptureAPIs>(0);
    int version_ABI;
    int version_API;
    std::string retval;

    const char* keywords[] = { "api", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:getWriterBackendPluginVersion", (char**)keywords, &jsobj_api) &&
        jsopencv_to_safe(jsobj_api, api, ArgInfo("api", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::videoio_registry::getWriterBackendPluginVersion(api, version_ABI, version_API));
        return Js_BuildValue(info, "(NNN)", jsopencv_from(info, retval), jsopencv_from(info, version_ABI), jsopencv_from(info, version_API));
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_videoio_registry_getWriterBackends(const Napi::CallbackInfo &info)
{
    using namespace cv::videoio_registry;

    std::vector<VideoCaptureAPIs> retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::videoio_registry::getWriterBackends());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_videoio_registry_hasBackend(const Napi::CallbackInfo &info)
{
    using namespace cv::videoio_registry;

    Napi::Value* jsobj_api = NULL;
    VideoCaptureAPIs api=static_cast<VideoCaptureAPIs>(0);
    bool retval;

    const char* keywords[] = { "api", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:hasBackend", (char**)keywords, &jsobj_api) &&
        jsopencv_to_safe(jsobj_api, api, ArgInfo("api", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::videoio_registry::hasBackend(api));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_videoio_registry_isBackendBuiltIn(const Napi::CallbackInfo &info)
{
    using namespace cv::videoio_registry;

    Napi::Value* jsobj_api = NULL;
    VideoCaptureAPIs api=static_cast<VideoCaptureAPIs>(0);
    bool retval;

    const char* keywords[] = { "api", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:isBackendBuiltIn", (char**)keywords, &jsobj_api) &&
        jsopencv_to_safe(jsobj_api, api, ArgInfo("api", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::videoio_registry::isBackendBuiltIn(api));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_xfeatures2d_BEBLID_create(const Napi::CallbackInfo &info)
{
    using namespace cv::xfeatures2d;

    Napi::Value* jsobj_scale_factor = NULL;
    float scale_factor=0.f;
    Napi::Value* jsobj_n_bits = NULL;
    int n_bits=BEBLID::SIZE_512_BITS;
    Ptr<BEBLID> retval;

    const char* keywords[] = { "scale_factor", "n_bits", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:BEBLID_create", (char**)keywords, &jsobj_scale_factor, &jsobj_n_bits) &&
        jsopencv_to_safe(jsobj_scale_factor, scale_factor, ArgInfo("scale_factor", 0)) &&
        jsopencv_to_safe(jsobj_n_bits, n_bits, ArgInfo("n_bits", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::xfeatures2d::BEBLID::create(scale_factor, n_bits));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_xfeatures2d_BoostDesc_create(const Napi::CallbackInfo &info)
{
    using namespace cv::xfeatures2d;

    Napi::Value* jsobj_desc = NULL;
    int desc=BoostDesc::BINBOOST_256;
    Napi::Value* jsobj_use_scale_orientation = NULL;
    bool use_scale_orientation=true;
    Napi::Value* jsobj_scale_factor = NULL;
    float scale_factor=6.25f;
    Ptr<BoostDesc> retval;

    const char* keywords[] = { "desc", "use_scale_orientation", "scale_factor", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OOO:BoostDesc_create", (char**)keywords, &jsobj_desc, &jsobj_use_scale_orientation, &jsobj_scale_factor) &&
        jsopencv_to_safe(jsobj_desc, desc, ArgInfo("desc", 0)) &&
        jsopencv_to_safe(jsobj_use_scale_orientation, use_scale_orientation, ArgInfo("use_scale_orientation", 0)) &&
        jsopencv_to_safe(jsobj_scale_factor, scale_factor, ArgInfo("scale_factor", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::xfeatures2d::BoostDesc::create(desc, use_scale_orientation, scale_factor));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_xfeatures2d_BriefDescriptorExtractor_create(const Napi::CallbackInfo &info)
{
    using namespace cv::xfeatures2d;

    Napi::Value* jsobj_bytes = NULL;
    int bytes=32;
    Napi::Value* jsobj_use_orientation = NULL;
    bool use_orientation=false;
    Ptr<BriefDescriptorExtractor> retval;

    const char* keywords[] = { "bytes", "use_orientation", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OO:BriefDescriptorExtractor_create", (char**)keywords, &jsobj_bytes, &jsobj_use_orientation) &&
        jsopencv_to_safe(jsobj_bytes, bytes, ArgInfo("bytes", 0)) &&
        jsopencv_to_safe(jsobj_use_orientation, use_orientation, ArgInfo("use_orientation", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::xfeatures2d::BriefDescriptorExtractor::create(bytes, use_orientation));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_xfeatures2d_DAISY_create(const Napi::CallbackInfo &info)
{
    using namespace cv::xfeatures2d;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_radius = NULL;
    float radius=15;
    Napi::Value* jsobj_q_radius = NULL;
    int q_radius=3;
    Napi::Value* jsobj_q_theta = NULL;
    int q_theta=8;
    Napi::Value* jsobj_q_hist = NULL;
    int q_hist=8;
    Napi::Value* jsobj_norm = NULL;
    DAISY_NormalizationType norm=DAISY::NRM_NONE;
    Napi::Value* jsobj_H = NULL;
    Mat H;
    Napi::Value* jsobj_interpolation = NULL;
    bool interpolation=true;
    Napi::Value* jsobj_use_orientation = NULL;
    bool use_orientation=false;
    Ptr<DAISY> retval;

    const char* keywords[] = { "radius", "q_radius", "q_theta", "q_hist", "norm", "H", "interpolation", "use_orientation", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OOOOOOOO:DAISY_create", (char**)keywords, &jsobj_radius, &jsobj_q_radius, &jsobj_q_theta, &jsobj_q_hist, &jsobj_norm, &jsobj_H, &jsobj_interpolation, &jsobj_use_orientation) &&
        jsopencv_to_safe(jsobj_radius, radius, ArgInfo("radius", 0)) &&
        jsopencv_to_safe(jsobj_q_radius, q_radius, ArgInfo("q_radius", 0)) &&
        jsopencv_to_safe(jsobj_q_theta, q_theta, ArgInfo("q_theta", 0)) &&
        jsopencv_to_safe(jsobj_q_hist, q_hist, ArgInfo("q_hist", 0)) &&
        jsopencv_to_safe(jsobj_norm, norm, ArgInfo("norm", 0)) &&
        jsopencv_to_safe(jsobj_H, H, ArgInfo("H", 0)) &&
        jsopencv_to_safe(jsobj_interpolation, interpolation, ArgInfo("interpolation", 0)) &&
        jsopencv_to_safe(jsobj_use_orientation, use_orientation, ArgInfo("use_orientation", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::xfeatures2d::DAISY::create(radius, q_radius, q_theta, q_hist, norm, H, interpolation, use_orientation));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_radius = NULL;
    float radius=15;
    Napi::Value* jsobj_q_radius = NULL;
    int q_radius=3;
    Napi::Value* jsobj_q_theta = NULL;
    int q_theta=8;
    Napi::Value* jsobj_q_hist = NULL;
    int q_hist=8;
    Napi::Value* jsobj_norm = NULL;
    DAISY_NormalizationType norm=DAISY::NRM_NONE;
    Napi::Value* jsobj_H = NULL;
    UMat H;
    Napi::Value* jsobj_interpolation = NULL;
    bool interpolation=true;
    Napi::Value* jsobj_use_orientation = NULL;
    bool use_orientation=false;
    Ptr<DAISY> retval;

    const char* keywords[] = { "radius", "q_radius", "q_theta", "q_hist", "norm", "H", "interpolation", "use_orientation", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OOOOOOOO:DAISY_create", (char**)keywords, &jsobj_radius, &jsobj_q_radius, &jsobj_q_theta, &jsobj_q_hist, &jsobj_norm, &jsobj_H, &jsobj_interpolation, &jsobj_use_orientation) &&
        jsopencv_to_safe(jsobj_radius, radius, ArgInfo("radius", 0)) &&
        jsopencv_to_safe(jsobj_q_radius, q_radius, ArgInfo("q_radius", 0)) &&
        jsopencv_to_safe(jsobj_q_theta, q_theta, ArgInfo("q_theta", 0)) &&
        jsopencv_to_safe(jsobj_q_hist, q_hist, ArgInfo("q_hist", 0)) &&
        jsopencv_to_safe(jsobj_norm, norm, ArgInfo("norm", 0)) &&
        jsopencv_to_safe(jsobj_H, H, ArgInfo("H", 0)) &&
        jsopencv_to_safe(jsobj_interpolation, interpolation, ArgInfo("interpolation", 0)) &&
        jsopencv_to_safe(jsobj_use_orientation, use_orientation, ArgInfo("use_orientation", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::xfeatures2d::DAISY::create(radius, q_radius, q_theta, q_hist, norm, H, interpolation, use_orientation));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "DAISY_create");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_xfeatures2d_FREAK_create(const Napi::CallbackInfo &info)
{
    using namespace cv::xfeatures2d;

    Napi::Value* jsobj_orientationNormalized = NULL;
    bool orientationNormalized=true;
    Napi::Value* jsobj_scaleNormalized = NULL;
    bool scaleNormalized=true;
    Napi::Value* jsobj_patternScale = NULL;
    float patternScale=22.0f;
    Napi::Value* jsobj_nOctaves = NULL;
    int nOctaves=4;
    Napi::Value* jsobj_selectedPairs = NULL;
    vector_int selectedPairs=std::vector<int>();
    Ptr<FREAK> retval;

    const char* keywords[] = { "orientationNormalized", "scaleNormalized", "patternScale", "nOctaves", "selectedPairs", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OOOOO:FREAK_create", (char**)keywords, &jsobj_orientationNormalized, &jsobj_scaleNormalized, &jsobj_patternScale, &jsobj_nOctaves, &jsobj_selectedPairs) &&
        jsopencv_to_safe(jsobj_orientationNormalized, orientationNormalized, ArgInfo("orientationNormalized", 0)) &&
        jsopencv_to_safe(jsobj_scaleNormalized, scaleNormalized, ArgInfo("scaleNormalized", 0)) &&
        jsopencv_to_safe(jsobj_patternScale, patternScale, ArgInfo("patternScale", 0)) &&
        jsopencv_to_safe(jsobj_nOctaves, nOctaves, ArgInfo("nOctaves", 0)) &&
        jsopencv_to_safe(jsobj_selectedPairs, selectedPairs, ArgInfo("selectedPairs", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::xfeatures2d::FREAK::create(orientationNormalized, scaleNormalized, patternScale, nOctaves, selectedPairs));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_xfeatures2d_HarrisLaplaceFeatureDetector_create(const Napi::CallbackInfo &info)
{
    using namespace cv::xfeatures2d;

    Napi::Value* jsobj_numOctaves = NULL;
    int numOctaves=6;
    Napi::Value* jsobj_corn_thresh = NULL;
    float corn_thresh=0.01f;
    Napi::Value* jsobj_DOG_thresh = NULL;
    float DOG_thresh=0.01f;
    Napi::Value* jsobj_maxCorners = NULL;
    int maxCorners=5000;
    Napi::Value* jsobj_num_layers = NULL;
    int num_layers=4;
    Ptr<HarrisLaplaceFeatureDetector> retval;

    const char* keywords[] = { "numOctaves", "corn_thresh", "DOG_thresh", "maxCorners", "num_layers", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OOOOO:HarrisLaplaceFeatureDetector_create", (char**)keywords, &jsobj_numOctaves, &jsobj_corn_thresh, &jsobj_DOG_thresh, &jsobj_maxCorners, &jsobj_num_layers) &&
        jsopencv_to_safe(jsobj_numOctaves, numOctaves, ArgInfo("numOctaves", 0)) &&
        jsopencv_to_safe(jsobj_corn_thresh, corn_thresh, ArgInfo("corn_thresh", 0)) &&
        jsopencv_to_safe(jsobj_DOG_thresh, DOG_thresh, ArgInfo("DOG_thresh", 0)) &&
        jsopencv_to_safe(jsobj_maxCorners, maxCorners, ArgInfo("maxCorners", 0)) &&
        jsopencv_to_safe(jsobj_num_layers, num_layers, ArgInfo("num_layers", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::xfeatures2d::HarrisLaplaceFeatureDetector::create(numOctaves, corn_thresh, DOG_thresh, maxCorners, num_layers));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_xfeatures2d_LATCH_create(const Napi::CallbackInfo &info)
{
    using namespace cv::xfeatures2d;

    Napi::Value* jsobj_bytes = NULL;
    int bytes=32;
    Napi::Value* jsobj_rotationInvariance = NULL;
    bool rotationInvariance=true;
    Napi::Value* jsobj_half_ssd_size = NULL;
    int half_ssd_size=3;
    Napi::Value* jsobj_sigma = NULL;
    double sigma=2.0;
    Ptr<LATCH> retval;

    const char* keywords[] = { "bytes", "rotationInvariance", "half_ssd_size", "sigma", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OOOO:LATCH_create", (char**)keywords, &jsobj_bytes, &jsobj_rotationInvariance, &jsobj_half_ssd_size, &jsobj_sigma) &&
        jsopencv_to_safe(jsobj_bytes, bytes, ArgInfo("bytes", 0)) &&
        jsopencv_to_safe(jsobj_rotationInvariance, rotationInvariance, ArgInfo("rotationInvariance", 0)) &&
        jsopencv_to_safe(jsobj_half_ssd_size, half_ssd_size, ArgInfo("half_ssd_size", 0)) &&
        jsopencv_to_safe(jsobj_sigma, sigma, ArgInfo("sigma", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::xfeatures2d::LATCH::create(bytes, rotationInvariance, half_ssd_size, sigma));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_xfeatures2d_LUCID_create(const Napi::CallbackInfo &info)
{
    using namespace cv::xfeatures2d;

    Napi::Value* jsobj_lucid_kernel = NULL;
    int lucid_kernel=1;
    Napi::Value* jsobj_blur_kernel = NULL;
    int blur_kernel=2;
    Ptr<LUCID> retval;

    const char* keywords[] = { "lucid_kernel", "blur_kernel", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OO:LUCID_create", (char**)keywords, &jsobj_lucid_kernel, &jsobj_blur_kernel) &&
        jsopencv_to_safe(jsobj_lucid_kernel, lucid_kernel, ArgInfo("lucid_kernel", 0)) &&
        jsopencv_to_safe(jsobj_blur_kernel, blur_kernel, ArgInfo("blur_kernel", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::xfeatures2d::LUCID::create(lucid_kernel, blur_kernel));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_xfeatures2d_MSDDetector_create(const Napi::CallbackInfo &info)
{
    using namespace cv::xfeatures2d;

    Napi::Value* jsobj_m_patch_radius = NULL;
    int m_patch_radius=3;
    Napi::Value* jsobj_m_search_area_radius = NULL;
    int m_search_area_radius=5;
    Napi::Value* jsobj_m_nms_radius = NULL;
    int m_nms_radius=5;
    Napi::Value* jsobj_m_nms_scale_radius = NULL;
    int m_nms_scale_radius=0;
    Napi::Value* jsobj_m_th_saliency = NULL;
    float m_th_saliency=250.0f;
    Napi::Value* jsobj_m_kNN = NULL;
    int m_kNN=4;
    Napi::Value* jsobj_m_scale_factor = NULL;
    float m_scale_factor=1.25f;
    Napi::Value* jsobj_m_n_scales = NULL;
    int m_n_scales=-1;
    Napi::Value* jsobj_m_compute_orientation = NULL;
    bool m_compute_orientation=false;
    Ptr<MSDDetector> retval;

    const char* keywords[] = { "m_patch_radius", "m_search_area_radius", "m_nms_radius", "m_nms_scale_radius", "m_th_saliency", "m_kNN", "m_scale_factor", "m_n_scales", "m_compute_orientation", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OOOOOOOOO:MSDDetector_create", (char**)keywords, &jsobj_m_patch_radius, &jsobj_m_search_area_radius, &jsobj_m_nms_radius, &jsobj_m_nms_scale_radius, &jsobj_m_th_saliency, &jsobj_m_kNN, &jsobj_m_scale_factor, &jsobj_m_n_scales, &jsobj_m_compute_orientation) &&
        jsopencv_to_safe(jsobj_m_patch_radius, m_patch_radius, ArgInfo("m_patch_radius", 0)) &&
        jsopencv_to_safe(jsobj_m_search_area_radius, m_search_area_radius, ArgInfo("m_search_area_radius", 0)) &&
        jsopencv_to_safe(jsobj_m_nms_radius, m_nms_radius, ArgInfo("m_nms_radius", 0)) &&
        jsopencv_to_safe(jsobj_m_nms_scale_radius, m_nms_scale_radius, ArgInfo("m_nms_scale_radius", 0)) &&
        jsopencv_to_safe(jsobj_m_th_saliency, m_th_saliency, ArgInfo("m_th_saliency", 0)) &&
        jsopencv_to_safe(jsobj_m_kNN, m_kNN, ArgInfo("m_kNN", 0)) &&
        jsopencv_to_safe(jsobj_m_scale_factor, m_scale_factor, ArgInfo("m_scale_factor", 0)) &&
        jsopencv_to_safe(jsobj_m_n_scales, m_n_scales, ArgInfo("m_n_scales", 0)) &&
        jsopencv_to_safe(jsobj_m_compute_orientation, m_compute_orientation, ArgInfo("m_compute_orientation", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::xfeatures2d::MSDDetector::create(m_patch_radius, m_search_area_radius, m_nms_radius, m_nms_scale_radius, m_th_saliency, m_kNN, m_scale_factor, m_n_scales, m_compute_orientation));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_xfeatures2d_PCTSignaturesSQFD_create(const Napi::CallbackInfo &info)
{
    using namespace cv::xfeatures2d;

    Napi::Value* jsobj_distanceFunction = NULL;
    int distanceFunction=3;
    Napi::Value* jsobj_similarityFunction = NULL;
    int similarityFunction=2;
    Napi::Value* jsobj_similarityParameter = NULL;
    float similarityParameter=1.0f;
    Ptr<PCTSignaturesSQFD> retval;

    const char* keywords[] = { "distanceFunction", "similarityFunction", "similarityParameter", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OOO:PCTSignaturesSQFD_create", (char**)keywords, &jsobj_distanceFunction, &jsobj_similarityFunction, &jsobj_similarityParameter) &&
        jsopencv_to_safe(jsobj_distanceFunction, distanceFunction, ArgInfo("distanceFunction", 0)) &&
        jsopencv_to_safe(jsobj_similarityFunction, similarityFunction, ArgInfo("similarityFunction", 0)) &&
        jsopencv_to_safe(jsobj_similarityParameter, similarityParameter, ArgInfo("similarityParameter", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::xfeatures2d::PCTSignaturesSQFD::create(distanceFunction, similarityFunction, similarityParameter));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_xfeatures2d_PCTSignatures_create(const Napi::CallbackInfo &info)
{
    using namespace cv::xfeatures2d;

    jsPrepareArgumentConversionErrorsStorage(3);

    {
    Napi::Value* jsobj_initSampleCount = NULL;
    int initSampleCount=2000;
    Napi::Value* jsobj_initSeedCount = NULL;
    int initSeedCount=400;
    Napi::Value* jsobj_pointDistribution = NULL;
    int pointDistribution=0;
    Ptr<PCTSignatures> retval;

    const char* keywords[] = { "initSampleCount", "initSeedCount", "pointDistribution", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OOO:PCTSignatures_create", (char**)keywords, &jsobj_initSampleCount, &jsobj_initSeedCount, &jsobj_pointDistribution) &&
        jsopencv_to_safe(jsobj_initSampleCount, initSampleCount, ArgInfo("initSampleCount", 0)) &&
        jsopencv_to_safe(jsobj_initSeedCount, initSeedCount, ArgInfo("initSeedCount", 0)) &&
        jsopencv_to_safe(jsobj_pointDistribution, pointDistribution, ArgInfo("pointDistribution", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::xfeatures2d::PCTSignatures::create(initSampleCount, initSeedCount, pointDistribution));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_initSamplingPoints = NULL;
    vector_Point2f initSamplingPoints;
    Napi::Value* jsobj_initSeedCount = NULL;
    int initSeedCount=0;
    Ptr<PCTSignatures> retval;

    const char* keywords[] = { "initSamplingPoints", "initSeedCount", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:PCTSignatures_create", (char**)keywords, &jsobj_initSamplingPoints, &jsobj_initSeedCount) &&
        jsopencv_to_safe(jsobj_initSamplingPoints, initSamplingPoints, ArgInfo("initSamplingPoints", 0)) &&
        jsopencv_to_safe(jsobj_initSeedCount, initSeedCount, ArgInfo("initSeedCount", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::xfeatures2d::PCTSignatures::create(initSamplingPoints, initSeedCount));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_initSamplingPoints = NULL;
    vector_Point2f initSamplingPoints;
    Napi::Value* jsobj_initClusterSeedIndexes = NULL;
    vector_int initClusterSeedIndexes;
    Ptr<PCTSignatures> retval;

    const char* keywords[] = { "initSamplingPoints", "initClusterSeedIndexes", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:PCTSignatures_create", (char**)keywords, &jsobj_initSamplingPoints, &jsobj_initClusterSeedIndexes) &&
        jsopencv_to_safe(jsobj_initSamplingPoints, initSamplingPoints, ArgInfo("initSamplingPoints", 0)) &&
        jsopencv_to_safe(jsobj_initClusterSeedIndexes, initClusterSeedIndexes, ArgInfo("initClusterSeedIndexes", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::xfeatures2d::PCTSignatures::create(initSamplingPoints, initClusterSeedIndexes));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "PCTSignatures_create");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_xfeatures2d_PCTSignatures_drawSignature(const Napi::CallbackInfo &info)
{
    using namespace cv::xfeatures2d;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_source = NULL;
    Mat source;
    Napi::Value* jsobj_signature = NULL;
    Mat signature;
    Napi::Value* jsobj_result = NULL;
    Mat result;
    Napi::Value* jsobj_radiusToShorterSideRatio = NULL;
    float radiusToShorterSideRatio=1.0 / 8;
    Napi::Value* jsobj_borderThickness = NULL;
    int borderThickness=1;

    const char* keywords[] = { "source", "signature", "result", "radiusToShorterSideRatio", "borderThickness", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOO:PCTSignatures_drawSignature", (char**)keywords, &jsobj_source, &jsobj_signature, &jsobj_result, &jsobj_radiusToShorterSideRatio, &jsobj_borderThickness) &&
        jsopencv_to_safe(jsobj_source, source, ArgInfo("source", 0)) &&
        jsopencv_to_safe(jsobj_signature, signature, ArgInfo("signature", 0)) &&
        jsopencv_to_safe(jsobj_result, result, ArgInfo("result", 1)) &&
        jsopencv_to_safe(jsobj_radiusToShorterSideRatio, radiusToShorterSideRatio, ArgInfo("radiusToShorterSideRatio", 0)) &&
        jsopencv_to_safe(jsobj_borderThickness, borderThickness, ArgInfo("borderThickness", 0)))
    {
        ERRWRAP2_NAPI(info, cv::xfeatures2d::PCTSignatures::drawSignature(source, signature, result, radiusToShorterSideRatio, borderThickness));
        return jsopencv_from(info, result);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_source = NULL;
    UMat source;
    Napi::Value* jsobj_signature = NULL;
    UMat signature;
    Napi::Value* jsobj_result = NULL;
    UMat result;
    Napi::Value* jsobj_radiusToShorterSideRatio = NULL;
    float radiusToShorterSideRatio=1.0 / 8;
    Napi::Value* jsobj_borderThickness = NULL;
    int borderThickness=1;

    const char* keywords[] = { "source", "signature", "result", "radiusToShorterSideRatio", "borderThickness", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOO:PCTSignatures_drawSignature", (char**)keywords, &jsobj_source, &jsobj_signature, &jsobj_result, &jsobj_radiusToShorterSideRatio, &jsobj_borderThickness) &&
        jsopencv_to_safe(jsobj_source, source, ArgInfo("source", 0)) &&
        jsopencv_to_safe(jsobj_signature, signature, ArgInfo("signature", 0)) &&
        jsopencv_to_safe(jsobj_result, result, ArgInfo("result", 1)) &&
        jsopencv_to_safe(jsobj_radiusToShorterSideRatio, radiusToShorterSideRatio, ArgInfo("radiusToShorterSideRatio", 0)) &&
        jsopencv_to_safe(jsobj_borderThickness, borderThickness, ArgInfo("borderThickness", 0)))
    {
        ERRWRAP2_NAPI(info, cv::xfeatures2d::PCTSignatures::drawSignature(source, signature, result, radiusToShorterSideRatio, borderThickness));
        return jsopencv_from(info, result);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "PCTSignatures_drawSignature");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_xfeatures2d_PCTSignatures_generateInitPoints(const Napi::CallbackInfo &info)
{
    using namespace cv::xfeatures2d;

    Napi::Value* jsobj_initPoints = NULL;
    vector_Point2f initPoints;
    Napi::Value* jsobj_count = NULL;
    int count=0;
    Napi::Value* jsobj_pointDistribution = NULL;
    int pointDistribution=0;

    const char* keywords[] = { "initPoints", "count", "pointDistribution", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:PCTSignatures_generateInitPoints", (char**)keywords, &jsobj_initPoints, &jsobj_count, &jsobj_pointDistribution) &&
        jsopencv_to_safe(jsobj_initPoints, initPoints, ArgInfo("initPoints", 0)) &&
        jsopencv_to_safe(jsobj_count, count, ArgInfo("count", 0)) &&
        jsopencv_to_safe(jsobj_pointDistribution, pointDistribution, ArgInfo("pointDistribution", 0)))
    {
        ERRWRAP2_NAPI(info, cv::xfeatures2d::PCTSignatures::generateInitPoints(initPoints, count, pointDistribution));
        return info.Env().Null();;
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_xfeatures2d_SIFT_create(const Napi::CallbackInfo &info)
{
    using namespace cv::xfeatures2d;

    Napi::Value* jsobj_nfeatures = NULL;
    int nfeatures=0;
    Napi::Value* jsobj_nOctaveLayers = NULL;
    int nOctaveLayers=3;
    Napi::Value* jsobj_contrastThreshold = NULL;
    double contrastThreshold=0.04;
    Napi::Value* jsobj_edgeThreshold = NULL;
    double edgeThreshold=10;
    Napi::Value* jsobj_sigma = NULL;
    double sigma=1.6;
    Ptr<cv::SIFT> retval;

    const char* keywords[] = { "nfeatures", "nOctaveLayers", "contrastThreshold", "edgeThreshold", "sigma", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OOOOO:SIFT_create", (char**)keywords, &jsobj_nfeatures, &jsobj_nOctaveLayers, &jsobj_contrastThreshold, &jsobj_edgeThreshold, &jsobj_sigma) &&
        jsopencv_to_safe(jsobj_nfeatures, nfeatures, ArgInfo("nfeatures", 0)) &&
        jsopencv_to_safe(jsobj_nOctaveLayers, nOctaveLayers, ArgInfo("nOctaveLayers", 0)) &&
        jsopencv_to_safe(jsobj_contrastThreshold, contrastThreshold, ArgInfo("contrastThreshold", 0)) &&
        jsopencv_to_safe(jsobj_edgeThreshold, edgeThreshold, ArgInfo("edgeThreshold", 0)) &&
        jsopencv_to_safe(jsobj_sigma, sigma, ArgInfo("sigma", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::xfeatures2d::SIFT_create(nfeatures, nOctaveLayers, contrastThreshold, edgeThreshold, sigma));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_xfeatures2d_SURF_create(const Napi::CallbackInfo &info)
{
    using namespace cv::xfeatures2d;

    Napi::Value* jsobj_hessianThreshold = NULL;
    double hessianThreshold=100;
    Napi::Value* jsobj_nOctaves = NULL;
    int nOctaves=4;
    Napi::Value* jsobj_nOctaveLayers = NULL;
    int nOctaveLayers=3;
    Napi::Value* jsobj_extended = NULL;
    bool extended=false;
    Napi::Value* jsobj_upright = NULL;
    bool upright=false;
    Ptr<SURF> retval;

    const char* keywords[] = { "hessianThreshold", "nOctaves", "nOctaveLayers", "extended", "upright", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OOOOO:SURF_create", (char**)keywords, &jsobj_hessianThreshold, &jsobj_nOctaves, &jsobj_nOctaveLayers, &jsobj_extended, &jsobj_upright) &&
        jsopencv_to_safe(jsobj_hessianThreshold, hessianThreshold, ArgInfo("hessianThreshold", 0)) &&
        jsopencv_to_safe(jsobj_nOctaves, nOctaves, ArgInfo("nOctaves", 0)) &&
        jsopencv_to_safe(jsobj_nOctaveLayers, nOctaveLayers, ArgInfo("nOctaveLayers", 0)) &&
        jsopencv_to_safe(jsobj_extended, extended, ArgInfo("extended", 0)) &&
        jsopencv_to_safe(jsobj_upright, upright, ArgInfo("upright", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::xfeatures2d::SURF::create(hessianThreshold, nOctaves, nOctaveLayers, extended, upright));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_xfeatures2d_StarDetector_create(const Napi::CallbackInfo &info)
{
    using namespace cv::xfeatures2d;

    Napi::Value* jsobj_maxSize = NULL;
    int maxSize=45;
    Napi::Value* jsobj_responseThreshold = NULL;
    int responseThreshold=30;
    Napi::Value* jsobj_lineThresholdProjected = NULL;
    int lineThresholdProjected=10;
    Napi::Value* jsobj_lineThresholdBinarized = NULL;
    int lineThresholdBinarized=8;
    Napi::Value* jsobj_suppressNonmaxSize = NULL;
    int suppressNonmaxSize=5;
    Ptr<StarDetector> retval;

    const char* keywords[] = { "maxSize", "responseThreshold", "lineThresholdProjected", "lineThresholdBinarized", "suppressNonmaxSize", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OOOOO:StarDetector_create", (char**)keywords, &jsobj_maxSize, &jsobj_responseThreshold, &jsobj_lineThresholdProjected, &jsobj_lineThresholdBinarized, &jsobj_suppressNonmaxSize) &&
        jsopencv_to_safe(jsobj_maxSize, maxSize, ArgInfo("maxSize", 0)) &&
        jsopencv_to_safe(jsobj_responseThreshold, responseThreshold, ArgInfo("responseThreshold", 0)) &&
        jsopencv_to_safe(jsobj_lineThresholdProjected, lineThresholdProjected, ArgInfo("lineThresholdProjected", 0)) &&
        jsopencv_to_safe(jsobj_lineThresholdBinarized, lineThresholdBinarized, ArgInfo("lineThresholdBinarized", 0)) &&
        jsopencv_to_safe(jsobj_suppressNonmaxSize, suppressNonmaxSize, ArgInfo("suppressNonmaxSize", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::xfeatures2d::StarDetector::create(maxSize, responseThreshold, lineThresholdProjected, lineThresholdBinarized, suppressNonmaxSize));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_xfeatures2d_TBMR_create(const Napi::CallbackInfo &info)
{
    using namespace cv::xfeatures2d;

    Napi::Value* jsobj_min_area = NULL;
    int min_area=60;
    Napi::Value* jsobj_max_area_relative = NULL;
    float max_area_relative=0.01f;
    Napi::Value* jsobj_scale_factor = NULL;
    float scale_factor=1.25f;
    Napi::Value* jsobj_n_scales = NULL;
    int n_scales=-1;
    Ptr<TBMR> retval;

    const char* keywords[] = { "min_area", "max_area_relative", "scale_factor", "n_scales", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OOOO:TBMR_create", (char**)keywords, &jsobj_min_area, &jsobj_max_area_relative, &jsobj_scale_factor, &jsobj_n_scales) &&
        jsopencv_to_safe(jsobj_min_area, min_area, ArgInfo("min_area", 0)) &&
        jsopencv_to_safe(jsobj_max_area_relative, max_area_relative, ArgInfo("max_area_relative", 0)) &&
        jsopencv_to_safe(jsobj_scale_factor, scale_factor, ArgInfo("scale_factor", 0)) &&
        jsopencv_to_safe(jsobj_n_scales, n_scales, ArgInfo("n_scales", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::xfeatures2d::TBMR::create(min_area, max_area_relative, scale_factor, n_scales));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_xfeatures2d_TEBLID_create(const Napi::CallbackInfo &info)
{
    using namespace cv::xfeatures2d;

    Napi::Value* jsobj_scale_factor = NULL;
    float scale_factor=0.f;
    Napi::Value* jsobj_n_bits = NULL;
    int n_bits=TEBLID::SIZE_256_BITS;
    Ptr<TEBLID> retval;

    const char* keywords[] = { "scale_factor", "n_bits", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:TEBLID_create", (char**)keywords, &jsobj_scale_factor, &jsobj_n_bits) &&
        jsopencv_to_safe(jsobj_scale_factor, scale_factor, ArgInfo("scale_factor", 0)) &&
        jsopencv_to_safe(jsobj_n_bits, n_bits, ArgInfo("n_bits", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::xfeatures2d::TEBLID::create(scale_factor, n_bits));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_xfeatures2d_VGG_create(const Napi::CallbackInfo &info)
{
    using namespace cv::xfeatures2d;

    Napi::Value* jsobj_desc = NULL;
    int desc=VGG::VGG_120;
    Napi::Value* jsobj_isigma = NULL;
    float isigma=1.4f;
    Napi::Value* jsobj_img_normalize = NULL;
    bool img_normalize=true;
    Napi::Value* jsobj_use_scale_orientation = NULL;
    bool use_scale_orientation=true;
    Napi::Value* jsobj_scale_factor = NULL;
    float scale_factor=6.25f;
    Napi::Value* jsobj_dsc_normalize = NULL;
    bool dsc_normalize=false;
    Ptr<VGG> retval;

    const char* keywords[] = { "desc", "isigma", "img_normalize", "use_scale_orientation", "scale_factor", "dsc_normalize", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OOOOOO:VGG_create", (char**)keywords, &jsobj_desc, &jsobj_isigma, &jsobj_img_normalize, &jsobj_use_scale_orientation, &jsobj_scale_factor, &jsobj_dsc_normalize) &&
        jsopencv_to_safe(jsobj_desc, desc, ArgInfo("desc", 0)) &&
        jsopencv_to_safe(jsobj_isigma, isigma, ArgInfo("isigma", 0)) &&
        jsopencv_to_safe(jsobj_img_normalize, img_normalize, ArgInfo("img_normalize", 0)) &&
        jsopencv_to_safe(jsobj_use_scale_orientation, use_scale_orientation, ArgInfo("use_scale_orientation", 0)) &&
        jsopencv_to_safe(jsobj_scale_factor, scale_factor, ArgInfo("scale_factor", 0)) &&
        jsopencv_to_safe(jsobj_dsc_normalize, dsc_normalize, ArgInfo("dsc_normalize", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::xfeatures2d::VGG::create(desc, isigma, img_normalize, use_scale_orientation, scale_factor, dsc_normalize));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_xfeatures2d_matchGMS(const Napi::CallbackInfo &info)
{
    using namespace cv::xfeatures2d;

    Napi::Value* jsobj_size1 = NULL;
    Size size1;
    Napi::Value* jsobj_size2 = NULL;
    Size size2;
    Napi::Value* jsobj_keypoints1 = NULL;
    vector_KeyPoint keypoints1;
    Napi::Value* jsobj_keypoints2 = NULL;
    vector_KeyPoint keypoints2;
    Napi::Value* jsobj_matches1to2 = NULL;
    vector_DMatch matches1to2;
    vector_DMatch matchesGMS;
    Napi::Value* jsobj_withRotation = NULL;
    bool withRotation=false;
    Napi::Value* jsobj_withScale = NULL;
    bool withScale=false;
    Napi::Value* jsobj_thresholdFactor = NULL;
    double thresholdFactor=6.0;

    const char* keywords[] = { "size1", "size2", "keypoints1", "keypoints2", "matches1to2", "withRotation", "withScale", "thresholdFactor", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOO|OOO:matchGMS", (char**)keywords, &jsobj_size1, &jsobj_size2, &jsobj_keypoints1, &jsobj_keypoints2, &jsobj_matches1to2, &jsobj_withRotation, &jsobj_withScale, &jsobj_thresholdFactor) &&
        jsopencv_to_safe(jsobj_size1, size1, ArgInfo("size1", 0)) &&
        jsopencv_to_safe(jsobj_size2, size2, ArgInfo("size2", 0)) &&
        jsopencv_to_safe(jsobj_keypoints1, keypoints1, ArgInfo("keypoints1", 0)) &&
        jsopencv_to_safe(jsobj_keypoints2, keypoints2, ArgInfo("keypoints2", 0)) &&
        jsopencv_to_safe(jsobj_matches1to2, matches1to2, ArgInfo("matches1to2", 0)) &&
        jsopencv_to_safe(jsobj_withRotation, withRotation, ArgInfo("withRotation", 0)) &&
        jsopencv_to_safe(jsobj_withScale, withScale, ArgInfo("withScale", 0)) &&
        jsopencv_to_safe(jsobj_thresholdFactor, thresholdFactor, ArgInfo("thresholdFactor", 0)))
    {
        ERRWRAP2_NAPI(info, cv::xfeatures2d::matchGMS(size1, size2, keypoints1, keypoints2, matches1to2, matchesGMS, withRotation, withScale, thresholdFactor));
        return jsopencv_from(info, matchesGMS);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_xfeatures2d_matchLOGOS(const Napi::CallbackInfo &info)
{
    using namespace cv::xfeatures2d;

    Napi::Value* jsobj_keypoints1 = NULL;
    vector_KeyPoint keypoints1;
    Napi::Value* jsobj_keypoints2 = NULL;
    vector_KeyPoint keypoints2;
    Napi::Value* jsobj_nn1 = NULL;
    vector_int nn1;
    Napi::Value* jsobj_nn2 = NULL;
    vector_int nn2;
    Napi::Value* jsobj_matches1to2 = NULL;
    vector_DMatch matches1to2;

    const char* keywords[] = { "keypoints1", "keypoints2", "nn1", "nn2", "matches1to2", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOO:matchLOGOS", (char**)keywords, &jsobj_keypoints1, &jsobj_keypoints2, &jsobj_nn1, &jsobj_nn2, &jsobj_matches1to2) &&
        jsopencv_to_safe(jsobj_keypoints1, keypoints1, ArgInfo("keypoints1", 0)) &&
        jsopencv_to_safe(jsobj_keypoints2, keypoints2, ArgInfo("keypoints2", 0)) &&
        jsopencv_to_safe(jsobj_nn1, nn1, ArgInfo("nn1", 0)) &&
        jsopencv_to_safe(jsobj_nn2, nn2, ArgInfo("nn2", 0)) &&
        jsopencv_to_safe(jsobj_matches1to2, matches1to2, ArgInfo("matches1to2", 0)))
    {
        ERRWRAP2_NAPI(info, cv::xfeatures2d::matchLOGOS(keypoints1, keypoints2, nn1, nn2, matches1to2));
        return info.Env().Null();;
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_AdaptiveManifoldFilter_create(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    Ptr<AdaptiveManifoldFilter> retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::ximgproc::AdaptiveManifoldFilter::create());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_FastHoughTransform(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_dstMatDepth = NULL;
    int dstMatDepth=0;
    Napi::Value* jsobj_angleRange = NULL;
    int angleRange=ARO_315_135;
    Napi::Value* jsobj_op = NULL;
    int op=FHT_ADD;
    Napi::Value* jsobj_makeSkew = NULL;
    int makeSkew=HDO_DESKEW;

    const char* keywords[] = { "src", "dstMatDepth", "dst", "angleRange", "op", "makeSkew", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOOO:FastHoughTransform", (char**)keywords, &jsobj_src, &jsobj_dstMatDepth, &jsobj_dst, &jsobj_angleRange, &jsobj_op, &jsobj_makeSkew) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_dstMatDepth, dstMatDepth, ArgInfo("dstMatDepth", 0)) &&
        jsopencv_to_safe(jsobj_angleRange, angleRange, ArgInfo("angleRange", 0)) &&
        jsopencv_to_safe(jsobj_op, op, ArgInfo("op", 0)) &&
        jsopencv_to_safe(jsobj_makeSkew, makeSkew, ArgInfo("makeSkew", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::FastHoughTransform(src, dst, dstMatDepth, angleRange, op, makeSkew));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_dstMatDepth = NULL;
    int dstMatDepth=0;
    Napi::Value* jsobj_angleRange = NULL;
    int angleRange=ARO_315_135;
    Napi::Value* jsobj_op = NULL;
    int op=FHT_ADD;
    Napi::Value* jsobj_makeSkew = NULL;
    int makeSkew=HDO_DESKEW;

    const char* keywords[] = { "src", "dstMatDepth", "dst", "angleRange", "op", "makeSkew", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOOO:FastHoughTransform", (char**)keywords, &jsobj_src, &jsobj_dstMatDepth, &jsobj_dst, &jsobj_angleRange, &jsobj_op, &jsobj_makeSkew) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_dstMatDepth, dstMatDepth, ArgInfo("dstMatDepth", 0)) &&
        jsopencv_to_safe(jsobj_angleRange, angleRange, ArgInfo("angleRange", 0)) &&
        jsopencv_to_safe(jsobj_op, op, ArgInfo("op", 0)) &&
        jsopencv_to_safe(jsobj_makeSkew, makeSkew, ArgInfo("makeSkew", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::FastHoughTransform(src, dst, dstMatDepth, angleRange, op, makeSkew));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "FastHoughTransform");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_GradientDericheX(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_op = NULL;
    Mat op;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_alpha = NULL;
    double alpha=0;
    Napi::Value* jsobj_omega = NULL;
    double omega=0;

    const char* keywords[] = { "op", "alpha", "omega", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:GradientDericheX", (char**)keywords, &jsobj_op, &jsobj_alpha, &jsobj_omega, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_op, op, ArgInfo("op", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_alpha, alpha, ArgInfo("alpha", 0)) &&
        jsopencv_to_safe(jsobj_omega, omega, ArgInfo("omega", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::GradientDericheX(op, dst, alpha, omega));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_op = NULL;
    UMat op;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_alpha = NULL;
    double alpha=0;
    Napi::Value* jsobj_omega = NULL;
    double omega=0;

    const char* keywords[] = { "op", "alpha", "omega", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:GradientDericheX", (char**)keywords, &jsobj_op, &jsobj_alpha, &jsobj_omega, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_op, op, ArgInfo("op", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_alpha, alpha, ArgInfo("alpha", 0)) &&
        jsopencv_to_safe(jsobj_omega, omega, ArgInfo("omega", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::GradientDericheX(op, dst, alpha, omega));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "GradientDericheX");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_GradientDericheY(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_op = NULL;
    Mat op;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_alpha = NULL;
    double alpha=0;
    Napi::Value* jsobj_omega = NULL;
    double omega=0;

    const char* keywords[] = { "op", "alpha", "omega", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:GradientDericheY", (char**)keywords, &jsobj_op, &jsobj_alpha, &jsobj_omega, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_op, op, ArgInfo("op", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_alpha, alpha, ArgInfo("alpha", 0)) &&
        jsopencv_to_safe(jsobj_omega, omega, ArgInfo("omega", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::GradientDericheY(op, dst, alpha, omega));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_op = NULL;
    UMat op;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_alpha = NULL;
    double alpha=0;
    Napi::Value* jsobj_omega = NULL;
    double omega=0;

    const char* keywords[] = { "op", "alpha", "omega", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:GradientDericheY", (char**)keywords, &jsobj_op, &jsobj_alpha, &jsobj_omega, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_op, op, ArgInfo("op", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_alpha, alpha, ArgInfo("alpha", 0)) &&
        jsopencv_to_safe(jsobj_omega, omega, ArgInfo("omega", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::GradientDericheY(op, dst, alpha, omega));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "GradientDericheY");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_HoughPoint2Line(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_houghPoint = NULL;
    Point houghPoint;
    Napi::Value* jsobj_srcImgInfo = NULL;
    Mat srcImgInfo;
    Napi::Value* jsobj_angleRange = NULL;
    int angleRange=ARO_315_135;
    Napi::Value* jsobj_makeSkew = NULL;
    int makeSkew=HDO_DESKEW;
    Napi::Value* jsobj_rules = NULL;
    int rules=RO_IGNORE_BORDERS;
    Vec4i retval;

    const char* keywords[] = { "houghPoint", "srcImgInfo", "angleRange", "makeSkew", "rules", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOO:HoughPoint2Line", (char**)keywords, &jsobj_houghPoint, &jsobj_srcImgInfo, &jsobj_angleRange, &jsobj_makeSkew, &jsobj_rules) &&
        jsopencv_to_safe(jsobj_houghPoint, houghPoint, ArgInfo("houghPoint", 0)) &&
        jsopencv_to_safe(jsobj_srcImgInfo, srcImgInfo, ArgInfo("srcImgInfo", 0)) &&
        jsopencv_to_safe(jsobj_angleRange, angleRange, ArgInfo("angleRange", 0)) &&
        jsopencv_to_safe(jsobj_makeSkew, makeSkew, ArgInfo("makeSkew", 0)) &&
        jsopencv_to_safe(jsobj_rules, rules, ArgInfo("rules", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ximgproc::HoughPoint2Line(houghPoint, srcImgInfo, angleRange, makeSkew, rules));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_houghPoint = NULL;
    Point houghPoint;
    Napi::Value* jsobj_srcImgInfo = NULL;
    UMat srcImgInfo;
    Napi::Value* jsobj_angleRange = NULL;
    int angleRange=ARO_315_135;
    Napi::Value* jsobj_makeSkew = NULL;
    int makeSkew=HDO_DESKEW;
    Napi::Value* jsobj_rules = NULL;
    int rules=RO_IGNORE_BORDERS;
    Vec4i retval;

    const char* keywords[] = { "houghPoint", "srcImgInfo", "angleRange", "makeSkew", "rules", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OOO:HoughPoint2Line", (char**)keywords, &jsobj_houghPoint, &jsobj_srcImgInfo, &jsobj_angleRange, &jsobj_makeSkew, &jsobj_rules) &&
        jsopencv_to_safe(jsobj_houghPoint, houghPoint, ArgInfo("houghPoint", 0)) &&
        jsopencv_to_safe(jsobj_srcImgInfo, srcImgInfo, ArgInfo("srcImgInfo", 0)) &&
        jsopencv_to_safe(jsobj_angleRange, angleRange, ArgInfo("angleRange", 0)) &&
        jsopencv_to_safe(jsobj_makeSkew, makeSkew, ArgInfo("makeSkew", 0)) &&
        jsopencv_to_safe(jsobj_rules, rules, ArgInfo("rules", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ximgproc::HoughPoint2Line(houghPoint, srcImgInfo, angleRange, makeSkew, rules));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "HoughPoint2Line");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_PeiLinNormalization(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_I = NULL;
    Mat I;
    Napi::Value* jsobj_T = NULL;
    Mat T;

    const char* keywords[] = { "I", "T", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:PeiLinNormalization", (char**)keywords, &jsobj_I, &jsobj_T) &&
        jsopencv_to_safe(jsobj_I, I, ArgInfo("I", 0)) &&
        jsopencv_to_safe(jsobj_T, T, ArgInfo("T", 1)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::PeiLinNormalization(I, T));
        return jsopencv_from(info, T);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_I = NULL;
    UMat I;
    Napi::Value* jsobj_T = NULL;
    UMat T;

    const char* keywords[] = { "I", "T", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:PeiLinNormalization", (char**)keywords, &jsobj_I, &jsobj_T) &&
        jsopencv_to_safe(jsobj_I, I, ArgInfo("I", 0)) &&
        jsopencv_to_safe(jsobj_T, T, ArgInfo("T", 1)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::PeiLinNormalization(I, T));
        return jsopencv_from(info, T);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "PeiLinNormalization");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_RadonTransform(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_theta = NULL;
    double theta=1;
    Napi::Value* jsobj_start_angle = NULL;
    double start_angle=0;
    Napi::Value* jsobj_end_angle = NULL;
    double end_angle=180;
    Napi::Value* jsobj_crop = NULL;
    bool crop=false;
    Napi::Value* jsobj_norm = NULL;
    bool norm=false;

    const char* keywords[] = { "src", "dst", "theta", "start_angle", "end_angle", "crop", "norm", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOOOOO:RadonTransform", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_theta, &jsobj_start_angle, &jsobj_end_angle, &jsobj_crop, &jsobj_norm) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_theta, theta, ArgInfo("theta", 0)) &&
        jsopencv_to_safe(jsobj_start_angle, start_angle, ArgInfo("start_angle", 0)) &&
        jsopencv_to_safe(jsobj_end_angle, end_angle, ArgInfo("end_angle", 0)) &&
        jsopencv_to_safe(jsobj_crop, crop, ArgInfo("crop", 0)) &&
        jsopencv_to_safe(jsobj_norm, norm, ArgInfo("norm", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::RadonTransform(src, dst, theta, start_angle, end_angle, crop, norm));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_theta = NULL;
    double theta=1;
    Napi::Value* jsobj_start_angle = NULL;
    double start_angle=0;
    Napi::Value* jsobj_end_angle = NULL;
    double end_angle=180;
    Napi::Value* jsobj_crop = NULL;
    bool crop=false;
    Napi::Value* jsobj_norm = NULL;
    bool norm=false;

    const char* keywords[] = { "src", "dst", "theta", "start_angle", "end_angle", "crop", "norm", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOOOOO:RadonTransform", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_theta, &jsobj_start_angle, &jsobj_end_angle, &jsobj_crop, &jsobj_norm) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_theta, theta, ArgInfo("theta", 0)) &&
        jsopencv_to_safe(jsobj_start_angle, start_angle, ArgInfo("start_angle", 0)) &&
        jsopencv_to_safe(jsobj_end_angle, end_angle, ArgInfo("end_angle", 0)) &&
        jsopencv_to_safe(jsobj_crop, crop, ArgInfo("crop", 0)) &&
        jsopencv_to_safe(jsobj_norm, norm, ArgInfo("norm", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::RadonTransform(src, dst, theta, start_angle, end_angle, crop, norm));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "RadonTransform");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_RidgeDetectionFilter_create(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    Napi::Value* jsobj_ddepth = NULL;
    int ddepth=CV_32FC1;
    Napi::Value* jsobj_dx = NULL;
    int dx=1;
    Napi::Value* jsobj_dy = NULL;
    int dy=1;
    Napi::Value* jsobj_ksize = NULL;
    int ksize=3;
    Napi::Value* jsobj_out_dtype = NULL;
    int out_dtype=CV_8UC1;
    Napi::Value* jsobj_scale = NULL;
    double scale=1;
    Napi::Value* jsobj_delta = NULL;
    double delta=0;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_DEFAULT;
    Ptr<RidgeDetectionFilter> retval;

    const char* keywords[] = { "ddepth", "dx", "dy", "ksize", "out_dtype", "scale", "delta", "borderType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OOOOOOOO:RidgeDetectionFilter_create", (char**)keywords, &jsobj_ddepth, &jsobj_dx, &jsobj_dy, &jsobj_ksize, &jsobj_out_dtype, &jsobj_scale, &jsobj_delta, &jsobj_borderType) &&
        jsopencv_to_safe(jsobj_ddepth, ddepth, ArgInfo("ddepth", 0)) &&
        jsopencv_to_safe(jsobj_dx, dx, ArgInfo("dx", 0)) &&
        jsopencv_to_safe(jsobj_dy, dy, ArgInfo("dy", 0)) &&
        jsopencv_to_safe(jsobj_ksize, ksize, ArgInfo("ksize", 0)) &&
        jsopencv_to_safe(jsobj_out_dtype, out_dtype, ArgInfo("out_dtype", 0)) &&
        jsopencv_to_safe(jsobj_scale, scale, ArgInfo("scale", 0)) &&
        jsopencv_to_safe(jsobj_delta, delta, ArgInfo("delta", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ximgproc::RidgeDetectionFilter::create(ddepth, dx, dy, ksize, out_dtype, scale, delta, borderType));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_amFilter(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_joint = NULL;
    Mat joint;
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_sigma_s = NULL;
    double sigma_s=0;
    Napi::Value* jsobj_sigma_r = NULL;
    double sigma_r=0;
    Napi::Value* jsobj_adjust_outliers = NULL;
    bool adjust_outliers=false;

    const char* keywords[] = { "joint", "src", "sigma_s", "sigma_r", "dst", "adjust_outliers", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OO:amFilter", (char**)keywords, &jsobj_joint, &jsobj_src, &jsobj_sigma_s, &jsobj_sigma_r, &jsobj_dst, &jsobj_adjust_outliers) &&
        jsopencv_to_safe(jsobj_joint, joint, ArgInfo("joint", 0)) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_sigma_s, sigma_s, ArgInfo("sigma_s", 0)) &&
        jsopencv_to_safe(jsobj_sigma_r, sigma_r, ArgInfo("sigma_r", 0)) &&
        jsopencv_to_safe(jsobj_adjust_outliers, adjust_outliers, ArgInfo("adjust_outliers", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::amFilter(joint, src, dst, sigma_s, sigma_r, adjust_outliers));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_joint = NULL;
    UMat joint;
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_sigma_s = NULL;
    double sigma_s=0;
    Napi::Value* jsobj_sigma_r = NULL;
    double sigma_r=0;
    Napi::Value* jsobj_adjust_outliers = NULL;
    bool adjust_outliers=false;

    const char* keywords[] = { "joint", "src", "sigma_s", "sigma_r", "dst", "adjust_outliers", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OO:amFilter", (char**)keywords, &jsobj_joint, &jsobj_src, &jsobj_sigma_s, &jsobj_sigma_r, &jsobj_dst, &jsobj_adjust_outliers) &&
        jsopencv_to_safe(jsobj_joint, joint, ArgInfo("joint", 0)) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_sigma_s, sigma_s, ArgInfo("sigma_s", 0)) &&
        jsopencv_to_safe(jsobj_sigma_r, sigma_r, ArgInfo("sigma_r", 0)) &&
        jsopencv_to_safe(jsobj_adjust_outliers, adjust_outliers, ArgInfo("adjust_outliers", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::amFilter(joint, src, dst, sigma_s, sigma_r, adjust_outliers));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "amFilter");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_anisotropicDiffusion(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_alpha = NULL;
    float alpha=0.f;
    Napi::Value* jsobj_K = NULL;
    float K=0.f;
    Napi::Value* jsobj_niters = NULL;
    int niters=0;

    const char* keywords[] = { "src", "alpha", "K", "niters", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|O:anisotropicDiffusion", (char**)keywords, &jsobj_src, &jsobj_alpha, &jsobj_K, &jsobj_niters, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_alpha, alpha, ArgInfo("alpha", 0)) &&
        jsopencv_to_safe(jsobj_K, K, ArgInfo("K", 0)) &&
        jsopencv_to_safe(jsobj_niters, niters, ArgInfo("niters", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::anisotropicDiffusion(src, dst, alpha, K, niters));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_alpha = NULL;
    float alpha=0.f;
    Napi::Value* jsobj_K = NULL;
    float K=0.f;
    Napi::Value* jsobj_niters = NULL;
    int niters=0;

    const char* keywords[] = { "src", "alpha", "K", "niters", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|O:anisotropicDiffusion", (char**)keywords, &jsobj_src, &jsobj_alpha, &jsobj_K, &jsobj_niters, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_alpha, alpha, ArgInfo("alpha", 0)) &&
        jsopencv_to_safe(jsobj_K, K, ArgInfo("K", 0)) &&
        jsopencv_to_safe(jsobj_niters, niters, ArgInfo("niters", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::anisotropicDiffusion(src, dst, alpha, K, niters));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "anisotropicDiffusion");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_bilateralTextureFilter(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_fr = NULL;
    int fr=3;
    Napi::Value* jsobj_numIter = NULL;
    int numIter=1;
    Napi::Value* jsobj_sigmaAlpha = NULL;
    double sigmaAlpha=-1.;
    Napi::Value* jsobj_sigmaAvg = NULL;
    double sigmaAvg=-1.;

    const char* keywords[] = { "src", "dst", "fr", "numIter", "sigmaAlpha", "sigmaAvg", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOOOO:bilateralTextureFilter", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_fr, &jsobj_numIter, &jsobj_sigmaAlpha, &jsobj_sigmaAvg) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_fr, fr, ArgInfo("fr", 0)) &&
        jsopencv_to_safe(jsobj_numIter, numIter, ArgInfo("numIter", 0)) &&
        jsopencv_to_safe(jsobj_sigmaAlpha, sigmaAlpha, ArgInfo("sigmaAlpha", 0)) &&
        jsopencv_to_safe(jsobj_sigmaAvg, sigmaAvg, ArgInfo("sigmaAvg", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::bilateralTextureFilter(src, dst, fr, numIter, sigmaAlpha, sigmaAvg));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_fr = NULL;
    int fr=3;
    Napi::Value* jsobj_numIter = NULL;
    int numIter=1;
    Napi::Value* jsobj_sigmaAlpha = NULL;
    double sigmaAlpha=-1.;
    Napi::Value* jsobj_sigmaAvg = NULL;
    double sigmaAvg=-1.;

    const char* keywords[] = { "src", "dst", "fr", "numIter", "sigmaAlpha", "sigmaAvg", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOOOO:bilateralTextureFilter", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_fr, &jsobj_numIter, &jsobj_sigmaAlpha, &jsobj_sigmaAvg) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_fr, fr, ArgInfo("fr", 0)) &&
        jsopencv_to_safe(jsobj_numIter, numIter, ArgInfo("numIter", 0)) &&
        jsopencv_to_safe(jsobj_sigmaAlpha, sigmaAlpha, ArgInfo("sigmaAlpha", 0)) &&
        jsopencv_to_safe(jsobj_sigmaAvg, sigmaAvg, ArgInfo("sigmaAvg", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::bilateralTextureFilter(src, dst, fr, numIter, sigmaAlpha, sigmaAvg));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "bilateralTextureFilter");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_colorMatchTemplate(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_img = NULL;
    Mat img;
    Napi::Value* jsobj_templ = NULL;
    Mat templ;
    Napi::Value* jsobj_result = NULL;
    Mat result;

    const char* keywords[] = { "img", "templ", "result", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:colorMatchTemplate", (char**)keywords, &jsobj_img, &jsobj_templ, &jsobj_result) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 0)) &&
        jsopencv_to_safe(jsobj_templ, templ, ArgInfo("templ", 0)) &&
        jsopencv_to_safe(jsobj_result, result, ArgInfo("result", 1)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::colorMatchTemplate(img, templ, result));
        return jsopencv_from(info, result);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_img = NULL;
    UMat img;
    Napi::Value* jsobj_templ = NULL;
    UMat templ;
    Napi::Value* jsobj_result = NULL;
    UMat result;

    const char* keywords[] = { "img", "templ", "result", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:colorMatchTemplate", (char**)keywords, &jsobj_img, &jsobj_templ, &jsobj_result) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 0)) &&
        jsopencv_to_safe(jsobj_templ, templ, ArgInfo("templ", 0)) &&
        jsopencv_to_safe(jsobj_result, result, ArgInfo("result", 1)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::colorMatchTemplate(img, templ, result));
        return jsopencv_from(info, result);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "colorMatchTemplate");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_computeBadPixelPercent(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_GT = NULL;
    Mat GT;
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_ROI = NULL;
    Rect ROI;
    Napi::Value* jsobj_thresh = NULL;
    int thresh=24;
    double retval;

    const char* keywords[] = { "GT", "src", "ROI", "thresh", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:computeBadPixelPercent", (char**)keywords, &jsobj_GT, &jsobj_src, &jsobj_ROI, &jsobj_thresh) &&
        jsopencv_to_safe(jsobj_GT, GT, ArgInfo("GT", 0)) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_ROI, ROI, ArgInfo("ROI", 0)) &&
        jsopencv_to_safe(jsobj_thresh, thresh, ArgInfo("thresh", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ximgproc::computeBadPixelPercent(GT, src, ROI, thresh));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_GT = NULL;
    UMat GT;
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_ROI = NULL;
    Rect ROI;
    Napi::Value* jsobj_thresh = NULL;
    int thresh=24;
    double retval;

    const char* keywords[] = { "GT", "src", "ROI", "thresh", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:computeBadPixelPercent", (char**)keywords, &jsobj_GT, &jsobj_src, &jsobj_ROI, &jsobj_thresh) &&
        jsopencv_to_safe(jsobj_GT, GT, ArgInfo("GT", 0)) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_ROI, ROI, ArgInfo("ROI", 0)) &&
        jsopencv_to_safe(jsobj_thresh, thresh, ArgInfo("thresh", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ximgproc::computeBadPixelPercent(GT, src, ROI, thresh));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "computeBadPixelPercent");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_computeMSE(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_GT = NULL;
    Mat GT;
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_ROI = NULL;
    Rect ROI;
    double retval;

    const char* keywords[] = { "GT", "src", "ROI", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:computeMSE", (char**)keywords, &jsobj_GT, &jsobj_src, &jsobj_ROI) &&
        jsopencv_to_safe(jsobj_GT, GT, ArgInfo("GT", 0)) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_ROI, ROI, ArgInfo("ROI", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ximgproc::computeMSE(GT, src, ROI));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_GT = NULL;
    UMat GT;
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_ROI = NULL;
    Rect ROI;
    double retval;

    const char* keywords[] = { "GT", "src", "ROI", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:computeMSE", (char**)keywords, &jsobj_GT, &jsobj_src, &jsobj_ROI) &&
        jsopencv_to_safe(jsobj_GT, GT, ArgInfo("GT", 0)) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_ROI, ROI, ArgInfo("ROI", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ximgproc::computeMSE(GT, src, ROI));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "computeMSE");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_contourSampling(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_out = NULL;
    Mat out;
    Napi::Value* jsobj_nbElt = NULL;
    int nbElt=0;

    const char* keywords[] = { "src", "nbElt", "out", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:contourSampling", (char**)keywords, &jsobj_src, &jsobj_nbElt, &jsobj_out) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_out, out, ArgInfo("out", 1)) &&
        jsopencv_to_safe(jsobj_nbElt, nbElt, ArgInfo("nbElt", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::contourSampling(src, out, nbElt));
        return jsopencv_from(info, out);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_out = NULL;
    UMat out;
    Napi::Value* jsobj_nbElt = NULL;
    int nbElt=0;

    const char* keywords[] = { "src", "nbElt", "out", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:contourSampling", (char**)keywords, &jsobj_src, &jsobj_nbElt, &jsobj_out) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_out, out, ArgInfo("out", 1)) &&
        jsopencv_to_safe(jsobj_nbElt, nbElt, ArgInfo("nbElt", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::contourSampling(src, out, nbElt));
        return jsopencv_from(info, out);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "contourSampling");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_covarianceEstimation(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_windowRows = NULL;
    int windowRows=0;
    Napi::Value* jsobj_windowCols = NULL;
    int windowCols=0;

    const char* keywords[] = { "src", "windowRows", "windowCols", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:covarianceEstimation", (char**)keywords, &jsobj_src, &jsobj_windowRows, &jsobj_windowCols, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_windowRows, windowRows, ArgInfo("windowRows", 0)) &&
        jsopencv_to_safe(jsobj_windowCols, windowCols, ArgInfo("windowCols", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::covarianceEstimation(src, dst, windowRows, windowCols));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_windowRows = NULL;
    int windowRows=0;
    Napi::Value* jsobj_windowCols = NULL;
    int windowCols=0;

    const char* keywords[] = { "src", "windowRows", "windowCols", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:covarianceEstimation", (char**)keywords, &jsobj_src, &jsobj_windowRows, &jsobj_windowCols, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_windowRows, windowRows, ArgInfo("windowRows", 0)) &&
        jsopencv_to_safe(jsobj_windowCols, windowCols, ArgInfo("windowCols", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::covarianceEstimation(src, dst, windowRows, windowCols));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "covarianceEstimation");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_createAMFilter(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    Napi::Value* jsobj_sigma_s = NULL;
    double sigma_s=0;
    Napi::Value* jsobj_sigma_r = NULL;
    double sigma_r=0;
    Napi::Value* jsobj_adjust_outliers = NULL;
    bool adjust_outliers=false;
    Ptr<AdaptiveManifoldFilter> retval;

    const char* keywords[] = { "sigma_s", "sigma_r", "adjust_outliers", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:createAMFilter", (char**)keywords, &jsobj_sigma_s, &jsobj_sigma_r, &jsobj_adjust_outliers) &&
        jsopencv_to_safe(jsobj_sigma_s, sigma_s, ArgInfo("sigma_s", 0)) &&
        jsopencv_to_safe(jsobj_sigma_r, sigma_r, ArgInfo("sigma_r", 0)) &&
        jsopencv_to_safe(jsobj_adjust_outliers, adjust_outliers, ArgInfo("adjust_outliers", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ximgproc::createAMFilter(sigma_s, sigma_r, adjust_outliers));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_createContourFitting(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    Napi::Value* jsobj_ctr = NULL;
    int ctr=1024;
    Napi::Value* jsobj_fd = NULL;
    int fd=16;
    Ptr<ContourFitting> retval;

    const char* keywords[] = { "ctr", "fd", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OO:createContourFitting", (char**)keywords, &jsobj_ctr, &jsobj_fd) &&
        jsopencv_to_safe(jsobj_ctr, ctr, ArgInfo("ctr", 0)) &&
        jsopencv_to_safe(jsobj_fd, fd, ArgInfo("fd", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ximgproc::createContourFitting(ctr, fd));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_createDTFilter(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_guide = NULL;
    Mat guide;
    Napi::Value* jsobj_sigmaSpatial = NULL;
    double sigmaSpatial=0;
    Napi::Value* jsobj_sigmaColor = NULL;
    double sigmaColor=0;
    Napi::Value* jsobj_mode = NULL;
    int mode=DTF_NC;
    Napi::Value* jsobj_numIters = NULL;
    int numIters=3;
    Ptr<DTFilter> retval;

    const char* keywords[] = { "guide", "sigmaSpatial", "sigmaColor", "mode", "numIters", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OO:createDTFilter", (char**)keywords, &jsobj_guide, &jsobj_sigmaSpatial, &jsobj_sigmaColor, &jsobj_mode, &jsobj_numIters) &&
        jsopencv_to_safe(jsobj_guide, guide, ArgInfo("guide", 0)) &&
        jsopencv_to_safe(jsobj_sigmaSpatial, sigmaSpatial, ArgInfo("sigmaSpatial", 0)) &&
        jsopencv_to_safe(jsobj_sigmaColor, sigmaColor, ArgInfo("sigmaColor", 0)) &&
        jsopencv_to_safe(jsobj_mode, mode, ArgInfo("mode", 0)) &&
        jsopencv_to_safe(jsobj_numIters, numIters, ArgInfo("numIters", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ximgproc::createDTFilter(guide, sigmaSpatial, sigmaColor, mode, numIters));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_guide = NULL;
    UMat guide;
    Napi::Value* jsobj_sigmaSpatial = NULL;
    double sigmaSpatial=0;
    Napi::Value* jsobj_sigmaColor = NULL;
    double sigmaColor=0;
    Napi::Value* jsobj_mode = NULL;
    int mode=DTF_NC;
    Napi::Value* jsobj_numIters = NULL;
    int numIters=3;
    Ptr<DTFilter> retval;

    const char* keywords[] = { "guide", "sigmaSpatial", "sigmaColor", "mode", "numIters", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OO:createDTFilter", (char**)keywords, &jsobj_guide, &jsobj_sigmaSpatial, &jsobj_sigmaColor, &jsobj_mode, &jsobj_numIters) &&
        jsopencv_to_safe(jsobj_guide, guide, ArgInfo("guide", 0)) &&
        jsopencv_to_safe(jsobj_sigmaSpatial, sigmaSpatial, ArgInfo("sigmaSpatial", 0)) &&
        jsopencv_to_safe(jsobj_sigmaColor, sigmaColor, ArgInfo("sigmaColor", 0)) &&
        jsopencv_to_safe(jsobj_mode, mode, ArgInfo("mode", 0)) &&
        jsopencv_to_safe(jsobj_numIters, numIters, ArgInfo("numIters", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ximgproc::createDTFilter(guide, sigmaSpatial, sigmaColor, mode, numIters));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "createDTFilter");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_createDisparityWLSFilter(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    Napi::Value* jsobj_matcher_left = NULL;
    Ptr<StereoMatcher> matcher_left;
    Ptr<DisparityWLSFilter> retval;

    const char* keywords[] = { "matcher_left", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:createDisparityWLSFilter", (char**)keywords, &jsobj_matcher_left) &&
        jsopencv_to_safe(jsobj_matcher_left, matcher_left, ArgInfo("matcher_left", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ximgproc::createDisparityWLSFilter(matcher_left));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_createDisparityWLSFilterGeneric(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    Napi::Value* jsobj_use_confidence = NULL;
    bool use_confidence=0;
    Ptr<DisparityWLSFilter> retval;

    const char* keywords[] = { "use_confidence", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:createDisparityWLSFilterGeneric", (char**)keywords, &jsobj_use_confidence) &&
        jsopencv_to_safe(jsobj_use_confidence, use_confidence, ArgInfo("use_confidence", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ximgproc::createDisparityWLSFilterGeneric(use_confidence));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_createEdgeAwareInterpolator(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    Ptr<EdgeAwareInterpolator> retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::ximgproc::createEdgeAwareInterpolator());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_createEdgeBoxes(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    Napi::Value* jsobj_alpha = NULL;
    float alpha=0.65f;
    Napi::Value* jsobj_beta = NULL;
    float beta=0.75f;
    Napi::Value* jsobj_eta = NULL;
    float eta=1;
    Napi::Value* jsobj_minScore = NULL;
    float minScore=0.01f;
    Napi::Value* jsobj_maxBoxes = NULL;
    int maxBoxes=10000;
    Napi::Value* jsobj_edgeMinMag = NULL;
    float edgeMinMag=0.1f;
    Napi::Value* jsobj_edgeMergeThr = NULL;
    float edgeMergeThr=0.5f;
    Napi::Value* jsobj_clusterMinMag = NULL;
    float clusterMinMag=0.5f;
    Napi::Value* jsobj_maxAspectRatio = NULL;
    float maxAspectRatio=3;
    Napi::Value* jsobj_minBoxArea = NULL;
    float minBoxArea=1000;
    Napi::Value* jsobj_gamma = NULL;
    float gamma=2;
    Napi::Value* jsobj_kappa = NULL;
    float kappa=1.5f;
    Ptr<EdgeBoxes> retval;

    const char* keywords[] = { "alpha", "beta", "eta", "minScore", "maxBoxes", "edgeMinMag", "edgeMergeThr", "clusterMinMag", "maxAspectRatio", "minBoxArea", "gamma", "kappa", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OOOOOOOOOOOO:createEdgeBoxes", (char**)keywords, &jsobj_alpha, &jsobj_beta, &jsobj_eta, &jsobj_minScore, &jsobj_maxBoxes, &jsobj_edgeMinMag, &jsobj_edgeMergeThr, &jsobj_clusterMinMag, &jsobj_maxAspectRatio, &jsobj_minBoxArea, &jsobj_gamma, &jsobj_kappa) &&
        jsopencv_to_safe(jsobj_alpha, alpha, ArgInfo("alpha", 0)) &&
        jsopencv_to_safe(jsobj_beta, beta, ArgInfo("beta", 0)) &&
        jsopencv_to_safe(jsobj_eta, eta, ArgInfo("eta", 0)) &&
        jsopencv_to_safe(jsobj_minScore, minScore, ArgInfo("minScore", 0)) &&
        jsopencv_to_safe(jsobj_maxBoxes, maxBoxes, ArgInfo("maxBoxes", 0)) &&
        jsopencv_to_safe(jsobj_edgeMinMag, edgeMinMag, ArgInfo("edgeMinMag", 0)) &&
        jsopencv_to_safe(jsobj_edgeMergeThr, edgeMergeThr, ArgInfo("edgeMergeThr", 0)) &&
        jsopencv_to_safe(jsobj_clusterMinMag, clusterMinMag, ArgInfo("clusterMinMag", 0)) &&
        jsopencv_to_safe(jsobj_maxAspectRatio, maxAspectRatio, ArgInfo("maxAspectRatio", 0)) &&
        jsopencv_to_safe(jsobj_minBoxArea, minBoxArea, ArgInfo("minBoxArea", 0)) &&
        jsopencv_to_safe(jsobj_gamma, gamma, ArgInfo("gamma", 0)) &&
        jsopencv_to_safe(jsobj_kappa, kappa, ArgInfo("kappa", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ximgproc::createEdgeBoxes(alpha, beta, eta, minScore, maxBoxes, edgeMinMag, edgeMergeThr, clusterMinMag, maxAspectRatio, minBoxArea, gamma, kappa));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_createEdgeDrawing(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    Ptr<EdgeDrawing> retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::ximgproc::createEdgeDrawing());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_createFastBilateralSolverFilter(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_guide = NULL;
    Mat guide;
    Napi::Value* jsobj_sigma_spatial = NULL;
    double sigma_spatial=0;
    Napi::Value* jsobj_sigma_luma = NULL;
    double sigma_luma=0;
    Napi::Value* jsobj_sigma_chroma = NULL;
    double sigma_chroma=0;
    Napi::Value* jsobj_lambda = NULL;
    double lambda=128.0;
    Napi::Value* jsobj_num_iter = NULL;
    int num_iter=25;
    Napi::Value* jsobj_max_tol = NULL;
    double max_tol=1e-5;
    Ptr<FastBilateralSolverFilter> retval;

    const char* keywords[] = { "guide", "sigma_spatial", "sigma_luma", "sigma_chroma", "lambda_", "num_iter", "max_tol", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOO:createFastBilateralSolverFilter", (char**)keywords, &jsobj_guide, &jsobj_sigma_spatial, &jsobj_sigma_luma, &jsobj_sigma_chroma, &jsobj_lambda, &jsobj_num_iter, &jsobj_max_tol) &&
        jsopencv_to_safe(jsobj_guide, guide, ArgInfo("guide", 0)) &&
        jsopencv_to_safe(jsobj_sigma_spatial, sigma_spatial, ArgInfo("sigma_spatial", 0)) &&
        jsopencv_to_safe(jsobj_sigma_luma, sigma_luma, ArgInfo("sigma_luma", 0)) &&
        jsopencv_to_safe(jsobj_sigma_chroma, sigma_chroma, ArgInfo("sigma_chroma", 0)) &&
        jsopencv_to_safe(jsobj_lambda, lambda, ArgInfo("lambda", 0)) &&
        jsopencv_to_safe(jsobj_num_iter, num_iter, ArgInfo("num_iter", 0)) &&
        jsopencv_to_safe(jsobj_max_tol, max_tol, ArgInfo("max_tol", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ximgproc::createFastBilateralSolverFilter(guide, sigma_spatial, sigma_luma, sigma_chroma, lambda, num_iter, max_tol));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_guide = NULL;
    UMat guide;
    Napi::Value* jsobj_sigma_spatial = NULL;
    double sigma_spatial=0;
    Napi::Value* jsobj_sigma_luma = NULL;
    double sigma_luma=0;
    Napi::Value* jsobj_sigma_chroma = NULL;
    double sigma_chroma=0;
    Napi::Value* jsobj_lambda = NULL;
    double lambda=128.0;
    Napi::Value* jsobj_num_iter = NULL;
    int num_iter=25;
    Napi::Value* jsobj_max_tol = NULL;
    double max_tol=1e-5;
    Ptr<FastBilateralSolverFilter> retval;

    const char* keywords[] = { "guide", "sigma_spatial", "sigma_luma", "sigma_chroma", "lambda_", "num_iter", "max_tol", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOO:createFastBilateralSolverFilter", (char**)keywords, &jsobj_guide, &jsobj_sigma_spatial, &jsobj_sigma_luma, &jsobj_sigma_chroma, &jsobj_lambda, &jsobj_num_iter, &jsobj_max_tol) &&
        jsopencv_to_safe(jsobj_guide, guide, ArgInfo("guide", 0)) &&
        jsopencv_to_safe(jsobj_sigma_spatial, sigma_spatial, ArgInfo("sigma_spatial", 0)) &&
        jsopencv_to_safe(jsobj_sigma_luma, sigma_luma, ArgInfo("sigma_luma", 0)) &&
        jsopencv_to_safe(jsobj_sigma_chroma, sigma_chroma, ArgInfo("sigma_chroma", 0)) &&
        jsopencv_to_safe(jsobj_lambda, lambda, ArgInfo("lambda", 0)) &&
        jsopencv_to_safe(jsobj_num_iter, num_iter, ArgInfo("num_iter", 0)) &&
        jsopencv_to_safe(jsobj_max_tol, max_tol, ArgInfo("max_tol", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ximgproc::createFastBilateralSolverFilter(guide, sigma_spatial, sigma_luma, sigma_chroma, lambda, num_iter, max_tol));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "createFastBilateralSolverFilter");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_createFastGlobalSmootherFilter(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_guide = NULL;
    Mat guide;
    Napi::Value* jsobj_lambda = NULL;
    double lambda=0;
    Napi::Value* jsobj_sigma_color = NULL;
    double sigma_color=0;
    Napi::Value* jsobj_lambda_attenuation = NULL;
    double lambda_attenuation=0.25;
    Napi::Value* jsobj_num_iter = NULL;
    int num_iter=3;
    Ptr<FastGlobalSmootherFilter> retval;

    const char* keywords[] = { "guide", "lambda_", "sigma_color", "lambda_attenuation", "num_iter", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OO:createFastGlobalSmootherFilter", (char**)keywords, &jsobj_guide, &jsobj_lambda, &jsobj_sigma_color, &jsobj_lambda_attenuation, &jsobj_num_iter) &&
        jsopencv_to_safe(jsobj_guide, guide, ArgInfo("guide", 0)) &&
        jsopencv_to_safe(jsobj_lambda, lambda, ArgInfo("lambda", 0)) &&
        jsopencv_to_safe(jsobj_sigma_color, sigma_color, ArgInfo("sigma_color", 0)) &&
        jsopencv_to_safe(jsobj_lambda_attenuation, lambda_attenuation, ArgInfo("lambda_attenuation", 0)) &&
        jsopencv_to_safe(jsobj_num_iter, num_iter, ArgInfo("num_iter", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ximgproc::createFastGlobalSmootherFilter(guide, lambda, sigma_color, lambda_attenuation, num_iter));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_guide = NULL;
    UMat guide;
    Napi::Value* jsobj_lambda = NULL;
    double lambda=0;
    Napi::Value* jsobj_sigma_color = NULL;
    double sigma_color=0;
    Napi::Value* jsobj_lambda_attenuation = NULL;
    double lambda_attenuation=0.25;
    Napi::Value* jsobj_num_iter = NULL;
    int num_iter=3;
    Ptr<FastGlobalSmootherFilter> retval;

    const char* keywords[] = { "guide", "lambda_", "sigma_color", "lambda_attenuation", "num_iter", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OO:createFastGlobalSmootherFilter", (char**)keywords, &jsobj_guide, &jsobj_lambda, &jsobj_sigma_color, &jsobj_lambda_attenuation, &jsobj_num_iter) &&
        jsopencv_to_safe(jsobj_guide, guide, ArgInfo("guide", 0)) &&
        jsopencv_to_safe(jsobj_lambda, lambda, ArgInfo("lambda", 0)) &&
        jsopencv_to_safe(jsobj_sigma_color, sigma_color, ArgInfo("sigma_color", 0)) &&
        jsopencv_to_safe(jsobj_lambda_attenuation, lambda_attenuation, ArgInfo("lambda_attenuation", 0)) &&
        jsopencv_to_safe(jsobj_num_iter, num_iter, ArgInfo("num_iter", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ximgproc::createFastGlobalSmootherFilter(guide, lambda, sigma_color, lambda_attenuation, num_iter));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "createFastGlobalSmootherFilter");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_createFastLineDetector(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    Napi::Value* jsobj_length_threshold = NULL;
    int length_threshold=10;
    Napi::Value* jsobj_distance_threshold = NULL;
    float distance_threshold=1.414213562f;
    Napi::Value* jsobj_canny_th1 = NULL;
    double canny_th1=50.0;
    Napi::Value* jsobj_canny_th2 = NULL;
    double canny_th2=50.0;
    Napi::Value* jsobj_canny_aperture_size = NULL;
    int canny_aperture_size=3;
    Napi::Value* jsobj_do_merge = NULL;
    bool do_merge=false;
    Ptr<FastLineDetector> retval;

    const char* keywords[] = { "length_threshold", "distance_threshold", "canny_th1", "canny_th2", "canny_aperture_size", "do_merge", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OOOOOO:createFastLineDetector", (char**)keywords, &jsobj_length_threshold, &jsobj_distance_threshold, &jsobj_canny_th1, &jsobj_canny_th2, &jsobj_canny_aperture_size, &jsobj_do_merge) &&
        jsopencv_to_safe(jsobj_length_threshold, length_threshold, ArgInfo("length_threshold", 0)) &&
        jsopencv_to_safe(jsobj_distance_threshold, distance_threshold, ArgInfo("distance_threshold", 0)) &&
        jsopencv_to_safe(jsobj_canny_th1, canny_th1, ArgInfo("canny_th1", 0)) &&
        jsopencv_to_safe(jsobj_canny_th2, canny_th2, ArgInfo("canny_th2", 0)) &&
        jsopencv_to_safe(jsobj_canny_aperture_size, canny_aperture_size, ArgInfo("canny_aperture_size", 0)) &&
        jsopencv_to_safe(jsobj_do_merge, do_merge, ArgInfo("do_merge", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ximgproc::createFastLineDetector(length_threshold, distance_threshold, canny_th1, canny_th2, canny_aperture_size, do_merge));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_createGuidedFilter(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_guide = NULL;
    Mat guide;
    Napi::Value* jsobj_radius = NULL;
    int radius=0;
    Napi::Value* jsobj_eps = NULL;
    double eps=0;
    Ptr<GuidedFilter> retval;

    const char* keywords[] = { "guide", "radius", "eps", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:createGuidedFilter", (char**)keywords, &jsobj_guide, &jsobj_radius, &jsobj_eps) &&
        jsopencv_to_safe(jsobj_guide, guide, ArgInfo("guide", 0)) &&
        jsopencv_to_safe(jsobj_radius, radius, ArgInfo("radius", 0)) &&
        jsopencv_to_safe(jsobj_eps, eps, ArgInfo("eps", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ximgproc::createGuidedFilter(guide, radius, eps));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_guide = NULL;
    UMat guide;
    Napi::Value* jsobj_radius = NULL;
    int radius=0;
    Napi::Value* jsobj_eps = NULL;
    double eps=0;
    Ptr<GuidedFilter> retval;

    const char* keywords[] = { "guide", "radius", "eps", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:createGuidedFilter", (char**)keywords, &jsobj_guide, &jsobj_radius, &jsobj_eps) &&
        jsopencv_to_safe(jsobj_guide, guide, ArgInfo("guide", 0)) &&
        jsopencv_to_safe(jsobj_radius, radius, ArgInfo("radius", 0)) &&
        jsopencv_to_safe(jsobj_eps, eps, ArgInfo("eps", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ximgproc::createGuidedFilter(guide, radius, eps));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "createGuidedFilter");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_createQuaternionImage(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_img = NULL;
    Mat img;
    Napi::Value* jsobj_qimg = NULL;
    Mat qimg;

    const char* keywords[] = { "img", "qimg", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:createQuaternionImage", (char**)keywords, &jsobj_img, &jsobj_qimg) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 0)) &&
        jsopencv_to_safe(jsobj_qimg, qimg, ArgInfo("qimg", 1)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::createQuaternionImage(img, qimg));
        return jsopencv_from(info, qimg);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_img = NULL;
    UMat img;
    Napi::Value* jsobj_qimg = NULL;
    UMat qimg;

    const char* keywords[] = { "img", "qimg", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:createQuaternionImage", (char**)keywords, &jsobj_img, &jsobj_qimg) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 0)) &&
        jsopencv_to_safe(jsobj_qimg, qimg, ArgInfo("qimg", 1)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::createQuaternionImage(img, qimg));
        return jsopencv_from(info, qimg);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "createQuaternionImage");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_createRFFeatureGetter(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    Ptr<RFFeatureGetter> retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::ximgproc::createRFFeatureGetter());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_createRICInterpolator(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    Ptr<RICInterpolator> retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::ximgproc::createRICInterpolator());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_createRightMatcher(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    Napi::Value* jsobj_matcher_left = NULL;
    Ptr<StereoMatcher> matcher_left;
    Ptr<StereoMatcher> retval;

    const char* keywords[] = { "matcher_left", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:createRightMatcher", (char**)keywords, &jsobj_matcher_left) &&
        jsopencv_to_safe(jsobj_matcher_left, matcher_left, ArgInfo("matcher_left", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ximgproc::createRightMatcher(matcher_left));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_createScanSegment(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    Napi::Value* jsobj_image_width = NULL;
    int image_width=0;
    Napi::Value* jsobj_image_height = NULL;
    int image_height=0;
    Napi::Value* jsobj_num_superpixels = NULL;
    int num_superpixels=0;
    Napi::Value* jsobj_slices = NULL;
    int slices=8;
    Napi::Value* jsobj_merge_small = NULL;
    bool merge_small=true;
    cv::Ptr<ScanSegment> retval;

    const char* keywords[] = { "image_width", "image_height", "num_superpixels", "slices", "merge_small", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OO:createScanSegment", (char**)keywords, &jsobj_image_width, &jsobj_image_height, &jsobj_num_superpixels, &jsobj_slices, &jsobj_merge_small) &&
        jsopencv_to_safe(jsobj_image_width, image_width, ArgInfo("image_width", 0)) &&
        jsopencv_to_safe(jsobj_image_height, image_height, ArgInfo("image_height", 0)) &&
        jsopencv_to_safe(jsobj_num_superpixels, num_superpixels, ArgInfo("num_superpixels", 0)) &&
        jsopencv_to_safe(jsobj_slices, slices, ArgInfo("slices", 0)) &&
        jsopencv_to_safe(jsobj_merge_small, merge_small, ArgInfo("merge_small", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ximgproc::createScanSegment(image_width, image_height, num_superpixels, slices, merge_small));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_createStructuredEdgeDetection(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    Napi::Value* jsobj_model = NULL;
    String model;
    Napi::Value* jsobj_howToGetFeatures = NULL;
    Ptr<RFFeatureGetter> howToGetFeatures;
    Ptr<StructuredEdgeDetection> retval;

    const char* keywords[] = { "model", "howToGetFeatures", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:createStructuredEdgeDetection", (char**)keywords, &jsobj_model, &jsobj_howToGetFeatures) &&
        jsopencv_to_safe(jsobj_model, model, ArgInfo("model", 0)) &&
        jsopencv_to_safe(jsobj_howToGetFeatures, howToGetFeatures, ArgInfo("howToGetFeatures", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ximgproc::createStructuredEdgeDetection(model, howToGetFeatures));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_createSuperpixelLSC(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_image = NULL;
    Mat image;
    Napi::Value* jsobj_region_size = NULL;
    int region_size=10;
    Napi::Value* jsobj_ratio = NULL;
    float ratio=0.075f;
    Ptr<SuperpixelLSC> retval;

    const char* keywords[] = { "image", "region_size", "ratio", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OO:createSuperpixelLSC", (char**)keywords, &jsobj_image, &jsobj_region_size, &jsobj_ratio) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_region_size, region_size, ArgInfo("region_size", 0)) &&
        jsopencv_to_safe(jsobj_ratio, ratio, ArgInfo("ratio", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ximgproc::createSuperpixelLSC(image, region_size, ratio));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_image = NULL;
    UMat image;
    Napi::Value* jsobj_region_size = NULL;
    int region_size=10;
    Napi::Value* jsobj_ratio = NULL;
    float ratio=0.075f;
    Ptr<SuperpixelLSC> retval;

    const char* keywords[] = { "image", "region_size", "ratio", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OO:createSuperpixelLSC", (char**)keywords, &jsobj_image, &jsobj_region_size, &jsobj_ratio) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_region_size, region_size, ArgInfo("region_size", 0)) &&
        jsopencv_to_safe(jsobj_ratio, ratio, ArgInfo("ratio", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ximgproc::createSuperpixelLSC(image, region_size, ratio));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "createSuperpixelLSC");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_createSuperpixelSEEDS(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    Napi::Value* jsobj_image_width = NULL;
    int image_width=0;
    Napi::Value* jsobj_image_height = NULL;
    int image_height=0;
    Napi::Value* jsobj_image_channels = NULL;
    int image_channels=0;
    Napi::Value* jsobj_num_superpixels = NULL;
    int num_superpixels=0;
    Napi::Value* jsobj_num_levels = NULL;
    int num_levels=0;
    Napi::Value* jsobj_prior = NULL;
    int prior=2;
    Napi::Value* jsobj_histogram_bins = NULL;
    int histogram_bins=5;
    Napi::Value* jsobj_double_step = NULL;
    bool double_step=false;
    Ptr<SuperpixelSEEDS> retval;

    const char* keywords[] = { "image_width", "image_height", "image_channels", "num_superpixels", "num_levels", "prior", "histogram_bins", "double_step", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOO|OOO:createSuperpixelSEEDS", (char**)keywords, &jsobj_image_width, &jsobj_image_height, &jsobj_image_channels, &jsobj_num_superpixels, &jsobj_num_levels, &jsobj_prior, &jsobj_histogram_bins, &jsobj_double_step) &&
        jsopencv_to_safe(jsobj_image_width, image_width, ArgInfo("image_width", 0)) &&
        jsopencv_to_safe(jsobj_image_height, image_height, ArgInfo("image_height", 0)) &&
        jsopencv_to_safe(jsobj_image_channels, image_channels, ArgInfo("image_channels", 0)) &&
        jsopencv_to_safe(jsobj_num_superpixels, num_superpixels, ArgInfo("num_superpixels", 0)) &&
        jsopencv_to_safe(jsobj_num_levels, num_levels, ArgInfo("num_levels", 0)) &&
        jsopencv_to_safe(jsobj_prior, prior, ArgInfo("prior", 0)) &&
        jsopencv_to_safe(jsobj_histogram_bins, histogram_bins, ArgInfo("histogram_bins", 0)) &&
        jsopencv_to_safe(jsobj_double_step, double_step, ArgInfo("double_step", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ximgproc::createSuperpixelSEEDS(image_width, image_height, image_channels, num_superpixels, num_levels, prior, histogram_bins, double_step));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_createSuperpixelSLIC(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_image = NULL;
    Mat image;
    Napi::Value* jsobj_algorithm = NULL;
    int algorithm=SLICO;
    Napi::Value* jsobj_region_size = NULL;
    int region_size=10;
    Napi::Value* jsobj_ruler = NULL;
    float ruler=10.0f;
    Ptr<SuperpixelSLIC> retval;

    const char* keywords[] = { "image", "algorithm", "region_size", "ruler", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOO:createSuperpixelSLIC", (char**)keywords, &jsobj_image, &jsobj_algorithm, &jsobj_region_size, &jsobj_ruler) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_algorithm, algorithm, ArgInfo("algorithm", 0)) &&
        jsopencv_to_safe(jsobj_region_size, region_size, ArgInfo("region_size", 0)) &&
        jsopencv_to_safe(jsobj_ruler, ruler, ArgInfo("ruler", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ximgproc::createSuperpixelSLIC(image, algorithm, region_size, ruler));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_image = NULL;
    UMat image;
    Napi::Value* jsobj_algorithm = NULL;
    int algorithm=SLICO;
    Napi::Value* jsobj_region_size = NULL;
    int region_size=10;
    Napi::Value* jsobj_ruler = NULL;
    float ruler=10.0f;
    Ptr<SuperpixelSLIC> retval;

    const char* keywords[] = { "image", "algorithm", "region_size", "ruler", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOO:createSuperpixelSLIC", (char**)keywords, &jsobj_image, &jsobj_algorithm, &jsobj_region_size, &jsobj_ruler) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_algorithm, algorithm, ArgInfo("algorithm", 0)) &&
        jsopencv_to_safe(jsobj_region_size, region_size, ArgInfo("region_size", 0)) &&
        jsopencv_to_safe(jsobj_ruler, ruler, ArgInfo("ruler", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ximgproc::createSuperpixelSLIC(image, algorithm, region_size, ruler));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "createSuperpixelSLIC");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_dtFilter(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_guide = NULL;
    Mat guide;
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_sigmaSpatial = NULL;
    double sigmaSpatial=0;
    Napi::Value* jsobj_sigmaColor = NULL;
    double sigmaColor=0;
    Napi::Value* jsobj_mode = NULL;
    int mode=DTF_NC;
    Napi::Value* jsobj_numIters = NULL;
    int numIters=3;

    const char* keywords[] = { "guide", "src", "sigmaSpatial", "sigmaColor", "dst", "mode", "numIters", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOO:dtFilter", (char**)keywords, &jsobj_guide, &jsobj_src, &jsobj_sigmaSpatial, &jsobj_sigmaColor, &jsobj_dst, &jsobj_mode, &jsobj_numIters) &&
        jsopencv_to_safe(jsobj_guide, guide, ArgInfo("guide", 0)) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_sigmaSpatial, sigmaSpatial, ArgInfo("sigmaSpatial", 0)) &&
        jsopencv_to_safe(jsobj_sigmaColor, sigmaColor, ArgInfo("sigmaColor", 0)) &&
        jsopencv_to_safe(jsobj_mode, mode, ArgInfo("mode", 0)) &&
        jsopencv_to_safe(jsobj_numIters, numIters, ArgInfo("numIters", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::dtFilter(guide, src, dst, sigmaSpatial, sigmaColor, mode, numIters));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_guide = NULL;
    UMat guide;
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_sigmaSpatial = NULL;
    double sigmaSpatial=0;
    Napi::Value* jsobj_sigmaColor = NULL;
    double sigmaColor=0;
    Napi::Value* jsobj_mode = NULL;
    int mode=DTF_NC;
    Napi::Value* jsobj_numIters = NULL;
    int numIters=3;

    const char* keywords[] = { "guide", "src", "sigmaSpatial", "sigmaColor", "dst", "mode", "numIters", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOO:dtFilter", (char**)keywords, &jsobj_guide, &jsobj_src, &jsobj_sigmaSpatial, &jsobj_sigmaColor, &jsobj_dst, &jsobj_mode, &jsobj_numIters) &&
        jsopencv_to_safe(jsobj_guide, guide, ArgInfo("guide", 0)) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_sigmaSpatial, sigmaSpatial, ArgInfo("sigmaSpatial", 0)) &&
        jsopencv_to_safe(jsobj_sigmaColor, sigmaColor, ArgInfo("sigmaColor", 0)) &&
        jsopencv_to_safe(jsobj_mode, mode, ArgInfo("mode", 0)) &&
        jsopencv_to_safe(jsobj_numIters, numIters, ArgInfo("numIters", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::dtFilter(guide, src, dst, sigmaSpatial, sigmaColor, mode, numIters));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "dtFilter");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_edgePreservingFilter(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_d = NULL;
    int d=0;
    Napi::Value* jsobj_threshold = NULL;
    double threshold=0;

    const char* keywords[] = { "src", "d", "threshold", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:edgePreservingFilter", (char**)keywords, &jsobj_src, &jsobj_d, &jsobj_threshold, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_d, d, ArgInfo("d", 0)) &&
        jsopencv_to_safe(jsobj_threshold, threshold, ArgInfo("threshold", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::edgePreservingFilter(src, dst, d, threshold));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_d = NULL;
    int d=0;
    Napi::Value* jsobj_threshold = NULL;
    double threshold=0;

    const char* keywords[] = { "src", "d", "threshold", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:edgePreservingFilter", (char**)keywords, &jsobj_src, &jsobj_d, &jsobj_threshold, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_d, d, ArgInfo("d", 0)) &&
        jsopencv_to_safe(jsobj_threshold, threshold, ArgInfo("threshold", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::edgePreservingFilter(src, dst, d, threshold));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "edgePreservingFilter");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_fastBilateralSolverFilter(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_guide = NULL;
    Mat guide;
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_confidence = NULL;
    Mat confidence;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_sigma_spatial = NULL;
    double sigma_spatial=8;
    Napi::Value* jsobj_sigma_luma = NULL;
    double sigma_luma=8;
    Napi::Value* jsobj_sigma_chroma = NULL;
    double sigma_chroma=8;
    Napi::Value* jsobj_lambda = NULL;
    double lambda=128.0;
    Napi::Value* jsobj_num_iter = NULL;
    int num_iter=25;
    Napi::Value* jsobj_max_tol = NULL;
    double max_tol=1e-5;

    const char* keywords[] = { "guide", "src", "confidence", "dst", "sigma_spatial", "sigma_luma", "sigma_chroma", "lambda_", "num_iter", "max_tol", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOOOOOO:fastBilateralSolverFilter", (char**)keywords, &jsobj_guide, &jsobj_src, &jsobj_confidence, &jsobj_dst, &jsobj_sigma_spatial, &jsobj_sigma_luma, &jsobj_sigma_chroma, &jsobj_lambda, &jsobj_num_iter, &jsobj_max_tol) &&
        jsopencv_to_safe(jsobj_guide, guide, ArgInfo("guide", 0)) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_confidence, confidence, ArgInfo("confidence", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_sigma_spatial, sigma_spatial, ArgInfo("sigma_spatial", 0)) &&
        jsopencv_to_safe(jsobj_sigma_luma, sigma_luma, ArgInfo("sigma_luma", 0)) &&
        jsopencv_to_safe(jsobj_sigma_chroma, sigma_chroma, ArgInfo("sigma_chroma", 0)) &&
        jsopencv_to_safe(jsobj_lambda, lambda, ArgInfo("lambda", 0)) &&
        jsopencv_to_safe(jsobj_num_iter, num_iter, ArgInfo("num_iter", 0)) &&
        jsopencv_to_safe(jsobj_max_tol, max_tol, ArgInfo("max_tol", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::fastBilateralSolverFilter(guide, src, confidence, dst, sigma_spatial, sigma_luma, sigma_chroma, lambda, num_iter, max_tol));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_guide = NULL;
    UMat guide;
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_confidence = NULL;
    UMat confidence;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_sigma_spatial = NULL;
    double sigma_spatial=8;
    Napi::Value* jsobj_sigma_luma = NULL;
    double sigma_luma=8;
    Napi::Value* jsobj_sigma_chroma = NULL;
    double sigma_chroma=8;
    Napi::Value* jsobj_lambda = NULL;
    double lambda=128.0;
    Napi::Value* jsobj_num_iter = NULL;
    int num_iter=25;
    Napi::Value* jsobj_max_tol = NULL;
    double max_tol=1e-5;

    const char* keywords[] = { "guide", "src", "confidence", "dst", "sigma_spatial", "sigma_luma", "sigma_chroma", "lambda_", "num_iter", "max_tol", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOOOOOO:fastBilateralSolverFilter", (char**)keywords, &jsobj_guide, &jsobj_src, &jsobj_confidence, &jsobj_dst, &jsobj_sigma_spatial, &jsobj_sigma_luma, &jsobj_sigma_chroma, &jsobj_lambda, &jsobj_num_iter, &jsobj_max_tol) &&
        jsopencv_to_safe(jsobj_guide, guide, ArgInfo("guide", 0)) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_confidence, confidence, ArgInfo("confidence", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_sigma_spatial, sigma_spatial, ArgInfo("sigma_spatial", 0)) &&
        jsopencv_to_safe(jsobj_sigma_luma, sigma_luma, ArgInfo("sigma_luma", 0)) &&
        jsopencv_to_safe(jsobj_sigma_chroma, sigma_chroma, ArgInfo("sigma_chroma", 0)) &&
        jsopencv_to_safe(jsobj_lambda, lambda, ArgInfo("lambda", 0)) &&
        jsopencv_to_safe(jsobj_num_iter, num_iter, ArgInfo("num_iter", 0)) &&
        jsopencv_to_safe(jsobj_max_tol, max_tol, ArgInfo("max_tol", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::fastBilateralSolverFilter(guide, src, confidence, dst, sigma_spatial, sigma_luma, sigma_chroma, lambda, num_iter, max_tol));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "fastBilateralSolverFilter");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_fastGlobalSmootherFilter(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_guide = NULL;
    Mat guide;
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_lambda = NULL;
    double lambda=0;
    Napi::Value* jsobj_sigma_color = NULL;
    double sigma_color=0;
    Napi::Value* jsobj_lambda_attenuation = NULL;
    double lambda_attenuation=0.25;
    Napi::Value* jsobj_num_iter = NULL;
    int num_iter=3;

    const char* keywords[] = { "guide", "src", "lambda_", "sigma_color", "dst", "lambda_attenuation", "num_iter", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOO:fastGlobalSmootherFilter", (char**)keywords, &jsobj_guide, &jsobj_src, &jsobj_lambda, &jsobj_sigma_color, &jsobj_dst, &jsobj_lambda_attenuation, &jsobj_num_iter) &&
        jsopencv_to_safe(jsobj_guide, guide, ArgInfo("guide", 0)) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_lambda, lambda, ArgInfo("lambda", 0)) &&
        jsopencv_to_safe(jsobj_sigma_color, sigma_color, ArgInfo("sigma_color", 0)) &&
        jsopencv_to_safe(jsobj_lambda_attenuation, lambda_attenuation, ArgInfo("lambda_attenuation", 0)) &&
        jsopencv_to_safe(jsobj_num_iter, num_iter, ArgInfo("num_iter", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::fastGlobalSmootherFilter(guide, src, dst, lambda, sigma_color, lambda_attenuation, num_iter));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_guide = NULL;
    UMat guide;
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_lambda = NULL;
    double lambda=0;
    Napi::Value* jsobj_sigma_color = NULL;
    double sigma_color=0;
    Napi::Value* jsobj_lambda_attenuation = NULL;
    double lambda_attenuation=0.25;
    Napi::Value* jsobj_num_iter = NULL;
    int num_iter=3;

    const char* keywords[] = { "guide", "src", "lambda_", "sigma_color", "dst", "lambda_attenuation", "num_iter", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OOO:fastGlobalSmootherFilter", (char**)keywords, &jsobj_guide, &jsobj_src, &jsobj_lambda, &jsobj_sigma_color, &jsobj_dst, &jsobj_lambda_attenuation, &jsobj_num_iter) &&
        jsopencv_to_safe(jsobj_guide, guide, ArgInfo("guide", 0)) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_lambda, lambda, ArgInfo("lambda", 0)) &&
        jsopencv_to_safe(jsobj_sigma_color, sigma_color, ArgInfo("sigma_color", 0)) &&
        jsopencv_to_safe(jsobj_lambda_attenuation, lambda_attenuation, ArgInfo("lambda_attenuation", 0)) &&
        jsopencv_to_safe(jsobj_num_iter, num_iter, ArgInfo("num_iter", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::fastGlobalSmootherFilter(guide, src, dst, lambda, sigma_color, lambda_attenuation, num_iter));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "fastGlobalSmootherFilter");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_findEllipses(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_image = NULL;
    Mat image;
    Napi::Value* jsobj_ellipses = NULL;
    Mat ellipses;
    Napi::Value* jsobj_scoreThreshold = NULL;
    float scoreThreshold=0.7f;
    Napi::Value* jsobj_reliabilityThreshold = NULL;
    float reliabilityThreshold=0.5f;
    Napi::Value* jsobj_centerDistanceThreshold = NULL;
    float centerDistanceThreshold=0.05f;

    const char* keywords[] = { "image", "ellipses", "scoreThreshold", "reliabilityThreshold", "centerDistanceThreshold", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOOO:findEllipses", (char**)keywords, &jsobj_image, &jsobj_ellipses, &jsobj_scoreThreshold, &jsobj_reliabilityThreshold, &jsobj_centerDistanceThreshold) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_ellipses, ellipses, ArgInfo("ellipses", 1)) &&
        jsopencv_to_safe(jsobj_scoreThreshold, scoreThreshold, ArgInfo("scoreThreshold", 0)) &&
        jsopencv_to_safe(jsobj_reliabilityThreshold, reliabilityThreshold, ArgInfo("reliabilityThreshold", 0)) &&
        jsopencv_to_safe(jsobj_centerDistanceThreshold, centerDistanceThreshold, ArgInfo("centerDistanceThreshold", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::findEllipses(image, ellipses, scoreThreshold, reliabilityThreshold, centerDistanceThreshold));
        return jsopencv_from(info, ellipses);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_image = NULL;
    UMat image;
    Napi::Value* jsobj_ellipses = NULL;
    UMat ellipses;
    Napi::Value* jsobj_scoreThreshold = NULL;
    float scoreThreshold=0.7f;
    Napi::Value* jsobj_reliabilityThreshold = NULL;
    float reliabilityThreshold=0.5f;
    Napi::Value* jsobj_centerDistanceThreshold = NULL;
    float centerDistanceThreshold=0.05f;

    const char* keywords[] = { "image", "ellipses", "scoreThreshold", "reliabilityThreshold", "centerDistanceThreshold", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOOO:findEllipses", (char**)keywords, &jsobj_image, &jsobj_ellipses, &jsobj_scoreThreshold, &jsobj_reliabilityThreshold, &jsobj_centerDistanceThreshold) &&
        jsopencv_to_safe(jsobj_image, image, ArgInfo("image", 0)) &&
        jsopencv_to_safe(jsobj_ellipses, ellipses, ArgInfo("ellipses", 1)) &&
        jsopencv_to_safe(jsobj_scoreThreshold, scoreThreshold, ArgInfo("scoreThreshold", 0)) &&
        jsopencv_to_safe(jsobj_reliabilityThreshold, reliabilityThreshold, ArgInfo("reliabilityThreshold", 0)) &&
        jsopencv_to_safe(jsobj_centerDistanceThreshold, centerDistanceThreshold, ArgInfo("centerDistanceThreshold", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::findEllipses(image, ellipses, scoreThreshold, reliabilityThreshold, centerDistanceThreshold));
        return jsopencv_from(info, ellipses);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "findEllipses");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_fourierDescriptor(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_nbElt = NULL;
    int nbElt=-1;
    Napi::Value* jsobj_nbFD = NULL;
    int nbFD=-1;

    const char* keywords[] = { "src", "dst", "nbElt", "nbFD", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOO:fourierDescriptor", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_nbElt, &jsobj_nbFD) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_nbElt, nbElt, ArgInfo("nbElt", 0)) &&
        jsopencv_to_safe(jsobj_nbFD, nbFD, ArgInfo("nbFD", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::fourierDescriptor(src, dst, nbElt, nbFD));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_nbElt = NULL;
    int nbElt=-1;
    Napi::Value* jsobj_nbFD = NULL;
    int nbFD=-1;

    const char* keywords[] = { "src", "dst", "nbElt", "nbFD", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOO:fourierDescriptor", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_nbElt, &jsobj_nbFD) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_nbElt, nbElt, ArgInfo("nbElt", 0)) &&
        jsopencv_to_safe(jsobj_nbFD, nbFD, ArgInfo("nbFD", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::fourierDescriptor(src, dst, nbElt, nbFD));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "fourierDescriptor");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_getDisparityVis(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_scale = NULL;
    double scale=1.0;

    const char* keywords[] = { "src", "dst", "scale", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OO:getDisparityVis", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_scale) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_scale, scale, ArgInfo("scale", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::getDisparityVis(src, dst, scale));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_scale = NULL;
    double scale=1.0;

    const char* keywords[] = { "src", "dst", "scale", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OO:getDisparityVis", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_scale) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_scale, scale, ArgInfo("scale", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::getDisparityVis(src, dst, scale));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "getDisparityVis");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_guidedFilter(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_guide = NULL;
    Mat guide;
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_radius = NULL;
    int radius=0;
    Napi::Value* jsobj_eps = NULL;
    double eps=0;
    Napi::Value* jsobj_dDepth = NULL;
    int dDepth=-1;

    const char* keywords[] = { "guide", "src", "radius", "eps", "dst", "dDepth", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OO:guidedFilter", (char**)keywords, &jsobj_guide, &jsobj_src, &jsobj_radius, &jsobj_eps, &jsobj_dst, &jsobj_dDepth) &&
        jsopencv_to_safe(jsobj_guide, guide, ArgInfo("guide", 0)) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_radius, radius, ArgInfo("radius", 0)) &&
        jsopencv_to_safe(jsobj_eps, eps, ArgInfo("eps", 0)) &&
        jsopencv_to_safe(jsobj_dDepth, dDepth, ArgInfo("dDepth", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::guidedFilter(guide, src, dst, radius, eps, dDepth));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_guide = NULL;
    UMat guide;
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_radius = NULL;
    int radius=0;
    Napi::Value* jsobj_eps = NULL;
    double eps=0;
    Napi::Value* jsobj_dDepth = NULL;
    int dDepth=-1;

    const char* keywords[] = { "guide", "src", "radius", "eps", "dst", "dDepth", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|OO:guidedFilter", (char**)keywords, &jsobj_guide, &jsobj_src, &jsobj_radius, &jsobj_eps, &jsobj_dst, &jsobj_dDepth) &&
        jsopencv_to_safe(jsobj_guide, guide, ArgInfo("guide", 0)) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_radius, radius, ArgInfo("radius", 0)) &&
        jsopencv_to_safe(jsobj_eps, eps, ArgInfo("eps", 0)) &&
        jsopencv_to_safe(jsobj_dDepth, dDepth, ArgInfo("dDepth", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::guidedFilter(guide, src, dst, radius, eps, dDepth));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "guidedFilter");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_jointBilateralFilter(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_joint = NULL;
    Mat joint;
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_d = NULL;
    int d=0;
    Napi::Value* jsobj_sigmaColor = NULL;
    double sigmaColor=0;
    Napi::Value* jsobj_sigmaSpace = NULL;
    double sigmaSpace=0;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_DEFAULT;

    const char* keywords[] = { "joint", "src", "d", "sigmaColor", "sigmaSpace", "dst", "borderType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOO|OO:jointBilateralFilter", (char**)keywords, &jsobj_joint, &jsobj_src, &jsobj_d, &jsobj_sigmaColor, &jsobj_sigmaSpace, &jsobj_dst, &jsobj_borderType) &&
        jsopencv_to_safe(jsobj_joint, joint, ArgInfo("joint", 0)) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_d, d, ArgInfo("d", 0)) &&
        jsopencv_to_safe(jsobj_sigmaColor, sigmaColor, ArgInfo("sigmaColor", 0)) &&
        jsopencv_to_safe(jsobj_sigmaSpace, sigmaSpace, ArgInfo("sigmaSpace", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::jointBilateralFilter(joint, src, dst, d, sigmaColor, sigmaSpace, borderType));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_joint = NULL;
    UMat joint;
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_d = NULL;
    int d=0;
    Napi::Value* jsobj_sigmaColor = NULL;
    double sigmaColor=0;
    Napi::Value* jsobj_sigmaSpace = NULL;
    double sigmaSpace=0;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_DEFAULT;

    const char* keywords[] = { "joint", "src", "d", "sigmaColor", "sigmaSpace", "dst", "borderType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOO|OO:jointBilateralFilter", (char**)keywords, &jsobj_joint, &jsobj_src, &jsobj_d, &jsobj_sigmaColor, &jsobj_sigmaSpace, &jsobj_dst, &jsobj_borderType) &&
        jsopencv_to_safe(jsobj_joint, joint, ArgInfo("joint", 0)) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_d, d, ArgInfo("d", 0)) &&
        jsopencv_to_safe(jsobj_sigmaColor, sigmaColor, ArgInfo("sigmaColor", 0)) &&
        jsopencv_to_safe(jsobj_sigmaSpace, sigmaSpace, ArgInfo("sigmaSpace", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::jointBilateralFilter(joint, src, dst, d, sigmaColor, sigmaSpace, borderType));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "jointBilateralFilter");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_l0Smooth(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_lambda = NULL;
    double lambda=0.02;
    Napi::Value* jsobj_kappa = NULL;
    double kappa=2.0;

    const char* keywords[] = { "src", "dst", "lambda_", "kappa", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOO:l0Smooth", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_lambda, &jsobj_kappa) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_lambda, lambda, ArgInfo("lambda", 0)) &&
        jsopencv_to_safe(jsobj_kappa, kappa, ArgInfo("kappa", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::l0Smooth(src, dst, lambda, kappa));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_lambda = NULL;
    double lambda=0.02;
    Napi::Value* jsobj_kappa = NULL;
    double kappa=2.0;

    const char* keywords[] = { "src", "dst", "lambda_", "kappa", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOO:l0Smooth", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_lambda, &jsobj_kappa) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_lambda, lambda, ArgInfo("lambda", 0)) &&
        jsopencv_to_safe(jsobj_kappa, kappa, ArgInfo("kappa", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::l0Smooth(src, dst, lambda, kappa));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "l0Smooth");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_niBlackThreshold(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj__src = NULL;
    Mat _src;
    Napi::Value* jsobj__dst = NULL;
    Mat _dst;
    Napi::Value* jsobj_maxValue = NULL;
    double maxValue=0;
    Napi::Value* jsobj_type = NULL;
    int type=0;
    Napi::Value* jsobj_blockSize = NULL;
    int blockSize=0;
    Napi::Value* jsobj_k = NULL;
    double k=0;
    Napi::Value* jsobj_binarizationMethod = NULL;
    int binarizationMethod=BINARIZATION_NIBLACK;
    Napi::Value* jsobj_r = NULL;
    double r=128;

    const char* keywords[] = { "_src", "maxValue", "type", "blockSize", "k", "_dst", "binarizationMethod", "r", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOO|OOO:niBlackThreshold", (char**)keywords, &jsobj__src, &jsobj_maxValue, &jsobj_type, &jsobj_blockSize, &jsobj_k, &jsobj__dst, &jsobj_binarizationMethod, &jsobj_r) &&
        jsopencv_to_safe(jsobj__src, _src, ArgInfo("_src", 0)) &&
        jsopencv_to_safe(jsobj__dst, _dst, ArgInfo("_dst", 1)) &&
        jsopencv_to_safe(jsobj_maxValue, maxValue, ArgInfo("maxValue", 0)) &&
        jsopencv_to_safe(jsobj_type, type, ArgInfo("type", 0)) &&
        jsopencv_to_safe(jsobj_blockSize, blockSize, ArgInfo("blockSize", 0)) &&
        jsopencv_to_safe(jsobj_k, k, ArgInfo("k", 0)) &&
        jsopencv_to_safe(jsobj_binarizationMethod, binarizationMethod, ArgInfo("binarizationMethod", 0)) &&
        jsopencv_to_safe(jsobj_r, r, ArgInfo("r", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::niBlackThreshold(_src, _dst, maxValue, type, blockSize, k, binarizationMethod, r));
        return jsopencv_from(info, _dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj__src = NULL;
    UMat _src;
    Napi::Value* jsobj__dst = NULL;
    UMat _dst;
    Napi::Value* jsobj_maxValue = NULL;
    double maxValue=0;
    Napi::Value* jsobj_type = NULL;
    int type=0;
    Napi::Value* jsobj_blockSize = NULL;
    int blockSize=0;
    Napi::Value* jsobj_k = NULL;
    double k=0;
    Napi::Value* jsobj_binarizationMethod = NULL;
    int binarizationMethod=BINARIZATION_NIBLACK;
    Napi::Value* jsobj_r = NULL;
    double r=128;

    const char* keywords[] = { "_src", "maxValue", "type", "blockSize", "k", "_dst", "binarizationMethod", "r", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOOO|OOO:niBlackThreshold", (char**)keywords, &jsobj__src, &jsobj_maxValue, &jsobj_type, &jsobj_blockSize, &jsobj_k, &jsobj__dst, &jsobj_binarizationMethod, &jsobj_r) &&
        jsopencv_to_safe(jsobj__src, _src, ArgInfo("_src", 0)) &&
        jsopencv_to_safe(jsobj__dst, _dst, ArgInfo("_dst", 1)) &&
        jsopencv_to_safe(jsobj_maxValue, maxValue, ArgInfo("maxValue", 0)) &&
        jsopencv_to_safe(jsobj_type, type, ArgInfo("type", 0)) &&
        jsopencv_to_safe(jsobj_blockSize, blockSize, ArgInfo("blockSize", 0)) &&
        jsopencv_to_safe(jsobj_k, k, ArgInfo("k", 0)) &&
        jsopencv_to_safe(jsobj_binarizationMethod, binarizationMethod, ArgInfo("binarizationMethod", 0)) &&
        jsopencv_to_safe(jsobj_r, r, ArgInfo("r", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::niBlackThreshold(_src, _dst, maxValue, type, blockSize, k, binarizationMethod, r));
        return jsopencv_from(info, _dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "niBlackThreshold");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_qconj(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_qimg = NULL;
    Mat qimg;
    Napi::Value* jsobj_qcimg = NULL;
    Mat qcimg;

    const char* keywords[] = { "qimg", "qcimg", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:qconj", (char**)keywords, &jsobj_qimg, &jsobj_qcimg) &&
        jsopencv_to_safe(jsobj_qimg, qimg, ArgInfo("qimg", 0)) &&
        jsopencv_to_safe(jsobj_qcimg, qcimg, ArgInfo("qcimg", 1)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::qconj(qimg, qcimg));
        return jsopencv_from(info, qcimg);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_qimg = NULL;
    UMat qimg;
    Napi::Value* jsobj_qcimg = NULL;
    UMat qcimg;

    const char* keywords[] = { "qimg", "qcimg", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:qconj", (char**)keywords, &jsobj_qimg, &jsobj_qcimg) &&
        jsopencv_to_safe(jsobj_qimg, qimg, ArgInfo("qimg", 0)) &&
        jsopencv_to_safe(jsobj_qcimg, qcimg, ArgInfo("qcimg", 1)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::qconj(qimg, qcimg));
        return jsopencv_from(info, qcimg);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "qconj");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_qdft(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_img = NULL;
    Mat img;
    Napi::Value* jsobj_qimg = NULL;
    Mat qimg;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;
    Napi::Value* jsobj_sideLeft = NULL;
    bool sideLeft=0;

    const char* keywords[] = { "img", "flags", "sideLeft", "qimg", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:qdft", (char**)keywords, &jsobj_img, &jsobj_flags, &jsobj_sideLeft, &jsobj_qimg) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 0)) &&
        jsopencv_to_safe(jsobj_qimg, qimg, ArgInfo("qimg", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_sideLeft, sideLeft, ArgInfo("sideLeft", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::qdft(img, qimg, flags, sideLeft));
        return jsopencv_from(info, qimg);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_img = NULL;
    UMat img;
    Napi::Value* jsobj_qimg = NULL;
    UMat qimg;
    Napi::Value* jsobj_flags = NULL;
    int flags=0;
    Napi::Value* jsobj_sideLeft = NULL;
    bool sideLeft=0;

    const char* keywords[] = { "img", "flags", "sideLeft", "qimg", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:qdft", (char**)keywords, &jsobj_img, &jsobj_flags, &jsobj_sideLeft, &jsobj_qimg) &&
        jsopencv_to_safe(jsobj_img, img, ArgInfo("img", 0)) &&
        jsopencv_to_safe(jsobj_qimg, qimg, ArgInfo("qimg", 1)) &&
        jsopencv_to_safe(jsobj_flags, flags, ArgInfo("flags", 0)) &&
        jsopencv_to_safe(jsobj_sideLeft, sideLeft, ArgInfo("sideLeft", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::qdft(img, qimg, flags, sideLeft));
        return jsopencv_from(info, qimg);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "qdft");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_qmultiply(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src1 = NULL;
    Mat src1;
    Napi::Value* jsobj_src2 = NULL;
    Mat src2;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;

    const char* keywords[] = { "src1", "src2", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:qmultiply", (char**)keywords, &jsobj_src1, &jsobj_src2, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::qmultiply(src1, src2, dst));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src1 = NULL;
    UMat src1;
    Napi::Value* jsobj_src2 = NULL;
    UMat src2;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;

    const char* keywords[] = { "src1", "src2", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:qmultiply", (char**)keywords, &jsobj_src1, &jsobj_src2, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src1, src1, ArgInfo("src1", 0)) &&
        jsopencv_to_safe(jsobj_src2, src2, ArgInfo("src2", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::qmultiply(src1, src2, dst));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "qmultiply");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_qunitary(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_qimg = NULL;
    Mat qimg;
    Napi::Value* jsobj_qnimg = NULL;
    Mat qnimg;

    const char* keywords[] = { "qimg", "qnimg", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:qunitary", (char**)keywords, &jsobj_qimg, &jsobj_qnimg) &&
        jsopencv_to_safe(jsobj_qimg, qimg, ArgInfo("qimg", 0)) &&
        jsopencv_to_safe(jsobj_qnimg, qnimg, ArgInfo("qnimg", 1)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::qunitary(qimg, qnimg));
        return jsopencv_from(info, qnimg);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_qimg = NULL;
    UMat qimg;
    Napi::Value* jsobj_qnimg = NULL;
    UMat qnimg;

    const char* keywords[] = { "qimg", "qnimg", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:qunitary", (char**)keywords, &jsobj_qimg, &jsobj_qnimg) &&
        jsopencv_to_safe(jsobj_qimg, qimg, ArgInfo("qimg", 0)) &&
        jsopencv_to_safe(jsobj_qnimg, qnimg, ArgInfo("qnimg", 1)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::qunitary(qimg, qnimg));
        return jsopencv_from(info, qnimg);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "qunitary");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_readGT(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src_path = NULL;
    String src_path;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    int retval;

    const char* keywords[] = { "src_path", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:readGT", (char**)keywords, &jsobj_src_path, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src_path, src_path, ArgInfo("src_path", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ximgproc::readGT(src_path, dst));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, dst));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src_path = NULL;
    String src_path;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    int retval;

    const char* keywords[] = { "src_path", "dst", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|O:readGT", (char**)keywords, &jsobj_src_path, &jsobj_dst) &&
        jsopencv_to_safe(jsobj_src_path, src_path, ArgInfo("src_path", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ximgproc::readGT(src_path, dst));
        return Js_BuildValue(info, "(NN)", jsopencv_from(info, retval), jsopencv_from(info, dst));
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "readGT");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_rollingGuidanceFilter(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_d = NULL;
    int d=-1;
    Napi::Value* jsobj_sigmaColor = NULL;
    double sigmaColor=25;
    Napi::Value* jsobj_sigmaSpace = NULL;
    double sigmaSpace=3;
    Napi::Value* jsobj_numOfIter = NULL;
    int numOfIter=4;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_DEFAULT;

    const char* keywords[] = { "src", "dst", "d", "sigmaColor", "sigmaSpace", "numOfIter", "borderType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOOOOO:rollingGuidanceFilter", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_d, &jsobj_sigmaColor, &jsobj_sigmaSpace, &jsobj_numOfIter, &jsobj_borderType) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_d, d, ArgInfo("d", 0)) &&
        jsopencv_to_safe(jsobj_sigmaColor, sigmaColor, ArgInfo("sigmaColor", 0)) &&
        jsopencv_to_safe(jsobj_sigmaSpace, sigmaSpace, ArgInfo("sigmaSpace", 0)) &&
        jsopencv_to_safe(jsobj_numOfIter, numOfIter, ArgInfo("numOfIter", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::rollingGuidanceFilter(src, dst, d, sigmaColor, sigmaSpace, numOfIter, borderType));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_d = NULL;
    int d=-1;
    Napi::Value* jsobj_sigmaColor = NULL;
    double sigmaColor=25;
    Napi::Value* jsobj_sigmaSpace = NULL;
    double sigmaSpace=3;
    Napi::Value* jsobj_numOfIter = NULL;
    int numOfIter=4;
    Napi::Value* jsobj_borderType = NULL;
    int borderType=BORDER_DEFAULT;

    const char* keywords[] = { "src", "dst", "d", "sigmaColor", "sigmaSpace", "numOfIter", "borderType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OOOOOO:rollingGuidanceFilter", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_d, &jsobj_sigmaColor, &jsobj_sigmaSpace, &jsobj_numOfIter, &jsobj_borderType) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_d, d, ArgInfo("d", 0)) &&
        jsopencv_to_safe(jsobj_sigmaColor, sigmaColor, ArgInfo("sigmaColor", 0)) &&
        jsopencv_to_safe(jsobj_sigmaSpace, sigmaSpace, ArgInfo("sigmaSpace", 0)) &&
        jsopencv_to_safe(jsobj_numOfIter, numOfIter, ArgInfo("numOfIter", 0)) &&
        jsopencv_to_safe(jsobj_borderType, borderType, ArgInfo("borderType", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::rollingGuidanceFilter(src, dst, d, sigmaColor, sigmaSpace, numOfIter, borderType));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "rollingGuidanceFilter");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_thinning(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_thinningType = NULL;
    int thinningType=THINNING_ZHANGSUEN;

    const char* keywords[] = { "src", "dst", "thinningType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OO:thinning", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_thinningType) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_thinningType, thinningType, ArgInfo("thinningType", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::thinning(src, dst, thinningType));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_thinningType = NULL;
    int thinningType=THINNING_ZHANGSUEN;

    const char* keywords[] = { "src", "dst", "thinningType", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O|OO:thinning", (char**)keywords, &jsobj_src, &jsobj_dst, &jsobj_thinningType) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_thinningType, thinningType, ArgInfo("thinningType", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::thinning(src, dst, thinningType));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "thinning");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_transformFD(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_t = NULL;
    Mat t;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_fdContour = NULL;
    bool fdContour=true;

    const char* keywords[] = { "src", "t", "dst", "fdContour", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:transformFD", (char**)keywords, &jsobj_src, &jsobj_t, &jsobj_dst, &jsobj_fdContour) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_t, t, ArgInfo("t", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_fdContour, fdContour, ArgInfo("fdContour", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::transformFD(src, t, dst, fdContour));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_t = NULL;
    UMat t;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_fdContour = NULL;
    bool fdContour=true;

    const char* keywords[] = { "src", "t", "dst", "fdContour", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|OO:transformFD", (char**)keywords, &jsobj_src, &jsobj_t, &jsobj_dst, &jsobj_fdContour) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_t, t, ArgInfo("t", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_fdContour, fdContour, ArgInfo("fdContour", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::transformFD(src, t, dst, fdContour));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "transformFD");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_weightedMedianFilter(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc;

    jsPrepareArgumentConversionErrorsStorage(2);

    {
    Napi::Value* jsobj_joint = NULL;
    Mat joint;
    Napi::Value* jsobj_src = NULL;
    Mat src;
    Napi::Value* jsobj_dst = NULL;
    Mat dst;
    Napi::Value* jsobj_r = NULL;
    int r=0;
    Napi::Value* jsobj_sigma = NULL;
    double sigma=25.5;
    Napi::Value* jsobj_weightType = NULL;
    int weightType=WMF_EXP;
    Napi::Value* jsobj_mask = NULL;
    Mat mask;

    const char* keywords[] = { "joint", "src", "r", "dst", "sigma", "weightType", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOOO:weightedMedianFilter", (char**)keywords, &jsobj_joint, &jsobj_src, &jsobj_r, &jsobj_dst, &jsobj_sigma, &jsobj_weightType, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_joint, joint, ArgInfo("joint", 0)) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_r, r, ArgInfo("r", 0)) &&
        jsopencv_to_safe(jsobj_sigma, sigma, ArgInfo("sigma", 0)) &&
        jsopencv_to_safe(jsobj_weightType, weightType, ArgInfo("weightType", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::weightedMedianFilter(joint, src, dst, r, sigma, weightType, mask));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_joint = NULL;
    UMat joint;
    Napi::Value* jsobj_src = NULL;
    UMat src;
    Napi::Value* jsobj_dst = NULL;
    UMat dst;
    Napi::Value* jsobj_r = NULL;
    int r=0;
    Napi::Value* jsobj_sigma = NULL;
    double sigma=25.5;
    Napi::Value* jsobj_weightType = NULL;
    int weightType=WMF_EXP;
    Napi::Value* jsobj_mask = NULL;
    UMat mask;

    const char* keywords[] = { "joint", "src", "r", "dst", "sigma", "weightType", "mask", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|OOOO:weightedMedianFilter", (char**)keywords, &jsobj_joint, &jsobj_src, &jsobj_r, &jsobj_dst, &jsobj_sigma, &jsobj_weightType, &jsobj_mask) &&
        jsopencv_to_safe(jsobj_joint, joint, ArgInfo("joint", 0)) &&
        jsopencv_to_safe(jsobj_src, src, ArgInfo("src", 0)) &&
        jsopencv_to_safe(jsobj_dst, dst, ArgInfo("dst", 1)) &&
        jsopencv_to_safe(jsobj_r, r, ArgInfo("r", 0)) &&
        jsopencv_to_safe(jsobj_sigma, sigma, ArgInfo("sigma", 0)) &&
        jsopencv_to_safe(jsobj_weightType, weightType, ArgInfo("weightType", 0)) &&
        jsopencv_to_safe(jsobj_mask, mask, ArgInfo("mask", 0)))
    {
        ERRWRAP2_NAPI(info, cv::ximgproc::weightedMedianFilter(joint, src, dst, r, sigma, weightType, mask));
        return jsopencv_from(info, dst);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "weightedMedianFilter");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_segmentation_createGraphSegmentation(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc::segmentation;

    Napi::Value* jsobj_sigma = NULL;
    double sigma=0.5;
    Napi::Value* jsobj_k = NULL;
    float k=300;
    Napi::Value* jsobj_min_size = NULL;
    int min_size=100;
    Ptr<GraphSegmentation> retval;

    const char* keywords[] = { "sigma", "k", "min_size", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|OOO:createGraphSegmentation", (char**)keywords, &jsobj_sigma, &jsobj_k, &jsobj_min_size) &&
        jsopencv_to_safe(jsobj_sigma, sigma, ArgInfo("sigma", 0)) &&
        jsopencv_to_safe(jsobj_k, k, ArgInfo("k", 0)) &&
        jsopencv_to_safe(jsobj_min_size, min_size, ArgInfo("min_size", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ximgproc::segmentation::createGraphSegmentation(sigma, k, min_size));
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_segmentation_createSelectiveSearchSegmentation(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc::segmentation;

    Ptr<SelectiveSearchSegmentation> retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::ximgproc::segmentation::createSelectiveSearchSegmentation());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_segmentation_createSelectiveSearchSegmentationStrategyColor(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc::segmentation;

    Ptr<SelectiveSearchSegmentationStrategyColor> retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategyColor());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_segmentation_createSelectiveSearchSegmentationStrategyFill(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc::segmentation;

    Ptr<SelectiveSearchSegmentationStrategyFill> retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategyFill());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_segmentation_createSelectiveSearchSegmentationStrategyMultiple(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc::segmentation;

    jsPrepareArgumentConversionErrorsStorage(5);

    {
    Ptr<SelectiveSearchSegmentationStrategyMultiple> retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategyMultiple());
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_s1 = NULL;
    Ptr<SelectiveSearchSegmentationStrategy> s1;
    Ptr<SelectiveSearchSegmentationStrategyMultiple> retval;

    const char* keywords[] = { "s1", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:createSelectiveSearchSegmentationStrategyMultiple", (char**)keywords, &jsobj_s1) &&
        jsopencv_to_safe(jsobj_s1, s1, ArgInfo("s1", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategyMultiple(s1));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_s1 = NULL;
    Ptr<SelectiveSearchSegmentationStrategy> s1;
    Napi::Value* jsobj_s2 = NULL;
    Ptr<SelectiveSearchSegmentationStrategy> s2;
    Ptr<SelectiveSearchSegmentationStrategyMultiple> retval;

    const char* keywords[] = { "s1", "s2", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:createSelectiveSearchSegmentationStrategyMultiple", (char**)keywords, &jsobj_s1, &jsobj_s2) &&
        jsopencv_to_safe(jsobj_s1, s1, ArgInfo("s1", 0)) &&
        jsopencv_to_safe(jsobj_s2, s2, ArgInfo("s2", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategyMultiple(s1, s2));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_s1 = NULL;
    Ptr<SelectiveSearchSegmentationStrategy> s1;
    Napi::Value* jsobj_s2 = NULL;
    Ptr<SelectiveSearchSegmentationStrategy> s2;
    Napi::Value* jsobj_s3 = NULL;
    Ptr<SelectiveSearchSegmentationStrategy> s3;
    Ptr<SelectiveSearchSegmentationStrategyMultiple> retval;

    const char* keywords[] = { "s1", "s2", "s3", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO:createSelectiveSearchSegmentationStrategyMultiple", (char**)keywords, &jsobj_s1, &jsobj_s2, &jsobj_s3) &&
        jsopencv_to_safe(jsobj_s1, s1, ArgInfo("s1", 0)) &&
        jsopencv_to_safe(jsobj_s2, s2, ArgInfo("s2", 0)) &&
        jsopencv_to_safe(jsobj_s3, s3, ArgInfo("s3", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategyMultiple(s1, s2, s3));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_s1 = NULL;
    Ptr<SelectiveSearchSegmentationStrategy> s1;
    Napi::Value* jsobj_s2 = NULL;
    Ptr<SelectiveSearchSegmentationStrategy> s2;
    Napi::Value* jsobj_s3 = NULL;
    Ptr<SelectiveSearchSegmentationStrategy> s3;
    Napi::Value* jsobj_s4 = NULL;
    Ptr<SelectiveSearchSegmentationStrategy> s4;
    Ptr<SelectiveSearchSegmentationStrategyMultiple> retval;

    const char* keywords[] = { "s1", "s2", "s3", "s4", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO:createSelectiveSearchSegmentationStrategyMultiple", (char**)keywords, &jsobj_s1, &jsobj_s2, &jsobj_s3, &jsobj_s4) &&
        jsopencv_to_safe(jsobj_s1, s1, ArgInfo("s1", 0)) &&
        jsopencv_to_safe(jsobj_s2, s2, ArgInfo("s2", 0)) &&
        jsopencv_to_safe(jsobj_s3, s3, ArgInfo("s3", 0)) &&
        jsopencv_to_safe(jsobj_s4, s4, ArgInfo("s4", 0)))
    {
        ERRWRAP2_NAPI(info, retval = cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategyMultiple(s1, s2, s3, s4));
        return jsopencv_from(info, retval);
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "createSelectiveSearchSegmentationStrategyMultiple");

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_segmentation_createSelectiveSearchSegmentationStrategySize(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc::segmentation;

    Ptr<SelectiveSearchSegmentationStrategySize> retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategySize());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

static Napi::Value jsopencv_cv_ximgproc_segmentation_createSelectiveSearchSegmentationStrategyTexture(const Napi::CallbackInfo &info)
{
    using namespace cv::ximgproc::segmentation;

    Ptr<SelectiveSearchSegmentationStrategyTexture> retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(info, retval = cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategyTexture());
        return jsopencv_from(info, retval);
    }

    return info.Env().Null();
}

#endif
