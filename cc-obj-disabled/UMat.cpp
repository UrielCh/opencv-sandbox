// #include "../sandbox/sample.cpp"
#include "./UMat.h"
#include "../cc-common/jsopencv_custom_headers.h"

#include "../cc-common/cv2_convert.h"
#include "../cc-common/cv2_util.h"
#include "../cc-generated/jsopencv_generated_include.h"

using namespace cv;

// equivalent generated by CVJS_TYPE in jsopencv_generated_types.h

static Napi::Value jsopencv_UMat_Instance(const Napi::Env& env, const cv::Ptr<cv::UMat>& r) {
    Napi::Object newInstance = UMatWrapper::constructor.New({});
    UMatWrapper* wrapper = UMatWrapper::Unwrap(newInstance);
    wrapper->cvdata = r;
    return newInstance;
}

// equivalent generated in jsopencv_generated_types_content.h
template <>
struct JsOpenCV_Converter<Ptr<cv::UMat>> {
    static Napi::Value from(const Napi::Env& env, const Ptr<cv::UMat>& r) {
        // std::cout << "AKAZE from JsOpenCV_Converter<Ptr<cv::AKAZE>> " << std::endl;
        return jsopencv_UMat_Instance(env, r);
    }
    static bool to(Napi::Value* src, Ptr<cv::UMat>& dst, const ArgInfo& info) {
        if (!src || src->IsNull() || src->IsUndefined())
            return true;

        Napi::Object obj = src->As<Napi::Object>();    // Convert Napi::Value to Napi::Object
        if (!obj.Has(UMatWrapper::typeSymbol)) {  //  || !obj.Get(AKAZEWrapper::typeSymbol).As<Napi::Boolean>().Value())
            jsfailmsg(src->Env(), "Expected Ptr<cv::2DWrapper> for argument '%s'", info.name);
        }
        UMatWrapper* wrapper = UMatWrapper::Unwrap(obj);  // Unwrap the Napi::Object to get AKAZEWrapper instance
        dst = wrapper->cvdata;                                      // Access the cvdata member
        return false;
    }
};


// New aproche, no equivalent
// common code for all types
Napi::FunctionReference UMatWrapper::constructor;
Napi::Symbol UMatWrapper::typeSymbol;
UMatWrapper::~UMatWrapper() {
    this->cvdata.release();
}
///


// all nethod generated in jsopencv_generated_types_content.h



// Wrapped methods
Napi::Value UMatWrapper::get(const Napi::CallbackInfo &info) {
    Napi::Env env = info.Env();
    Ptr<cv::UMat> _self_ = this->cvdata;
    Mat retval;
    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(env, retval = cv_UMat_get(_self_));
        return jsopencv_from(env, retval);
    }
    return env.Null();
}

Napi::Value UMatWrapper::handle(const Napi::CallbackInfo &info) {
    Napi::Env env = info.Env();
    Ptr<cv::UMat> _self_ = this->cvdata;
    Napi::Value* jsobj_accessFlags = NULL;
    AccessFlag accessFlags=static_cast<AccessFlag>(0);
    void* retval;
    const char* keywords[] = { "accessFlags", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:UMat.handle", (char**)keywords, &jsobj_accessFlags) &&
        jsopencv_to_safe(jsobj_accessFlags, accessFlags, ArgInfo("accessFlags", 0)))
    {
        ERRWRAP2_NAPI(env, retval = _self_->handle(accessFlags));
        return jsopencv_from(env, retval);
    }
    return env.Null();
}

Napi::Value UMatWrapper::isContinuous(const Napi::CallbackInfo &info) {
    Napi::Env env = info.Env();
    Ptr<cv::UMat> _self_ = this->cvdata;
    bool retval;

    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(env, retval = _self_->isContinuous());
        return jsopencv_from(env, retval);
    }

    return env.Null();
}

Napi::Value UMatWrapper::isSubmatrix(const Napi::CallbackInfo &info) {
    Napi::Env env = info.Env();
    Ptr<cv::UMat> _self_ = this->cvdata;
    bool retval;
    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(env, retval = _self_->isSubmatrix());
        return jsopencv_from(env, retval);
    }
    return env.Null();
}


// Static methods
Napi::Value UMatWrapper::context(const Napi::CallbackInfo &info) {
    Napi::Env env = info.Env();
    void* retval;
    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(env, retval = cv_UMat_context());
        return jsopencv_from(env, retval);
    }
    return env.Null();
}
// static
Napi::Value UMatWrapper::queue(const Napi::CallbackInfo &info) {
    Napi::Env env = info.Env();
    void* retval;
    if (info.Length() == 0 || (info.Length() == 1 && info[0].IsObject() && info[0].IsEmpty()))
    {
        ERRWRAP2_NAPI(env, retval = cv_UMat_queue());
        return jsopencv_from(env, retval);
    }
    return env.Null();
}



// Static methods
// Napi::Value UMatWrapper::CreateStatic(const Napi::CallbackInfo& info) {
//     Napi::FunctionReference* constructor = info.Env().GetInstanceData<Napi::FunctionReference>();
//     return constructor->New(CallbackInfoToVector(info));
// }

// complet reformat of JsGetSetDef jsopencv_XXX_getseters[] and jsopencv_XXX_methods from jsopencv_generated_types_content.h
Napi::Object UMatWrapper::Init(Napi::Env env, Napi::Object exports) {
    Napi::HandleScope scope(env);
    napi_property_attributes atts = static_cast<napi_property_attributes>(napi_writable | napi_configurable);
    // link definition to prototype
    Napi::Function func = DefineClass(env, "UMat", {
                                                                // properties
                                                                InstanceAccessor<&UMatWrapper::get_offset>("offset"),
                                                                // methods
                                                                InstanceMethod<&UMatWrapper::get>("get", atts),
                                                                InstanceMethod<&UMatWrapper::handle>("handle", atts),
                                                                InstanceMethod<&UMatWrapper::isContinuous>("isContinuous", atts),
                                                                InstanceMethod<&UMatWrapper::isSubmatrix>("isSubmatrix", atts),
                                                                // Static
                                                                StaticMethod<&UMatWrapper::context>("context", atts),
                                                                StaticMethod<&UMatWrapper::queue>("queue", atts),
                                                            });
    constructor = Napi::Persistent(func);
    constructor.SuppressDestruct();
    // Add the symbol to the AKAZEWrapper prototype
    typeSymbol = Napi::Symbol::New(env, "cv2.UMat");  // or "UMatWrapper" m can be use for class debugging
    constructor.Value().Set(typeSymbol, Napi::Boolean::New(env, true));
    env.SetInstanceData<Napi::FunctionReference>(&constructor);
    exports.Set("UMat", func);
    return exports;
}

// constructor generated in jsopencv_generated_types_content.h
UMatWrapper::UMatWrapper(const Napi::CallbackInfo& info)
    : Napi::ObjectWrap<UMatWrapper>(info) {
    Napi::Env env = info.Env();

    jsPrepareArgumentConversionErrorsStorage(9);

    {
    Napi::Value* jsobj_usageFlags = NULL;
    UMatUsageFlags usageFlags=USAGE_DEFAULT;

    const char* keywords[] = { "usageFlags", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "|O:UMat", (char**)keywords, &jsobj_usageFlags) &&
        jsopencv_to_safe(jsobj_usageFlags, usageFlags, ArgInfo("usageFlags", 0)))
    {
        Napi::Object *self = &info.This().As<Napi::Object>();
        Ptr<cv::UMat> *data = (Ptr<cv::UMat> *)self->Get("v").As<Napi::Buffer<char>>().Data();
        new (data) Ptr<cv::UMat>(); // init Ptr with placement new
        if(data) ERRWRAP2_NAPI_VOID(env, data->reset(new cv::UMat(usageFlags)));
        return 0;
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_rows = NULL;
    int rows=0;
    Napi::Value* jsobj_cols = NULL;
    int cols=0;
    Napi::Value* jsobj_type = NULL;
    int type=0;
    Napi::Value* jsobj_usageFlags = NULL;
    UMatUsageFlags usageFlags=USAGE_DEFAULT;

    const char* keywords[] = { "rows", "cols", "type", "usageFlags", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:UMat", (char**)keywords, &jsobj_rows, &jsobj_cols, &jsobj_type, &jsobj_usageFlags) &&
        jsopencv_to_safe(jsobj_rows, rows, ArgInfo("rows", 0)) &&
        jsopencv_to_safe(jsobj_cols, cols, ArgInfo("cols", 0)) &&
        jsopencv_to_safe(jsobj_type, type, ArgInfo("type", 0)) &&
        jsopencv_to_safe(jsobj_usageFlags, usageFlags, ArgInfo("usageFlags", 0)))
    {
        Napi::Object *self = &info.This().As<Napi::Object>();
        Ptr<cv::UMat> *data = (Ptr<cv::UMat> *)self->Get("v").As<Napi::Buffer<char>>().Data();
        new (data) Ptr<cv::UMat>(); // init Ptr with placement new
        if(data) ERRWRAP2_NAPI_VOID(env, data->reset(new cv::UMat(rows, cols, type, usageFlags)));
        return 0;
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_size = NULL;
    Size size;
    Napi::Value* jsobj_type = NULL;
    int type=0;
    Napi::Value* jsobj_usageFlags = NULL;
    UMatUsageFlags usageFlags=USAGE_DEFAULT;

    const char* keywords[] = { "size", "type", "usageFlags", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:UMat", (char**)keywords, &jsobj_size, &jsobj_type, &jsobj_usageFlags) &&
        jsopencv_to_safe(jsobj_size, size, ArgInfo("size", 0)) &&
        jsopencv_to_safe(jsobj_type, type, ArgInfo("type", 0)) &&
        jsopencv_to_safe(jsobj_usageFlags, usageFlags, ArgInfo("usageFlags", 0)))
    {
        Napi::Object *self = &info.This().As<Napi::Object>();
        Ptr<cv::UMat> *data = (Ptr<cv::UMat> *)self->Get("v").As<Napi::Buffer<char>>().Data();
        new (data) Ptr<cv::UMat>(); // init Ptr with placement new
        if(data) ERRWRAP2_NAPI_VOID(env, data->reset(new cv::UMat(size, type, usageFlags)));
        return 0;
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_rows = NULL;
    int rows=0;
    Napi::Value* jsobj_cols = NULL;
    int cols=0;
    Napi::Value* jsobj_type = NULL;
    int type=0;
    Napi::Value* jsobj_s = NULL;
    Scalar s;
    Napi::Value* jsobj_usageFlags = NULL;
    UMatUsageFlags usageFlags=USAGE_DEFAULT;

    const char* keywords[] = { "rows", "cols", "type", "s", "usageFlags", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOOO|O:UMat", (char**)keywords, &jsobj_rows, &jsobj_cols, &jsobj_type, &jsobj_s, &jsobj_usageFlags) &&
        jsopencv_to_safe(jsobj_rows, rows, ArgInfo("rows", 0)) &&
        jsopencv_to_safe(jsobj_cols, cols, ArgInfo("cols", 0)) &&
        jsopencv_to_safe(jsobj_type, type, ArgInfo("type", 0)) &&
        jsopencv_to_safe(jsobj_s, s, ArgInfo("s", 0)) &&
        jsopencv_to_safe(jsobj_usageFlags, usageFlags, ArgInfo("usageFlags", 0)))
    {
        Napi::Object *self = &info.This().As<Napi::Object>();
        Ptr<cv::UMat> *data = (Ptr<cv::UMat> *)self->Get("v").As<Napi::Buffer<char>>().Data();
        new (data) Ptr<cv::UMat>(); // init Ptr with placement new
        if(data) ERRWRAP2_NAPI_VOID(env, data->reset(new cv::UMat(rows, cols, type, s, usageFlags)));
        return 0;
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_size = NULL;
    Size size;
    Napi::Value* jsobj_type = NULL;
    int type=0;
    Napi::Value* jsobj_s = NULL;
    Scalar s;
    Napi::Value* jsobj_usageFlags = NULL;
    UMatUsageFlags usageFlags=USAGE_DEFAULT;

    const char* keywords[] = { "size", "type", "s", "usageFlags", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OOO|O:UMat", (char**)keywords, &jsobj_size, &jsobj_type, &jsobj_s, &jsobj_usageFlags) &&
        jsopencv_to_safe(jsobj_size, size, ArgInfo("size", 0)) &&
        jsopencv_to_safe(jsobj_type, type, ArgInfo("type", 0)) &&
        jsopencv_to_safe(jsobj_s, s, ArgInfo("s", 0)) &&
        jsopencv_to_safe(jsobj_usageFlags, usageFlags, ArgInfo("usageFlags", 0)))
    {
        Napi::Object *self = &info.This().As<Napi::Object>();
        Ptr<cv::UMat> *data = (Ptr<cv::UMat> *)self->Get("v").As<Napi::Buffer<char>>().Data();
        new (data) Ptr<cv::UMat>(); // init Ptr with placement new
        if(data) ERRWRAP2_NAPI_VOID(env, data->reset(new cv::UMat(size, type, s, usageFlags)));
        return 0;
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_m = NULL;
    UMat m;

    const char* keywords[] = { "m", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "O:UMat", (char**)keywords, &jsobj_m) &&
        jsopencv_to_safe(jsobj_m, m, ArgInfo("m", 0)))
    {
        Napi::Object *self = &info.This().As<Napi::Object>();
        Ptr<cv::UMat> *data = (Ptr<cv::UMat> *)self->Get("v").As<Napi::Buffer<char>>().Data();
        new (data) Ptr<cv::UMat>(); // init Ptr with placement new
        if(data) ERRWRAP2_NAPI_VOID(env, data->reset(new cv::UMat(m)));
        return 0;
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_m = NULL;
    UMat m;
    Napi::Value* jsobj_rowRange = NULL;
    Range rowRange;
    Napi::Value* jsobj_colRange = NULL;
    Range colRange=Range::all();

    const char* keywords[] = { "m", "rowRange", "colRange", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO|O:UMat", (char**)keywords, &jsobj_m, &jsobj_rowRange, &jsobj_colRange) &&
        jsopencv_to_safe(jsobj_m, m, ArgInfo("m", 0)) &&
        jsopencv_to_safe(jsobj_rowRange, rowRange, ArgInfo("rowRange", 0)) &&
        jsopencv_to_safe(jsobj_colRange, colRange, ArgInfo("colRange", 0)))
    {
        Napi::Object *self = &info.This().As<Napi::Object>();
        Ptr<cv::UMat> *data = (Ptr<cv::UMat> *)self->Get("v").As<Napi::Buffer<char>>().Data();
        new (data) Ptr<cv::UMat>(); // init Ptr with placement new
        if(data) ERRWRAP2_NAPI_VOID(env, data->reset(new cv::UMat(m, rowRange, colRange)));
        return 0;
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_m = NULL;
    UMat m;
    Napi::Value* jsobj_roi = NULL;
    Rect roi;

    const char* keywords[] = { "m", "roi", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:UMat", (char**)keywords, &jsobj_m, &jsobj_roi) &&
        jsopencv_to_safe(jsobj_m, m, ArgInfo("m", 0)) &&
        jsopencv_to_safe(jsobj_roi, roi, ArgInfo("roi", 0)))
    {
        Napi::Object *self = &info.This().As<Napi::Object>();
        Ptr<cv::UMat> *data = (Ptr<cv::UMat> *)self->Get("v").As<Napi::Buffer<char>>().Data();
        new (data) Ptr<cv::UMat>(); // init Ptr with placement new
        if(data) ERRWRAP2_NAPI_VOID(env, data->reset(new cv::UMat(m, roi)));
        return 0;
    }


        jsPopulateArgumentConversionErrors(info);
    }
    

    {
    Napi::Value* jsobj_m = NULL;
    UMat m;
    Napi::Value* jsobj_ranges = NULL;
    vector_Range ranges;

    const char* keywords[] = { "m", "ranges", NULL };
    if (JsArg_ParseTupleAndKeywords(info, "OO:UMat", (char**)keywords, &jsobj_m, &jsobj_ranges) &&
        jsopencv_to_safe(jsobj_m, m, ArgInfo("m", 0)) &&
        jsopencv_to_safe(jsobj_ranges, ranges, ArgInfo("ranges", 0)))
    {
        Napi::Object *self = &info.This().As<Napi::Object>();
        Ptr<cv::UMat> *data = (Ptr<cv::UMat> *)self->Get("v").As<Napi::Buffer<char>>().Data();
        new (data) Ptr<cv::UMat>(); // init Ptr with placement new
        if(data) ERRWRAP2_NAPI_VOID(env, data->reset(new cv::UMat(m, ranges)));
        return 0;
    }


        jsPopulateArgumentConversionErrors(info);
    }
    jsRaiseCVOverloadException(info, "UMat");

    return -1;

}
